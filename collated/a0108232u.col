//@author: a0108232u



	/**
	 * origin: C:\Users\GamePro-Pc\Desktop\Work\Y2S2\CS2103\main\source\src\planner\Constants.java
	 */

    public enum CommandType {
        ADD, ADD_CLASH, UPDATE, DELETE, SHOW, SHOW_ALL, SHOW_ONE, DONE, 
        SETNOTDONE, UNDO, SEARCH, HELP, HELP_ADD, HELP_UPDATE, HELP_DELETE, 
        HELP_SHOW, HELP_DONE, HELP_UNDO, HELP_SEARCH, JUMP, CONVERT, 
        CONVERT_FLOATING, CONVERT_DEADLINE, CONVERT_TIMED, SAVEWHERE, SAVEHERE, 
        INVALID, EXIT
    };
    
    public enum ErrorType {
        INVALID_COMMAND, INVALID_TASK_ID, BLANK_TASK_NAME, INVALID_DATE,
        INVALID_NUMBER_OF_DATES, INVALID_TIME, DATE1_NOT_SMALLER_THAN_DATE2,
        INVALID_PRIORITY_LEVEL, TASK_NOT_FOUND, CONVERT_TASK_TYPE_IN_UPDATE,
        UPDATE_NO_CHANGES, NOTHING_TO_UNDO, NO_INPUT, INVALID_PATH
    };

    public enum TipType{
        UP_TIP, DOWN_TIP, UPDOWN_TIP
    }
    
    public enum DisplayStateFlag {
        ALL, TODAY, TENTATIVE, OVERDUE, UPCOMING, DONE, NOTDONE, WORD_SEARCH, PRIORITY_SEARCH, INVALID,
        HELP, HELP_ADD, HELP_UPDATE, HELP_DELETE, HELP_DONE, HELP_UNDO, HELP_SEARCH, HELP_PRIORITY_SEARCH,
        SETTINGS
    }
	// End of segment: C:\Users\GamePro-Pc\Desktop\Work\Y2S2\CS2103\main\source\src\planner\Constants.java





	/**
	 * origin: C:\Users\GamePro-Pc\Desktop\Work\Y2S2\CS2103\main\source\src\planner\Constants.java
	 */

    public static final String[] COMMAND_KEYWORDS = {"add", "new", "update", 
        "edit", "change", "del", "delete", "trash", "remove", "show", "display", 
        "done", "completed", "finished", "setnotdone", "undo", "revert", 
        "search", "find", "help", "sos", "jump", "convert", "savewhere", 
        "savehere", "exit" 
    };
    
    public static final String[] NONCOMMAND_KEYWORDS = { "at",
        "on", "date", "from", "by", "due", "until", "to", "jump",
        "priority", "desc", "description", "remind", "tag" };
    

    public static final int ADD_TUTORIAL = 0;
    public static final int DELETE_TUTORIAL = 1;
    public static final int UPDATE_TUTORIAL = 2;
    public static final int DONE_TUTORIAL = 3;
    public static final int SETNOTDONE_TUTORIAL = 4;
    public static final int UNDO_TUTORIAL = 5;
    public static final int SEARCH_TUTORIAL = 6;
    public static final int HELP_TUTORIAL =7;
    public static final int SAVEHERE_TUTORIAL = 8;
    public static final int SAVEWHERE_TUTORIAL = 9;
    public static final int CMD_HISTORY_TUTORIAL = 10;
    public static final int SCROLL_INFOPANEL_CMD_HISTORY_TUTORIAL = 11;
    public static final int CYCLE_PREVIOUS_COMMANDS_TURORIAL = 12;
    
    /**
     * Contains the information for the dropdown box at the GUI input bar.
     */
    public static final String [][] POSSIBLE_COMMANDS = { 
        {"Add tasks (fields besides name optional)", 
         "add <taskname>",
         "add <taskname> by <date>", 
         "add <taskname> date <start date> date2 <end date>",
         "add <taskname> at <date> priority <priority level> desc <description info> tag <tagname>",
         "add exampletask at 5 april 2015 pm 7.00 priority 5 desc exampledescription tag exampletag",
         "new <taskname>",
         "new <taskname> by <date>", 
         "new <taskname> date <start date> date2 <end date>",
         "new <taskname> at <date> priority <priority level> desc <description info> tag <tagname>",
         "new exampletask at 5 april 2015 pm 7.00 priority 5 desc exampledescription tag exampletag",
         "create <taskname>",
         "create <taskname> by <date>", 
         "create <taskname> date <start date> date2 <end date>",
         "create <taskname> at <date> priority <priority level> desc <description info> tag <tagname>", 
         "create exampletask at 5 april 2015 pm 7.00 priority 5 desc exampledescription tag exampletag",
        },
        {"Delete tasks", 
         "delete <task id>",
         "trash <task id>",
         "remove <task id>",
         "del <task id>"
        },
        {"Update tasks (number of fields to update optional)", 
         "update <task id> on <date> priority <priority level> desc <description info> tag <tagname>",
         "update 1 name at 5 april 2015 pm 7.00 priority 5 desc exampledescription tag exampletag",
         "edit <task id> on <date> priority <priority level> desc <description info> tag <tagname>",
         "edit 1 name at 5 april 2015 pm 7.00 priority 5 desc exampledescription tag exampletag",
         "change <task id> on <date> priority <priority level> desc <description info> tag <tagname>",
         "change 1 name at 5 april 2015 pm 7.00 priority 5 desc exampledescription tag exampletag",
        },
        {"Done",
         "done <task id>",
         "completed <task id>",
         "finished <task id>"
        },
        {"Setnotdone",
         "setnotdone <task id>"
        },
        {"Undo previous modification",
         "undo",
         "revert",              
        },
        {"Search tasks (number of fields to search by optional)",
         "search <task name> on <date> priority <priority level> desc <description info> tag <tagname>",
         "search examplename at 5 april 2015 pm 7.00 priority 5 desc exampledescription tag exampletag",
         "find <task name> on <date> priority <priority level> desc <description info> tag <tagname>",
         "find examplename at 5 april 2015 pm 7.00 priority 5 desc exampledescription tag exampletag",
        },
        {"Help",
         "help",
         "sos"
        },
        {"Savehere",
         "savehere /<full file path>"   
        },
        {"Savewhere",
         "savewhere"
        },
        {"Exit",
         "exit",
         "quit",
         "bye"
        }
    };
    
    /**
     * Contains the information for the GUI help window.
     */
    public static final String [][] HELP_CONTENT = {
        {"Add tasks (fields besides name optional)", 
         "Equivalent commands: add/create/new\n\nThis command will add the task into YOPO. You can use this command together with description, time, priority and tag.\n\nExample usage: add revise CS2103\n\n[This will add revise CS2103T as one of the task to complete in YOPO]",
         "Example usage: add revise CS2103"
        },
        {"Delete tasks",
         "Equivalent commands: delete/del/trash/remove\n\nThis command deletes the task with the specific id.\n\nExample usage: delete 143\n\n[This will delete item 143 from the task list]",
         "Example usage: delete 143"
        },
        {"Update tasks (number of fields to update optional)",
         "Equivalent commands: update/edit/change\n\nThis command will update the task with the specified id with the information provided.\n\nExample usage: update 143 revise CS2103T\n\n[This will update item 143 to the name revise CS2103T]",
         "Example usage: update 143 revise CS2103T"
        },
        {"Set tasks as done",
         "Equivalent commands: done/completed/finished\n\nThis command marks the task with the specified id as done.\n\nExample usage: done 143\n\n[This will mark item 143 as done]",
         "Example usage: done 143"
        },
        {"Set tasks as not done",
         "This command marks the task with the specified id as not done.\n\nExample usage: setnotdone 271\n\n[This will mark item 271 as not done]",
         "Example usage: setnotdone 271"
        },
        {"Undo previous modification",
         "This command undoes the previous command entered that changed the data.\n\nExample usage: undo\n\n[This will undo the previous command]",
         "Example usage: undo"
        },
        {"Search tasks (number of fields to search by optional)",
         "Equivalent commands: search/find\n\nThis command will search all tasks stored in YOPO and display all tasks matching the criteria the user specified.\n\nExample usage: search priority 4 description important\n\n[This will display all tasks with priority 4 and above and description containing the word important]",
         "Example usage: search priority 4 description important"
        },
        {"Help",
         "Equivalent commands: help/sos\n\nThis command will bring out the help message, listing the available commands.\n\nExample usage: help\n\n[This will show this help window]",
         "Example usage: help"
        },
        {"Changing save data location",
         "format: savehere <full file path>\n\nThis command causes all program files to be saved in the location specified by <full file path>\n\nExample usage: save here C:\\\n\n[This will cause all program files to be saved in C:\\]",
         "Example usage: save here C:\\\\"
        },
        {"Finding out save data location",
         "This command will cause the current save location for program files to be displayed in the display box.\n\nExample usage: savewhere\n\n[This causes the current save location for program files to be displayed in the display box]",
         "Example usage: savewhere"
        },
        {"Exit",
         "Equivalent commands: exit/quit/bye\n\nThis command will cause the program to exit.\n\nExample usage: exit\n\n[This will exit the program]",
         "Example usage: exit"
        },
        {"Show command history",
         "This shortcut will display your past commands and their results.\n\nExample usage: Shift + F1\n\n[This causes your command history to be displayed in the side panel]",
         "Example usage: Shift \\+ F1"
        },
        {"Scroll through info panel or command history",
         "This will scroll through your info panel or command history.\n\nExample usage: Ctrl + down/up arrow key\n\n[This scrolls through the info panel/command history]",
         "Example usage: Ctrl \\+ down\\/up arrow key"
        },
        {"Cycle through previous commands",
         "This will cycle through the commands you previously input.\n\nExample usage: Shift + down/up arrow key\n\n[This cycles through your previous commands in the input box]",
         "Example usage: Shift \\+ down\\/up arrow key"
        }
    };

    public static String[] NAVIGATION_BAR_STRING_CONTENTS = { "More info for task #",           // F1
                                                              "Previous View",                  // F2
                                                              "Tutorial",                       // F3
                                                              " Task due today",                // F4
                                                              " Tasks due today",
                                                              " Task in total",                 // F5
                                                              " Tasks in total",
                                                              " Upcoming Task",                 // F6
                                                              " Upcoming Tasks",
                                                              " Floating Task",                // F7
                                                              " Floating Tasks",
                                                              " Overdue Task",                  // F8
                                                              " Overdue Tasks",
                                                              " Task Done",                     // F9
                                                              " Tasks Done",
                                                              " Task not Done",                 // F10
                                                              " Tasks not Done"};                   
    
    public static Color[] COLOR_SERIES = { new Color( 239, 52, 65 ),
                                           new Color( 244, 132, 57 ),
                                           new Color( 224, 226, 54 ),
                                           new Color( 47, 244, 237 ),
                                           new Color( 74, 243, 110 ),
                                           new Color( 242, 141, 236 ),
                                           new Color( 245, 142, 142 ) };
    
    public static final String CONFIG_FILE_NAME = "config";
    public static final String DEFAULT_STORAGE_NAME = "data";

    public static final int NO_PRIORITY_LEVEL = 0;
    public static final int NO_ID_SET = 0;
    public static final int NAVIGATION_BAR_STRING_CONTENTS_SIZE = 17;
    public static final int NAVIGATION_BARS_MAX_NUM = 10;
    
    public static EnumMap<ErrorType, String> errorMessages = new EnumMap<ErrorType, String>(ErrorType.class);

    public static void initializeErrorMessages() {

        errorMessages.put(ErrorType.INVALID_COMMAND, "invalid command type");
        errorMessages.put(ErrorType.INVALID_TASK_ID, "a number must be entered for the task id");
        errorMessages.put(ErrorType.BLANK_TASK_NAME, "the name of the task added cannot be blank");
        errorMessages.put(ErrorType.INVALID_DATE, "Unable to parse date");
        errorMessages.put(ErrorType.INVALID_TIME, "Unable to parse time");
        errorMessages.put(ErrorType.INVALID_PRIORITY_LEVEL, "Please input a priority level from 1 to 5");
        errorMessages.put(ErrorType.DATE1_NOT_SMALLER_THAN_DATE2, "Please input a start date earlier than the end date");
        errorMessages.put(ErrorType.INVALID_NUMBER_OF_DATES, "Please input the correct number of dates for convert");
        
        //Errors from Engine
        errorMessages.put(ErrorType.TASK_NOT_FOUND, "Task not found!");
        errorMessages.put(ErrorType.CONVERT_TASK_TYPE_IN_UPDATE, "Conversion of"
                + " Task type not allowed in update. Use the convert command");
        errorMessages.put(ErrorType.UPDATE_NO_CHANGES, "No changes in"
                + " update command!");
        errorMessages.put(ErrorType.NOTHING_TO_UNDO, "No actions to undo!");
        errorMessages.put(ErrorType.NO_INPUT, "Please enter a command.");
        errorMessages.put(ErrorType.INVALID_PATH, "Path provided is invalid");
    }
    
	// End of segment: C:\Users\GamePro-Pc\Desktop\Work\Y2S2\CS2103\main\source\src\planner\Constants.java





	/**
	 * origin: C:\Users\GamePro-Pc\Desktop\Work\Y2S2\CS2103\main\source\src\planner\Parser.java
	 */

package planner;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Calendar;
import java.util.Date;
import java.util.logging.Level;
import java.util.logging.Logger;

import planner.Constants.CommandType;
import planner.Constants.ErrorType;

/**
 * This class contains all the logic for parsing
 * user commands into useful information for
 * the engine. 
 */
public class Parser {

    private static Logger logger = Logger.getLogger("Parser");    
    
    // stores the arguments for each keyword
    private static String keywordArgs = "";
    
    // stores the tokens of the user input delimited by spaces
    private static String[] inputTokens = null;
    
    // all keywords that are not a command
    private static String[] nonCommandKeywordsArray = {"at", "on", "from", "by",
        "priority", "desc", "description", "date", "due",
        "remind", "tag", "until", "to"  
    };
    private static ArrayList<String> nonCommandKeywords =
            new ArrayList<String>(Arrays.asList(nonCommandKeywordsArray));
    
    // common ways to type months
    private static String[] monthsArray = {"jan", "january", "feb", "february",
        "mar", "march", "apr", "april", "may", "may", "jun", "june", "jul",
        "july", "aug", "august", "sep", "september", "oct", "october", "nov",
        "november", "dec", "december"
    };
    private static ArrayList<String> months =
            new ArrayList<String>(Arrays.asList(monthsArray));
    
    // common ways to type days
    private static String[] daysInWeek = {"mon", "monday", "tue", "tuesday", 
        "wed", "wednesday", "thu", "thursday", "fri", "friday", "sat", 
        "saturday", "sun", "sunday"
    };
    private static ArrayList<String> days =
            new ArrayList<String>(Arrays.asList(daysInWeek));
    
    // command types that will not take into account any keywords besides the
    // command itself
    private static String[] cmdsWithoutFollowingKeywords = {"help", "undo",
        "delete", "done", "setnotdone", "savewhere", "savehere", "show", "exit"
    };
    private static ArrayList<String> monoKeywordCommands =
            new ArrayList<String>(Arrays.asList(cmdsWithoutFollowingKeywords));
    
    private static final int COMMAND_WORD_INDEX = 0;
    private static final int FIRST_ARG = 0;
    private static final int SECOND_ARG = 1;
    private static final int THIRD_ARG = 2;
    private static final int FOURTH_ARG = 3;
    private static final int NEXT_ARG = 1;
    private static final int FIRST_AFTER_COMMAND_TYPE = 1;
    private static final int HALF_DAY_IN_HOURS = 12;
    private static final int DATE_1_INDEX = 1;
    private static final int DATE_2_INDEX = 2;
    private static final int NO_PRIORITY_LVL = 0;
    private static final int LOWEST_PRIORITY_LVL = 1;
    private static final int HIGHEST_PRIORITY_LVL = 5;
    private static final int DATE_TO_REMIND_INDEX = 3;
    private static final int ONE_WORD = 1;
    private static final int FLAGS_SIZE = 8;
    private static final int DATE_FLAG = 0;
    private static final int DATE_TO_REMIND_FLAG = 1;
    private static final int PRIORITY_LVL_FLAG = 2;
    private static final int ID_FLAG = 3;
    private static final int NAME_FLAG = 4;
    private static final int DESC_FLAG = 5;
    private static final int TAG_FLAG = 6;
    private static final int DATE_2_FLAG = 7;
    private static final int FIRST_TOKEN = 0;
    private static final int ALL_DATE_ARGS = 5;
    private static final int CORRECT_NO_TIME_ARGS = 2;
    private static final int ONLY_DAY_ARG = 1;
    private static final int DAY_AND_MONTH_ARGS = 2;
    private static final int ZERO_HOURS = 0;
    private static final int ZERO_MINUTES = 0;
    private static final int ZERO_SECONDS = 0;
    private static final int ONE_DAY = 1;
    private static final int ONE_MONTH = 1;
    private static final int FIRST_MONTH = 0;
    private static final int ONE_YEAR = 1;
    private static final int DAYS_IN_WEEK = 7;
    private static final int WEEK_DIFFERENCE_IN_DAYS = 0;
    private static final int MONTH_ENGLISH_VARIATIONS = 2;
    private static final int DAY_ENGLISH_VARIATIONS = 2;
    private static final int SMALLEST_HOUR = 0;
    private static final int BIGGEST_HOUR = 12;
    private static final int BIGGEST_24_HOUR_HOUR = 23;
    private static final int SMALLEST_MIN = 0;
    private static final int BIGGEST_MIN = 59;
    private static final int NOT_FOUND = -1;
    private static final String ADD_COMMAND_STR = "add";
    private static final String UPDATE_COMMAND_STR = "update";
    private static final String DEL_COMMAND_STR = "delete";
    private static final String SHOW_COMMAND_STR = "show";
    private static final String DONE_COMMAND_STR = "done";
    private static final String SETNOTDONE_COMMAND_STR = "setnotdone";
    private static final String UNDO_COMMAND_STR = "undo";
    private static final String SEARCH_COMMAND_STR = "search";
    private static final String HELP_COMMAND_STR = "help";
    private static final String JUMP_COMMAND_STR = "jump";
    private static final String CONVERT_COMMAND_STR = "convert";
    private static final String SAVEWHERE_COMMAND_STR = "savewhere";
    private static final String SAVEHERE_COMMAND_STR = "savehere";
    private static final String EXIT_COMMAND_STR = "exit";    
    private static final String DATE_KEYWORD = "date";
    private static final String DEADLINE_TYPE = "deadline";
    private static final String TIMED_TYPE = "timed";
    private static final String FLOATING_TYPE = "floating";
    private static final String PM = "pm";
    private static final String AM = "am";
    private static final String NEXT_KEYWORD = "next";
    private static final String TIME_DELIMITER = "\\.";
    
    // these fields will be used to construct the parseResult
    private static ErrorType errorType = null;
    private static CommandType commandType = null;    
    private static Date date = null;
    private static Date date2 = null;
    private static Date dateToRemind = null;
    private static int priorityLevel = NO_PRIORITY_LVL;
    private static long id = 0;
    private static String name = "";
    private static String description = "";
    private static String tag = "";
    private static boolean isTimeSetByUser = false;
    private static boolean isTime2SetByUser = false;
    private static boolean isParseDateComplete = false;
    private static boolean[] flags = new boolean[FLAGS_SIZE];
    private static Calendar desiredTime = null;
    
    // fields used for parsing date
    private static int year = 0;
    private static int month = 0;
    private static int day = 0;
    
    /**
     * Processes a user input string and returns a result object containing
     * information such as the user's desired command type and the relevant
     * fields to update.
     * 
     * @param inputString The user input.
     * @return            A result containing information such as command type.
     */
    public static ParseResult parse(String inputString) {
        logger.setLevel(Level.WARNING);
        resetFields();
        process(inputString.trim());
        return createParseResult(commandType); 
    }
    
    /**
     * Processes the input string by updating the result fields based on what 
     * the command type is.
     * 
     * @param inputString The user input.
     * @return            A result containing information such as command type.
     */
    private static void process(String inputString) {
        inputTokens = splitBySpaceDelimiter(inputString);
        assert(inputTokens.length > 0);
        commandType = determineCommandType(inputTokens[COMMAND_WORD_INDEX]);
        processDependingOnCommandType(commandType);
    }
    
    /**
     * Tokenizes a string input.
     * 
     * @param input Input string.
     * @return      Array of tokens.
     */
    private static String[] splitBySpaceDelimiter(String input) {
        return input.split(" ");
    }

    /**
     * Determines the type of command a user wants to execute given the input
     * token expected to be a valid command keyword.
     * 
     * @param commandWord Command keyword.
     * @return            Type of command.
     */
    private static CommandType determineCommandType(String commandWord) {
        switch(commandWord.toLowerCase()) {
            case "add":
            case "new":
                return CommandType.ADD;

            case "update":
            case "edit":
            case "change":
                return CommandType.UPDATE;

            case "delete":
            case "trash":
            case "remove":
            case "del":
                return CommandType.DELETE;

            case "show":
            case "display":
                // at this point, undetermined if showing one task or all
                return CommandType.SHOW;

            case "done":
            case "completed":
            case "finished":
                return CommandType.DONE;
                
            case "setnotdone":
                return CommandType.SETNOTDONE;

            case "undo":
            case "revert":
                return CommandType.UNDO;

            case "search":
            case "find":
                return CommandType.SEARCH;

            case "help":
            case "sos":
                return CommandType.HELP;
                
            case "jump":
                return CommandType.JUMP;
                
            case "convert":
                return CommandType.CONVERT;
                
            case "savewhere":
                return CommandType.SAVEWHERE;
                
            case "savehere":
                return CommandType.SAVEHERE;
                
            case "exit":
                return CommandType.EXIT;

            default:
                return CommandType.INVALID;
        }
    }
    
    /**
     * Given the command type, processes the rest of the input depending on 
     * what the command is. The command type is converted to a string for 
     * convenience in processing.
     * 
     * @param commandType Type of command being parsed.
     */
    private static void processDependingOnCommandType(CommandType commandType) {
        switch(commandType) {
            case ADD:
                processCommand(ADD_COMMAND_STR);
                break;
                
            case UPDATE:
                processCommand(UPDATE_COMMAND_STR);
                break;
                
            case DELETE:
                processCommand(DEL_COMMAND_STR);
                break;
                
            case SHOW:
                processCommand(SHOW_COMMAND_STR);
                break;
                
            case DONE:
                processCommand(DONE_COMMAND_STR);
                break;
            
            case SETNOTDONE:
                processCommand(SETNOTDONE_COMMAND_STR);
                break;
                
            case UNDO:
                processCommand(UNDO_COMMAND_STR);
                break;
                
            case SEARCH:
                processCommand(SEARCH_COMMAND_STR);
                break;
                
            case HELP:
                processCommand(HELP_COMMAND_STR);
                break;
            
            case JUMP:
                processCommand(JUMP_COMMAND_STR);
                break;
                
            case CONVERT:
                processCommand(CONVERT_COMMAND_STR);
                break;
                
            case SAVEWHERE:
                processCommand(SAVEWHERE_COMMAND_STR);
                break;
            
            case SAVEHERE:
                processCommand(SAVEHERE_COMMAND_STR);
                break;
            
            case EXIT:
                processCommand(EXIT_COMMAND_STR);
                break;
                
            default:
                setErrorType(ErrorType.INVALID_COMMAND);
                logger.log(Level.WARNING, "command " + commandType.toString() + 
                           " not recognized");
                break;
        }
    }
    
    /**
     * Sets the error type result field to the given input.
     * 
     * @param desiredErrorType Error that arose from parsing.
     */
    private static void setErrorType(ErrorType desiredErrorType) {
        errorType = desiredErrorType;
    }
    
    /**
     * Sets the command type result field to the given input.
     * 
     * @param desiredCommandType Command type determined from parsing.
     */
    private static void setCommandType(CommandType desiredCommandType) {
        commandType = desiredCommandType;
    }

    /**
     * Resets the result fields used to construct the parse result object.
     */
    private static void resetFields() {
        commandType = null;
        keywordArgs = "";
        inputTokens = null;
        date = null;
        date2 = null;
        dateToRemind = null;
        priorityLevel = NO_PRIORITY_LVL;
        id = 0;
        name = "";
        description = "";
        tag = "";
        errorType = null;
        flags = new boolean[FLAGS_SIZE];
        desiredTime = null;
        isTimeSetByUser = false;
        isTime2SetByUser = false;    
        isParseDateComplete = false;
    }

    /**
     * Checks whether input word is a non command keyword.
     * 
     * @param word Keyword.
     * @return     Whether the keyword is a non command keyword.
     */
    private static Boolean isNonCmdKeyword(String word) {
        return nonCommandKeywords.contains(word);
    }
    
    /**
     * Processes the rest of the input given the command word the user used.
     * 
     * @param commandWord User's desired command type.
     */
    private static void processCommand(String commandWord) {        
        processKeywordsAndArgs(commandWord);        
        checkAddConvertHaveValidFields();
        setDefaultTimesForAdd();
        checkDate1BeforeDate2();
        flags = updateResultFlags(date, dateToRemind, priorityLevel, id, name, 
                                  description, tag, date2);
    }
    
    /**
     * Searches the user input for keywords and processes each keyword and its 
     * arguments in succession.
     * 
     * @param commandWord The initial keyword representing the command type.
     */
    private static void processKeywordsAndArgs(String commandWord) {
        int indexBeingProcessed = FIRST_AFTER_COMMAND_TYPE;
        String wordBeingProcessed = "";        
        String previousKeywordProcessed = "";
        // to decide what to do with args
        String keywordBeingProcessed = commandWord;
        
        // continue looking for keywords until the end of the command        
        while (indexBeingProcessed < inputTokens.length) {
            wordBeingProcessed = inputTokens[indexBeingProcessed];
            if (isNonCmdKeyword(wordBeingProcessed)) {
                /* all text after the help, delete, done, setnotdone, savewhere,
                   savehere and show commands and their arguments is ignored */
                if (monoKeywordCommands.contains(keywordBeingProcessed)) {
                    break;
                } else if (keywordBeingProcessed.equals(JUMP_COMMAND_STR)) {
                    /* allow users to say use "jump date <date>" as well as 
                     * "jump <date>" */
                    if (wordBeingProcessed.equals(DATE_KEYWORD)) {
                        // do nothing
                    } else {
                        break;
                    }
                // no special case
                } else {
                    // process arguments of the previous command
                    processArgs(keywordBeingProcessed);
                    keywordArgs = "";
                    previousKeywordProcessed = keywordBeingProcessed;
                    keywordBeingProcessed = wordBeingProcessed;
                }
            } else {
                // add to arguments of previous command
                keywordArgs += wordBeingProcessed + " ";
            }
            indexBeingProcessed++;
        }
        processArgs(keywordBeingProcessed);
    }
    
    /**
     * Processes the existing keywords in the keyword buffer string based on
     * what the keyword is.
     * 
     * @param keyword The keyword for which the arguments will be processed.
     */
    private static void processArgs(String keyword) {  
        // remove escape character from arguments since now unneeded
        keywordArgs = removeEscapeCharacterInstances(keywordArgs);
        // split for later use in cases
        String[] keywordArgsArray = splitBySpaceDelimiter(keywordArgs);
        
        if (isNonCmdKeyword(keyword)) {
            processNonCmdKeywordArgs(keyword, keywordArgs, keywordArgsArray);
        } else {
            processCmdKeywordArgs(keyword, keywordArgs, keywordArgsArray);
        }           
    }
    
    /**
     * Processes the existing keywords in the keyword buffer string based on
     * which of the non command keywords the keyword is.
     * 
     * @param keyword          The keyword for which the arguments will be 
     *                         processed.
     * @param keywordArgs      The arguments of the keyword with escape 
     *                         characters removed.
     * @param keywordArgsArray The tokenized arguments of the keyword with 
     *                         escape characters removed.
     */
    private static void processNonCmdKeywordArgs(String keyword,
                                                 String keywordArgs,
                                                 String[] keywordArgsArray) {
        switch(keyword) {     
            case "at":            
            case "on":
            case "date":            
            case "from":
            case "by":
            case "due":
                updateDate(keywordArgs, DATE_1_INDEX);                          
                break;
            
            // end date (for timed tasks)
            case "until":
            case "to":
                updateDate(keywordArgs, DATE_2_INDEX);                
                break;           
    
            // not yet implemented
            case "every":
                break;
            
            // not yet implemented
            case "in":
                break;
    
            case "priority":
                updatePriorityLevel(keywordArgsArray[FIRST_ARG]);                
                break;
    
            case "desc":
            case "description":
                description = keywordArgs.trim();
                break;
    
            case "remind":
                updateDate(keywordArgs, DATE_TO_REMIND_INDEX);  
                break;
                
            case "tag":
                tag = keywordArgs.trim();
                break;
    
            default:
                break;    
        }
    }
    
    /**
     * Processes the existing keywords in the keyword buffer string based on
     * which of the command keywords the keyword is.
     * 
     * @param keyword          The keyword for which the arguments will be 
     *                         processed.
     * @param keywordArgs      The arguments of the keyword with escape 
     *                         characters removed.
     * @param keywordArgsArray The tokenized arguments of the keyword with 
     *                         escape characters removed.
     */
    private static void processCmdKeywordArgs(String keyword, 
                                              String keywordArgs,
                                              String[] keywordArgsArray) {
        switch(keyword) {            
            case "add":
                name = keywordArgs.trim();
                break;
    
            case "update":
                updateId(keywordArgsArray[FIRST_ARG], keyword);
                updateName(keywordArgsArray);
                
            case "delete":
            case "setnotdone":
            case "done":
                updateId(keywordArgsArray[FIRST_ARG], keyword);                
                break;
    
            case "show":
                // not in use
                break;
            
            case "undo":
                // no arguments, all other text ignored
                break;
    
            case "search":
                name = keywordArgs.trim();
                break;
    
            case "help":
                determineWhatUserNeedsHelpWith(keywordArgsArray[FIRST_ARG]);
                break;
            
            case "convert":
                // get id of task to convert
                updateId(keywordArgsArray[FIRST_ARG], keyword); 
                
                // determine type to convert to
                setCommandType(determineConvertType(
                               keywordArgsArray[SECOND_ARG]));             
                break;
                
            case "savewhere":
                // no arguments, all other text ignored
                break;
                
            case "savehere":
                // desired file path for data storage will be put in name field
                name = keywordArgs.trim();
                break;
                
             // arguments for jump are expected to be date info
            case "jump":
                updateDate(keywordArgs, DATE_1_INDEX);
                break;
                
            default:
                break;
        }
    }    
    
    /**
     * Updates the priority field after processing a string representing the 
     * desired priority level.
     * 
     * @param desiredLevel Priority level.
     */
    private static void updatePriorityLevel(String desiredLevel) {
        try {
            priorityLevel = Integer.parseInt(desiredLevel);
        } catch (NumberFormatException e) {
            logger.log(Level.WARNING, "error parsing priority level");
            setCommandType(CommandType.INVALID);
            setErrorType(ErrorType.INVALID_PRIORITY_LEVEL);
        }
        
        if (priorityLevel < LOWEST_PRIORITY_LVL || 
            priorityLevel > HIGHEST_PRIORITY_LVL) {
            
            setCommandType(CommandType.INVALID);
            setErrorType(ErrorType.INVALID_PRIORITY_LEVEL);
        }
    }
    
    /**
     * Updates the ID field after processing a string representing the target
     * id of the command. Keyword is input for logging purposes.
     * 
     * @param targetIdString     Target task of command.
     * @param keywordBeingParsed Keyword being parsed.
     */
    private static void updateId(String targetIdString, 
                                 String keywordBeingParsed) {
        try {
            id = Long.parseLong(targetIdString);
        } catch (NumberFormatException e) {
            logger.log(Level.WARNING, "error parsing id in " + 
                       keywordBeingParsed);
            setCommandType(CommandType.INVALID);
            setErrorType(ErrorType.INVALID_TASK_ID);
        }
    }
    
    private static void updateName(String[] keywordArgs) {
        if (keywordArgs.length > ONE_WORD) {
            String nameToUpdateTo = "";
            for (int i = 1; i < keywordArgs.length; i++) {
                nameToUpdateTo += keywordArgs[i] + " ";
            }
            name = nameToUpdateTo.trim();
        }        
    }
    
    /**
     * Updates the selected date result field based on the keyword arguments.
     * 
     * @param keywordArgs       The arguments of the keyword, expected to be 
     *                          date data.
     * @param dateFieldToUpdate Index representing which date field to update.
     */
    private static void updateDate(String keywordArgs, int dateFieldToUpdate) {
        desiredTime = parseDate(keywordArgs, dateFieldToUpdate);
        if (desiredTime != null) {
            if (dateFieldToUpdate == DATE_1_INDEX) {
                date = desiredTime.getTime();
            } else if (dateFieldToUpdate == DATE_2_INDEX) {
                date2 = desiredTime.getTime();
            } else {
                dateToRemind = desiredTime.getTime();
            }
        }      
    }
    
    /**
     * Updates the command type to a help-related command type if the user has
     * specified a valid command type as an argument.
     * 
     * @param commandType Type of command user needs help with.
     */
    private static void determineWhatUserNeedsHelpWith(String commandType) {
        // check whether the user needs help with specific command
        String cmdToHelpWith = commandType;
        
        // determine the type of command the user wants help with
        CommandType cmdToHelpWithType = determineCommandType(cmdToHelpWith);
        
        // user did not ask for help for a valid command type
        if (cmdToHelpWithType.equals(Constants.CommandType.INVALID)) {
            logger.log(Level.INFO, "show general help");
        } else {
            logger.log(Level.INFO, "show help for specific command");
            setCommandType(determineHelpCmdType(cmdToHelpWithType));
        }
    }
    
    /**
     * Remove all instances of the escape character '/' from the given input 
     * string, which is expected to be the arguments of a keyword.
     * 
     * @param  inputString Arguments of the keyword being processed.
     * @return             The input string with the character removed.
     */
    private static String removeEscapeCharacterInstances(String inputString) {     
        String[] keywordArgsArray = splitBySpaceDelimiter(inputString);
        StringBuilder sb = new StringBuilder(inputString.length());
        for (String s: keywordArgsArray) {
            sb.append(s.replaceFirst("/", "") + " ");
        }
        String keywordArgs = sb.toString().trim();
        return keywordArgs;
    }

    /**
     * Updates the flags that show what useful information the parse result
     * contains after checking each field.
     * 
     * @param date          First date field.
     * @param dateToRemind  Date at which to remind user to do task.
     * @param priorityLevel Priority level.
     * @param id            Task ID.
     * @param name          Task name.
     * @param description   Task description.
     * @param tag           Task tag.
     * @param date2         Second date field, used for timed tasks.
     * @return              Flags showing presence/absence of useful info.
     */
    private static boolean[] updateResultFlags(Date date, Date dateToRemind, 
                                               int priorityLevel, long id, 
                                               String name, String description, 
                                               String tag, Date date2) {
        /* flags order: date, dateToRemind, priorityLevel, id, name,
                        description, tag */
        boolean[] resultFlags = new boolean[FLAGS_SIZE];

        if (date != null) {
            resultFlags[DATE_FLAG] = true;
        }
        if (dateToRemind != null) {
            resultFlags[DATE_TO_REMIND_FLAG] = true;
        }
        if (priorityLevel != 0) {
            resultFlags[PRIORITY_LVL_FLAG] = true;
        }
        if (id != 0) {
            resultFlags[ID_FLAG] = true;
        }
        if (!name.equals("")) {
            resultFlags[NAME_FLAG] = true;
        }
        if (!description.equals("")) {
            resultFlags[DESC_FLAG] = true;
        }
        if (!tag.equals("")) {
            resultFlags[TAG_FLAG] = true;
        }
        if (date2 != null) {
            resultFlags[DATE_2_FLAG] = true;
        }
        return resultFlags;
    }

    /**
     * Constructs and returns a result object based on the current result 
     * fields and input command type.
     * 
     * @param commandType Type of command the user input.
     * @return            Result of parsing user input string.
     */
    private static ParseResult createParseResult(CommandType commandType) {
        return new ParseResult(commandType, date, date2, dateToRemind, 
                               priorityLevel, id, name, description, tag, 
                               errorType, flags);
    }
    
    /**
     * Returns a help-related command type for the result based on which 
     * command the user wants help with.
     * 
     * @param commandType Command that user wants help with.
     * @return            Help-related command type.
     */
    private static CommandType determineHelpCmdType(CommandType commandType) {
        switch(commandType) {
            case ADD:
                return CommandType.HELP_ADD;
                
            case UPDATE:
                return CommandType.HELP_UPDATE;
                
            case DELETE:
                return CommandType.HELP_DELETE;
                
            case SHOW:
                return CommandType.HELP_SHOW;
                
            case DONE:
                return CommandType.HELP_DONE;
                
            case UNDO:                
                return CommandType.UNDO;
                
            case SEARCH:
                return CommandType.HELP_SEARCH;
                
            default:
                setErrorType(ErrorType.INVALID_COMMAND);
                return CommandType.INVALID;
        }
    }
    
    /**
     * Returns a convert-related command type for the result based on which 
     * type of task the user wants to convert his task to.
     * 
     * @param convertTypeString Desired type of task to convert to.
     * @return                  Convert-related command type.
     */
    private static CommandType determineConvertType(String convertTypeString) {
        switch (convertTypeString.trim()) {
            case DEADLINE_TYPE:
                return CommandType.CONVERT_DEADLINE;
                
            case FLOATING_TYPE:
                return CommandType.CONVERT_FLOATING;
                
            case TIMED_TYPE:
                return CommandType.CONVERT_TIMED;
               
            default:
                setErrorType(ErrorType.INVALID_COMMAND);
                logger.log(Level.WARNING, "unable to determine convert type");
                return CommandType.INVALID;
        }
    }
    
    /**
     * Parses the input arguments that are expected to be a date representation
     * into a consistent Calendar format.
     * 
     * @param arguments            String representation of a date.
     * @param dateBeingParsedIndex Index of the date field being updated (e.g. 
     *                             date, date2).
     * @return                     Parsed date.
     */
    private static Calendar parseDate(String arguments, 
                                      int dateBeingParsedIndex) {
        logger.log(Level.INFO, "beginning date parsing");
        desiredTime = Calendar.getInstance();
        Calendar currentTime = Calendar.getInstance();
        updateDateFields(desiredTime);
        int tokenBeingParsedIndex = FIRST_TOKEN;
        // the tokens that will individually represent day, month etc
        String[] dateParts = splitBySpaceDelimiter(arguments);
        assert(dateParts.length > 0);
        
        parseFirstDateArg(dateParts, arguments, tokenBeingParsedIndex, 
                          dateBeingParsedIndex, currentTime);
        if (isParseDateComplete) {
            return desiredTime;
        }
        
        // now parsing second token
        tokenBeingParsedIndex++;
        parseSecondDateArg(dateParts, arguments, tokenBeingParsedIndex, 
                           dateBeingParsedIndex, currentTime);
        if (isParseDateComplete) {
            return desiredTime;
        }
        
        // now parsing third token
        tokenBeingParsedIndex++;
        parseThirdDateArg(dateParts, arguments, tokenBeingParsedIndex, 
                          dateBeingParsedIndex);
        if (isParseDateComplete) {
            return desiredTime;
        }        
        
        tokenBeingParsedIndex++;     
        
        if (dateParts.length == ALL_DATE_ARGS) {
            // parsing 4th/5th token, user has input year, month, day, and time
            parseFourthAndFithDateArg(dateParts, arguments, 
                                      tokenBeingParsedIndex, 
                                      dateBeingParsedIndex);         
            return desiredTime;
        }
        
        logger.log(Level.INFO, "ending date parsing");
        
        // date was parsed with a simple day month year format.
        return createCalendar(year, month - ONE_MONTH, day, 0, 0);
    }
    
    /**
     * Updates the individual date related fields with the given calendar.
     * @param desiredTime Time to update to.
     */
    private static void updateDateFields(Calendar desiredTime) {
        day = desiredTime.get(Calendar.DATE);
        month = desiredTime.get(Calendar.MONTH);
        year = desiredTime.get(Calendar.YEAR);
    }
    
    /**
     * Processes the first date argument.
     * 
     * @param dateParts             Tokens that represent day, month, etc.
     * @param arguments             All the date arguments.
     * @param tokenBeingParsedIndex Index of the token being parsed.
     * @param dateBeingParsedIndex  Either date1 or date2.
     * @param existingTime          Existing time.
     */
    private static void parseFirstDateArg(String[] dateParts, String arguments, 
                                          int tokenBeingParsedIndex, 
                                          int dateBeingParsedIndex, 
                                          Calendar existingTime) {
        // may be the day, a time keyword, or the next keyword
        String firstArg = dateParts[tokenBeingParsedIndex].toLowerCase();
        
        try {
            day = Integer.parseInt(firstArg);
            
            // check whether there are no more args to be processed
            if (dateParts.length == ONLY_DAY_ARG) {
                /* handle whether the next occurrence of the specified day 
                 * occurs this month or next month */
                if (day < existingTime.get(Calendar.DATE)) {
                    desiredTime = createCalendar(year, month + ONE_MONTH, day, 
                                                 ZERO_HOURS, ZERO_MINUTES); 
                } else {
                    desiredTime = createCalendar(year, month, day, ZERO_HOURS, 
                                                 ZERO_MINUTES);
                }
            }
        } catch (NumberFormatException e) {
            // try parsing as a non standard format (e.g. time field, next day)
            calcDiffFormatDateOnFirstDateArg(arguments, dateParts, 
                                             tokenBeingParsedIndex, 
                                             dateBeingParsedIndex,
                                             firstArg);
        }
    }
    
    /**
     * Processes the second date argument.
     * 
     * @param dateParts             Tokens that represent day, month, etc.
     * @param arguments             All the date arguments.
     * @param tokenBeingParsedIndex Index of the token being parsed.
     * @param dateBeingParsedIndex  Either date1 or date2.
     * @param existingTime          Existing time.
     */
    private static void parseSecondDateArg(String[] dateParts, String arguments, 
                                           int tokenBeingParsedIndex, 
                                           int dateBeingParsedIndex, 
                                           Calendar existingTime) {
        // may be a representation of the month, or a time keyword
        String secondArg = dateParts[tokenBeingParsedIndex].toLowerCase();
            
        try {
            month = Integer.parseInt(secondArg);
            
            // check whether there are no more args to be processed
            if (dateParts.length == DAY_AND_MONTH_ARGS) {
                /* handle whether the next occurrence of the specified month 
                 * occurs this year or next year */
                if (month < existingTime.get(Calendar.MONTH)) {
                    desiredTime = createCalendar(year + ONE_YEAR, 
                                                 month - ONE_MONTH, day, 
                                                 ZERO_HOURS, ZERO_MINUTES);
                } else {
                    desiredTime = createCalendar(year, month - ONE_MONTH, day, 
                                                 ZERO_HOURS, ZERO_MINUTES);
                }
                isParseDateComplete = true;
            }
        } catch (NumberFormatException e) {            
            int monthIndex = months.indexOf(secondArg.toLowerCase());
            // check whether it is an English month string
            if (monthIndex != NOT_FOUND) {
                month = (monthIndex / MONTH_ENGLISH_VARIATIONS) + ONE_MONTH;
            } else {
                desiredTime = calcTimeOnDateArg(arguments, dateParts, 
                                         tokenBeingParsedIndex, 
                                         dateBeingParsedIndex,
                                         secondArg);                
            }
        }
    }
    
    /**
     * Processes the third date argument.
     * 
     * @param dateParts             Tokens that represent day, month, etc.
     * @param arguments             All the date arguments.
     * @param tokenBeingParsedIndex Index of the token being parsed.
     * @param dateBeingParsedIndex  Either date1 or date2.
     */
    private static void parseThirdDateArg(String[] dateParts, String arguments, 
                                          int tokenBeingParsedIndex, 
                                          int dateBeingParsedIndex) {
        // may be a representation of the year, or a time keyword
        String thirdArg = dateParts[THIRD_ARG].toLowerCase();
        
        try {
            year = Integer.parseInt(thirdArg);
        } catch (NumberFormatException e) {
            desiredTime = calcTimeOnDateArg(arguments, dateParts, 
                                            tokenBeingParsedIndex, 
                                            dateBeingParsedIndex,
                                            thirdArg);            
        }
    }
    
    /**
     * Processes the fourth and fifth date arguments, expected to be for time.
     * 
     * @param dateParts             Tokens that represent day, month, etc.
     * @param arguments             All the date arguments.
     * @param tokenBeingParsedIndex Index of the token being parsed.
     * @param dateBeingParsedIndex  Either date1 or date2.
     */
    private static void parseFourthAndFithDateArg(String[] dateParts, 
                                                  String arguments, 
                                                  int tokenBeingParsedIndex, 
                                                  int dateBeingParsedIndex) {
        // expected to be a time keyword
        String fourthArg = dateParts[FOURTH_ARG].toLowerCase();
        
        desiredTime = calcTimeOnDateArg(arguments, dateParts, 
                                        tokenBeingParsedIndex, 
                                        dateBeingParsedIndex,
                                        fourthArg);
    }
    
    /**
     * Processes the first argument of the arguments for date. Expected to 
     * be either a time keyword (pm/am) or 'next' to signify a command similar
     * to 'next day'.
     * 
     * @param dateParts             Tokens that represent day, month, etc.
     * @param arguments             All the date arguments.
     * @param tokenBeingParsedIndex Index of the token being parsed.
     * @param dateBeingParsedIndex  Either date1 or date2.
     * @param dateArg               First argument of the date.
     */
    private static void calcDiffFormatDateOnFirstDateArg(String arguments,
            String[] dateParts, int tokenBeingParsedIndex, 
            int dateBeingParsedIndex, String firstArg) {
        
        // check whether the current argument is a keyword for time
        if (firstArg.equals(PM) || firstArg.equals(AM)) {
            setTimeSetByUserToTrue(dateBeingParsedIndex);
            desiredTime = calcDateGivenTime(dateParts, tokenBeingParsedIndex, 
                                            firstArg);            
        
        // use parseNext when "next" is the first argument
        } else if (firstArg.toLowerCase().trim().equals(NEXT_KEYWORD)) {
            desiredTime = parseNext(arguments);
        } else { 
            setCommandType(CommandType.INVALID);
            setErrorType(ErrorType.INVALID_DATE);
            logger.log(Level.WARNING, "unable to parse day");
            desiredTime = null;
        }
        isParseDateComplete = true;
    }
    
    /**
     * Calculate the time given an argument that is expected to be a time 
     * keyword (am/pm).
     * 
     * @param arguments             All the date arguments.
     * @param dateParts             Tokens that represent day, month, etc.
     * @param tokenBeingParsedIndex Index of the token being parsed.
     * @param dateBeingParsedIndex  Either date1 or date2.
     * @param dateArg               Expected to be am/pm.
     * @return                      Result date/time.
     */
    private static Calendar calcTimeOnDateArg(String arguments,
            String[] dateParts, int tokenBeingParsedIndex, 
            int dateBeingParsedIndex, String dateArg) {
        // check whether the current argument is a keyword for time
        if (dateArg.equals(PM) || dateArg.equals(AM)) {
            setTimeSetByUserToTrue(dateBeingParsedIndex);
            return calcDateGivenTime(dateParts, tokenBeingParsedIndex, 
                                       dateArg); 
            
        } else {
            setCommandType(CommandType.INVALID);
            setErrorType(ErrorType.INVALID_DATE);
            logger.log(Level.WARNING, "unable to parse date");
            return null;                
         }
    }   
    
    /**
     * Converts arguments in the form of 'next x time period' (e.g. next 3 
     * days) into a proper date based on the current time and date.
     * 
     * @param arguments String representation of date in form "next ...".
     * @return          Parsed date.
     */
    private static Calendar parseNext(String arguments) {
        String[] dateParts = splitBySpaceDelimiter(arguments);
        String secondArg = dateParts[SECOND_ARG].toLowerCase().trim();
        Calendar existingTime = Calendar.getInstance();
        int year = existingTime.get(Calendar.YEAR);
        int month = existingTime.get(Calendar.MONTH);
        int date = existingTime.get(Calendar.DATE);
        int day = existingTime.get(Calendar.DAY_OF_WEEK);
        try {
            switch(secondArg) {
                case "day":
                    return createCalendar(year, month, date + ONE_DAY, 
                                          ZERO_HOURS, ZERO_MINUTES);
                
                case "month":
                    return createCalendar(year, month + ONE_MONTH, ONE_DAY, 
                                          ZERO_HOURS, ZERO_MINUTES);
                    
                case "year":
                    return createCalendar(year + ONE_YEAR, FIRST_MONTH, ONE_DAY, 
                                          ZERO_HOURS, ZERO_MINUTES);
                    
                case "week":                     
                    return createCalendarForNextWeek(year, month, date, day);
                    
                default:                    
                    return createCalendarForNextNamedTime(secondArg, date, day);
            }
        } catch (NumberFormatException e) {
            setCommandType(CommandType.INVALID);
            setErrorType(ErrorType.INVALID_DATE);
            logger.log(Level.WARNING, "unable to parse date");
        }
        return createCalendar(year, month, date, ZERO_HOURS, ZERO_MINUTES);        
    }
    
    /**
     * Handles the special case of 'next week' when parsing a date.
     * 
     * @param existingYear      Existing year.
     * @param existingMonth     Existing month.
     * @param existingDate      Existing day of the month.
     * @param existingDayOfWeek Existing day of the week.
     * @return                  Parsed date.
     */
    private static Calendar createCalendarForNextWeek(int existingYear, 
                                                      int existingMonth, 
                                                      int existingDate, 
                                                      int existingDayOfWeek) {
        /* Calendar forces monday = 2, sunday = 1. If current day is monday,
         * difference calculated after %7 is 0 so needs to be changed back to 7
         */
        int daysDifference = (DAYS_IN_WEEK - existingDayOfWeek) % DAYS_IN_WEEK;
        if (daysDifference == WEEK_DIFFERENCE_IN_DAYS) {
            daysDifference = DAYS_IN_WEEK;
        }
        return createCalendar(existingYear, existingMonth, 
                              existingDate + daysDifference, ZERO_HOURS, 
                              ZERO_MINUTES);
    }
    
    /**
     * Handles the special case of parsing a named time such as 'next Friday'
     * or 'next October'.
     * 
     * @param dateArg           Expected to be the name (e.g. Friday, Oct).
     * @param existingDate      Existing day of the month.
     * @param existingDayOfWeek Existing day of the week.
     * @return                  Parsed date.
     */
    private static Calendar createCalendarForNextNamedTime(String dateArg, 
            int existingDate, int existingDayOfWeek) {
        // check if argument is a month in English
        int index = months.indexOf(dateArg.toLowerCase().trim());
        if (index == NOT_FOUND) {
            
            // check if argument is a day of the week
            index = days.indexOf(dateArg.toLowerCase().trim());
            if (index == NOT_FOUND) {                
                // invalid argument, set error
                setCommandType(CommandType.INVALID);
                setErrorType(ErrorType.INVALID_DATE);
                return null;
            } else {
                
                /* calculate differences since mon = 2 for calendar while 
                   mon = 1 from arraylist index */
                int dayDiff = DAYS_IN_WEEK + (index / DAY_ENGLISH_VARIATIONS) + 
                              ONE_DAY - (existingDayOfWeek - ONE_DAY);
                System.out.println(existingDayOfWeek);
                return createCalendar(year, month, existingDate + dayDiff, 
                                      ZERO_HOURS, ZERO_MINUTES);
            }
        } else {
            int monthRequested = (index / MONTH_ENGLISH_VARIATIONS) + ONE_MONTH;
            return createCalendar(year + ONE_YEAR, monthRequested - ONE_MONTH, 
                                  ONE_DAY, ZERO_HOURS, ZERO_MINUTES);                    
        }
    }
    
    /**
     *  Takes in an array of strings containing date info and the expected 
     *  index containing the time string, and returns a Calendar constructed 
     *  with all the date info.
     *  
     *  @param dateParts    String tokens with date info.
     *  @param indexToCheck Index expected to contain time string.
     *  @param pmOrAm       Differentiates which half of the day it is.
     *  @return             Parsed date.
     */    
    private static Calendar calcDateGivenTime(String[] dateParts, 
                                              int indexBeingParsed, 
                                              String pmOrAm) {
        // check for a valid argument to be parsed as the time
        if (!isTimeArgExistent(indexBeingParsed, dateParts)) {
            // does not exist, return default date value
            return createCalendar(year, month - ONE_MONTH, day, ZERO_HOURS, 
                                  ZERO_MINUTES);
        }
        
        String timeString = dateParts[indexBeingParsed + NEXT_ARG];
        String[] timeParts = timeString.split(TIME_DELIMITER);  
        
        // check for appropriate format (##.##) 
        if (!isValidTimeFormat(indexBeingParsed, timeParts)) {
            // invalid date format, return default date value
            return createCalendar(year, month - ONE_MONTH, day, ZERO_HOURS, 
                                  ZERO_MINUTES);
        }       

        try {
            int hour = Integer.parseInt(timeParts[0]);
            int min = Integer.parseInt(timeParts[1]);
            if (!isValidHour(hour) || !isValidMin(min)) {
                // hour and/or minute not valid, return default date value
                return createCalendar(year, month, day, ZERO_HOURS, 
                                      ZERO_MINUTES);
            }
            
            return calcDateConsideringAmOrPm(pmOrAm, hour, min);            
            
        } catch (NumberFormatException e) {
            setCommandType(CommandType.INVALID);
            setErrorType(ErrorType.INVALID_TIME);
            logger.log(Level.WARNING, "error parsing time on argument number " + 
                       indexBeingParsed);
            return createCalendar(year, month - ONE_MONTH, day, ZERO_HOURS, 
                                  ZERO_MINUTES);
        }
        
    }
    
    /**
     * Helper method for calcDateGivenTime that validates the presence of an 
     * argument for the time keyword.
     * 
     * @param indexBeingParsed Index of time keyword.
     * @param dateParts        String tokens with date info.
     * @return                 Whether the argument exists.
     */
    private static boolean isTimeArgExistent(int indexBeingParsed, 
                                             String[] dateParts) {
        if (indexBeingParsed + NEXT_ARG > dateParts.length) {
            setCommandType(CommandType.INVALID);
            setErrorType(ErrorType.INVALID_TIME);
            logger.log(Level.WARNING, "unable to parse time on argument " + 
                       "number " + indexBeingParsed + 
                       " due to no token after time keyword");
            return false;
        } else {
            return true;
        }
    }
    
    /**
     * Helper method for calcDateGivenTime that validates that the time has 
     * two parts (expected to be hour and minute). Index of time keyword is 
     * input for logging purposes.
     * 
     * @param indexBeingParsed Index of time keyword.
     * @param timeParts        Hour and minute.
     * @return                 Whether there are two parts.
     */
    private static boolean isValidTimeFormat(int indexBeingParsed, String[] timeParts) {  
        if (timeParts.length != CORRECT_NO_TIME_ARGS) {
            setCommandType(CommandType.INVALID);
            setErrorType(ErrorType.INVALID_TIME);
            logger.log(Level.WARNING, "unable to parse time on argument " + 
                       "number " + indexBeingParsed + 
                       " due to incorrect format");
            return false;
        } else {
            return true;
        }
    }
    
    /**
     * Checks whether the input hour is between 0 and 12 inclusive.
     * 
     * @param hour Hour of the day.
     * @return     Whether the hour is valid.
     */
    private static boolean isValidHour(int hour) {
        if (hour < SMALLEST_HOUR || hour > BIGGEST_HOUR) {
            setCommandType(CommandType.INVALID);
            setErrorType(ErrorType.INVALID_TIME);
            logger.log(Level.WARNING, "unable to parse time on argument " +
                                      "due to invalid hour given");
            return false;
        } else {
            return true;
        }
    }
    
    /**
     * Checks whether the input minute is between 0 and 59 inclusive.
     * 
     * @param min Minute of the day.
     * @return    Whether the minute is valid.
     */
    private static boolean isValidMin(int min) {
        if (min < SMALLEST_MIN || min > BIGGEST_MIN) {
            setCommandType(CommandType.INVALID);
            setErrorType(ErrorType.INVALID_TIME);
            logger.log(Level.WARNING, "unable to parse time on argument " + 
                       "due to invalid minute given");
            return false;
        } else {
            return true;
        }
    }
    
    /**
     * Helper method for calcDateGivenTime that finishes calculating the result
     * based on the fields calculated so far as well as whether the time given 
     * is in PM or AM.
     * 
     * @param pmOrAm Differentiates which half of the day it is.
     * @param hour   Desired hour.
     * @param min    Desired min.
     * @return       Resulting date.
     */
    private static Calendar calcDateConsideringAmOrPm(String pmOrAm, int hour, 
                                                      int min) {
        assert(pmOrAm.equals(PM) || pmOrAm.equals(AM));
        if (pmOrAm.equals(PM)) {
            // special case of 12pm
            if (hour == BIGGEST_HOUR) {
                return createCalendar(year, month - ONE_MONTH, day, hour, min); 
            } else {
                return createCalendar(year, month - ONE_MONTH, day, 
                                      hour + HALF_DAY_IN_HOURS, min); 
            }
        // am case
        } else {
            // special case for 12am
            if (hour == BIGGEST_HOUR) {
                return createCalendar(year, month - ONE_MONTH, day,
                                      hour - HALF_DAY_IN_HOURS, min); 
            } else {
                return createCalendar(year, month - ONE_MONTH, day, hour, min);  
            }                    
        }
    }
    
    /**
     * Creates a calendar with a time given by the input values. The value of the
     * second is always set to 0.
     * 
     * @param year   Desired year.
     * @param month  Desired month.
     * @param day    Desired day.
     * @param hour   Desired hour.
     * @param minute Desired minute.
     * @return       Resulting date.
     */
    private static Calendar createCalendar(int desiredYear, int desiredMonth, 
                                           int desiredDay, int hour, 
                                           int minute) {
        Calendar calendar = Calendar.getInstance();
        calendar.set(desiredYear, desiredMonth, desiredDay, hour, minute, 
                     ZERO_SECONDS);
        return calendar;
    }
    
    /**
     * Verifies that a command with the type Add or Convert has valid fields.
     */
    private static void checkAddConvertHaveValidFields() {       
        if (commandType.equals(CommandType.ADD)) {
            checkAddHasValidName();         
         
        // check for two valid dates in the case of convert timed
        } else if (commandType.equals(CommandType.CONVERT_TIMED)) {
            checkValidDates();
            
        // check for at least one valid date in the case of convert deadline
        } else if (commandType.equals(CommandType.CONVERT_DEADLINE)) {
            checkAtLeastOneValidDate();
        }
    }
    
    /**
     * Checks that the user provided a valid name.
     */
    private static void checkAddHasValidName() {
        if (name.equals("")) {
            setCommandType(CommandType.INVALID);
            setErrorType(ErrorType.BLANK_TASK_NAME);
        }
    }
    
    /**
     * Check that both date1 and date2 fields contain valid dates.
     */
    private static void checkValidDates() {
        if (date == null || date2 == null) {
            logger.log(Level.WARNING, "Less than two valid dates for " + 
                       "Convert Timed");
            setCommandType(CommandType.INVALID);
            setErrorType(ErrorType.INVALID_NUMBER_OF_DATES);
        }
    }
    /**
     * Check that there is at least one valid date out of date1 and date2.
     */
    private static void checkAtLeastOneValidDate() {
        logger.log(Level.WARNING, "no valid dates for Convert Deadline");
        if (date == null && date2 == null) {
            setCommandType(CommandType.INVALID);
            setErrorType(ErrorType.INVALID_NUMBER_OF_DATES);
        }
    }
    
    /**
     * Sets true the flag showing whether the user has set a particular time 
     * field.
     * 
     * @param targetDateIndex Index of date field the user has set.
     */
    private static void setTimeSetByUserToTrue(int targetDateIndex) {
        if (targetDateIndex == DATE_1_INDEX) {
            isTimeSetByUser = true;
        } else if (targetDateIndex == DATE_2_INDEX) {
            isTime2SetByUser = true;
        }
    }
    
    /**
     * Sets default times for the user in the case that they added a task 
     * without specifying the times on their own.
     */
    private static void setDefaultTimesForAdd() {
        if (commandType.equals(CommandType.ADD)) {
            // case of timed task
            if (date != null && date2 != null) {
                setDefaultTimesForTimedAdd();
            // case of deadline task
            } else if (date != null || date2 != null) {
                setDefaultTimeForDeadlineAdd();
            }
        }
    }
    
    /**
     * Sets default times to the start of the day for the first date and the
     * end of the day for the second date if they were not set by the user.
     */
    private static void setDefaultTimesForTimedAdd() {
        if (!isTimeSetByUser) {
            // set the default time for first date to start of the day
            desiredTime.setTime(date);
            int existingYear = desiredTime.get(Calendar.YEAR);
            int existingMonth = desiredTime.get(Calendar.MONTH);
            int existingDay = desiredTime.get(Calendar.DATE);
            desiredTime.set(existingYear, existingMonth, existingDay, 
                            ZERO_HOURS, ZERO_MINUTES);
            date = desiredTime.getTime();
        }
        if (!isTime2SetByUser) {
            // set the default time for second date to end of the day
            desiredTime.setTime(date2);
            int existingYear = desiredTime.get(Calendar.YEAR);
            int existingMonth = desiredTime.get(Calendar.MONTH);
            int existingDay = desiredTime.get(Calendar.DATE);
            desiredTime.set(existingYear, existingMonth, existingDay, 
                            BIGGEST_24_HOUR_HOUR, BIGGEST_MIN);
            date2 = desiredTime.getTime();
        }
    }
    
    /**
     * Sets default time for any of the fields date and date2 to the end of the
     * day if they were not set by the user.
     */
    private static void setDefaultTimeForDeadlineAdd() {
        if (!isTimeSetByUser && date != null) {
            // set the default time for the date to end of the day
            desiredTime.setTime(date);
            int existingYear = desiredTime.get(Calendar.YEAR);
            int existingMonth = desiredTime.get(Calendar.MONTH);
            int existingDay = desiredTime.get(Calendar.DATE);
            desiredTime.set(existingYear, existingMonth, existingDay, 
                            BIGGEST_24_HOUR_HOUR, BIGGEST_MIN);
            date = desiredTime.getTime();
        }
        
        if (!isTime2SetByUser && date2 != null) {
            // set the default time for the date to end of the day
            desiredTime.setTime(date2);
            int existingYear = desiredTime.get(Calendar.YEAR);
            int existingMonth = desiredTime.get(Calendar.MONTH);
            int existingDay = desiredTime.get(Calendar.DATE);
            desiredTime.set(existingYear, existingMonth, existingDay, 
                            BIGGEST_24_HOUR_HOUR, BIGGEST_MIN);
            date2 = desiredTime.getTime();
        }
    }
    
    /**
     * Checks that the date represented by date1 is before the date represented
     * by date2.
     */
    private static void checkDate1BeforeDate2() {
        if (date != null && date2 != null) {
            if (!(date.compareTo(date2) < 0)) {
                logger.log(Level.WARNING, "Date 1 not smaller than Date 2");
                setCommandType(CommandType.INVALID);
                setErrorType(ErrorType.DATE1_NOT_SMALLER_THAN_DATE2);
            }
        }
    }
}

	// End of segment: C:\Users\GamePro-Pc\Desktop\Work\Y2S2\CS2103\main\source\src\planner\Parser.java





	/**
	 * origin: C:\Users\GamePro-Pc\Desktop\Work\Y2S2\CS2103\main\source\src\planner\ParseResult.java
	 */

package planner;

import java.util.Arrays;
import java.util.Date;

import planner.Constants.CommandType;
import planner.Constants.ErrorType;

/**
 * This class is used to deliver the results of  
 * parsing a user command to the engine. 
 */
public class ParseResult {

    private final int NO_PRIORITY_LEVEL = 0;
    private final int NO_ID_SET = 0;
    private final int COMMAND_FLAGS_MAX_SIZE = 8;    

    private CommandType commandType = null;
    private Date parsedDate = null;
    private Date parsedDate2 = null;
    private Date dateToRemind = null;
    private int priorityLevel = NO_PRIORITY_LEVEL;
    private long taskId = NO_ID_SET;
    private String taskName = "";
    private String taskDescription = "";
    private String taskTag = "";
    private ErrorType errorType = null;
    // flags order: date, dateToRemind, priorityLevel, id, name,
    //              description, tag, date2
    private boolean[] commandFlags;
    
    /**
     * This method is the ParseResult constructor.
     * 
     * @param commandType Type of the command e.g. search.
     * @param time        Time/date parsed from command.               
     * @param flags       Indicate presence of properties (e.g. time).
     */
	public ParseResult(CommandType commandType,
                       Date date, Date date2, Date dateToRemind, 
                       int priorityLevel, long id, String name, 
                       String description, String tag, ErrorType errorType,
                       boolean[] flags) {

        this.commandType = commandType;
        
        if (date != null) {            
            this.parsedDate = new Date(date.getTime());                   
        } else {            
            this.parsedDate = null;
        }
        
        if (dateToRemind != null) {            
            this.dateToRemind = new Date(dateToRemind.getTime());           
        } else {            
            this.dateToRemind = null;
        }

        this.parsedDate2 = date2;
        this.dateToRemind = dateToRemind;
        this.priorityLevel = priorityLevel;
        this.taskId = id;
        this.taskName = name;
        this.taskDescription = description;
        this.taskTag = tag;
        this.errorType = errorType;
        this.commandFlags = flags;
        
        if(flags != null) {            
            this.commandFlags = Arrays.copyOf(flags, flags.length);       
        } else {            
            this.commandFlags = new boolean[COMMAND_FLAGS_MAX_SIZE];
        }
    }
	
	/**
	 * Gets the type of command the user input
	 * 
	 * @return Command type.
	 */
    public CommandType getCommandType() {
        return commandType;
    }

    /**
     * Gets the first date field the user input.
     * 
     * @return First date field.
     */
    public Date getDate() {
        if (parsedDate != null) {
            return new Date(parsedDate.getTime());
        } else {
            return null;
        }
    }
    
    /**
     * Gets the second date field the user input.
     * 
     * @return Second date field.
     */
    public Date getSecondDate() {
        return parsedDate2;
    }
    
    /**
     * Gets the date by which the user wishes to be reminded.
     * 
     * @return Reminder date.
     */
    public Date getDateToRemind() {     
        if (dateToRemind != null) {
            return new Date(dateToRemind.getTime());
        } else {
            return null;
        }
    }

    /**
     * Gets the priority level the user input.
     * 
     * @return Priority level.
     */
    public int getPriorityLevel() {
        return priorityLevel;
    }

    /**
     * Gets the task id the user input.
     * 
     * @return Task id.
     */
    public long getId() {
        return taskId;
    }

    /**
     * Gets the task name the user input.
     * 
     * @return Task name.
     */
    public String getName() {
        return taskName;
    }

    /**
     * Gets the task description the user input.
     * 
     * @return Task description.
     */
    public String getDescription() {
        return taskDescription;
    }

    /**
     * Gets the task tag the user input.
     * 
     * @return Task tag.
     */
    public String getTag() {
        return taskTag;
    }

    /**
     * Gets the error from parsing the user command.
     * 
     * @return Error type.
     */
    public ErrorType getErrorType() {
        return errorType;
    }
    
    /**
     * Gets the flags that represent which fields in the result contain valid
     * values.
     * 
     * @return Field validity flags.
     */
    public boolean[] getCommandFlags() {
        if (commandFlags != null) {
            return Arrays.copyOf(commandFlags, commandFlags.length);
        } else {
            return new boolean[COMMAND_FLAGS_MAX_SIZE];
        }
    }
}

	// End of segment: C:\Users\GamePro-Pc\Desktop\Work\Y2S2\CS2103\main\source\src\planner\ParseResult.java





	/**
	 * origin: C:\Users\GamePro-Pc\Desktop\Work\Y2S2\CS2103\main\source\test\planner\ParserTest.java
	 */

package planner;

import static org.junit.Assert.*;

import java.util.Arrays;

import org.junit.Test;

public class ParserTest {
    
    @Test
    /**
     * Tests adding all the fields, as well as the partitions of the starts
     * and ends of years, months and days.
     */
    public void testAddCommandWithAllFieldsIncludingBoundaryDateTimes() {
        ParseResult result = Parser.parse("add important meeting with boss on 1 Jan 2018 am 0.00 until 31 Dec 2018 pm 11.59 priority 5 tag important desc testdescription");
        assertEquals(Constants.CommandType.ADD, result.getCommandType());
        assertEquals("Mon Jan 01 00:00:00 SGT 2018", result.getDate().toString());
        assertEquals("Mon Dec 31 23:59:00 SGT 2018", result.getSecondDate().toString()); 
        assertTrue(result.getDateToRemind() == null);
        assertEquals(5, result.getPriorityLevel());
        assertEquals(Constants.NO_ID_SET, result.getId());
        assertEquals("testdescription", result.getDescription());
        assertEquals("important", result.getTag());
        assertTrue(result.getErrorType() == null);
        boolean[] flags = {true, false, true, false, true, true, true, true};
        assertTrue(Arrays.equals(flags, result.getCommandFlags()));
        assertEquals("important meeting with boss", result.getName());        
    }
    
    @Test
    /**
     * Tests adding all the fields, as well as the boundaries on the 12pm 
     * partition.
     */
    public void testAddCommandWithAllFieldsIncluding12pm() {
        ParseResult result = Parser.parse("add important meeting with boss on 1 Jan 2018 pm 12.00 until 31 Dec 2018 pm 12.01 priority 5 tag important desc testdescription");
        assertEquals(Constants.CommandType.ADD, result.getCommandType());
        assertEquals("Mon Jan 01 12:00:00 SGT 2018", result.getDate().toString());
        assertEquals("Mon Dec 31 12:01:00 SGT 2018", result.getSecondDate().toString()); 
        assertTrue(result.getDateToRemind() == null);
        assertEquals(5, result.getPriorityLevel());
        assertEquals(Constants.NO_ID_SET, result.getId());
        assertEquals("testdescription", result.getDescription());
        assertEquals("important", result.getTag());
        assertTrue(result.getErrorType() == null);
        boolean[] flags = {true, false, true, false, true, true, true, true};
        assertTrue(Arrays.equals(flags, result.getCommandFlags()));
        assertEquals("important meeting with boss", result.getName());        
    }
    
    @Test
    /**
     * Tests that inputting on the 'date1 that is not earlier than date2' 
     * partition results in an invalid command type and the correct error 
     * message.
     */
    public void testAddCommandWithDate1NotEarlierThanDate2() {
        ParseResult result = Parser.parse("add holiday /in bali date 3 Jun 1123 until 2 Jun 1123");
        assertEquals(Constants.CommandType.INVALID, result.getCommandType());
        assertEquals("Sun Jun 03 00:00:00 SGT 1123", result.getDate().toString());
        assertEquals("Sat Jun 02 23:59:00 SGT 1123", result.getSecondDate().toString()); 
        assertTrue(result.getDateToRemind() == null);
        assertEquals(0, result.getPriorityLevel());
        assertEquals(Constants.NO_ID_SET, result.getId());
        assertEquals("", result.getDescription());
        assertEquals("", result.getTag());
        assertEquals(Constants.ErrorType.DATE1_NOT_SMALLER_THAN_DATE2, result.getErrorType());
        boolean[] flags = {true, false, false, false, true, false, false, true};
        assertTrue(Arrays.equals(flags, result.getCommandFlags()));
        assertEquals("holiday in bali", result.getName());   
    }

    @Test
    /**
     * Tests an update command with all fields.
     */
    public void testUpdateCommandWithAllFields() {
        ParseResult result = Parser.parse("update 123 fish eating contest date 23 June 2015 pm 7.46 desc testUpdate tag updateTest priority 1");
        assertEquals(Constants.CommandType.UPDATE, result.getCommandType());
        assertEquals("Tue Jun 23 19:46:00 SGT 2015", result.getDate().toString());
        assertTrue(result.getSecondDate() == null);
        assertTrue(result.getDateToRemind() == null);
        assertEquals(1, result.getPriorityLevel());
        assertEquals(123, result.getId());
        assertEquals("testUpdate", result.getDescription());
        assertEquals("updateTest", result.getTag());
        assertTrue(result.getErrorType() == null);
        boolean[] flags = {true, false, true, true, true, true, true, false};
        assertTrue(Arrays.equals(flags, result.getCommandFlags()));
        assertEquals("fish eating contest", result.getName());
    }
    
    @Test
    public void testNextMonth(){
        ParseResult result = Parser.parse("edit 322 date next month");
        assertEquals(Constants.CommandType.UPDATE, result.getCommandType());
        assertEquals("Fri May 01 00:00:00 SGT 2015", result.getDate().toString());
        assertTrue(result.getSecondDate() == null);
        assertTrue(result.getDateToRemind() == null);
        assertEquals(322, result.getId());
        assertEquals(0, result.getPriorityLevel());
        assertEquals("", result.getDescription());
        assertEquals("", result.getTag());
        assertTrue(result.getErrorType() == null);
        boolean[] flags = {true, false, false, true, false, false, false, false};
        assertTrue(Arrays.equals(flags, result.getCommandFlags()));
        assertEquals("", result.getName());
    }
    
    @Test
    /**
     * Tests that the delete command correctly processes the command type.
     */
    public void testDeleteCommand() {
        ParseResult result = Parser.parse("remove 462 at 15 Nov 1995");
        assertEquals(Constants.CommandType.DELETE, result.getCommandType());
        assertTrue(result.getDate() == null);
        assertTrue(result.getSecondDate() == null);
        assertTrue(result.getDateToRemind() == null);
        assertEquals(0, result.getPriorityLevel());
        assertEquals(462, result.getId());
        assertEquals("", result.getDescription());
        assertEquals("", result.getTag());
        assertTrue(result.getErrorType() == null);
        boolean[] flags = {false, false, false, true, false, false, false, false};
        assertTrue(Arrays.equals(flags, result.getCommandFlags()));
        assertEquals("", result.getName());
    }
    
    @Test
    /**
     * Tests that the correct usage of the done command correctly processes the 
     * command type.
     */
    public void testDoneCommand() {
        ParseResult result = Parser.parse("done 347564 date 111 Mar 3917");
        assertEquals(Constants.CommandType.DONE, result.getCommandType());
        assertTrue(result.getDate() == null);
        assertTrue(result.getSecondDate() == null);
        assertTrue(result.getDateToRemind() == null);
        assertEquals(0, result.getPriorityLevel());
        assertEquals(347564, result.getId());
        assertEquals("", result.getDescription());
        assertEquals("", result.getTag());
        assertTrue(result.getErrorType() == null);
        boolean[] flags = {false, false, false, true, false, false, false, false};
        assertTrue(Arrays.equals(flags, result.getCommandFlags()));
        assertEquals("", result.getName());        

    }
    
    @Test
    /**
     * Tests that the correct usage of the setnotdone command correctly 
     * processes the command type.
     */
    public void testSetNotDoneCommand() {
        ParseResult result = Parser.parse("setnotdone 322 date 111 Mar 3917");
        assertEquals(Constants.CommandType.SETNOTDONE, result.getCommandType());
        assertTrue(result.getDate() == null);
        assertTrue(result.getSecondDate() == null);
        assertTrue(result.getDateToRemind() == null);
        assertEquals(0, result.getPriorityLevel());
        assertEquals(322, result.getId());
        assertEquals("", result.getDescription());
        assertEquals("", result.getTag());
        assertTrue(result.getErrorType() == null);
        boolean[] flags = {false, false, false, true, false, false, false, false};
        assertTrue(Arrays.equals(flags, result.getCommandFlags()));
        assertEquals("", result.getName()); 
    }
    
    @Test
    /**
     * Test that done command without a valid id immediately after 'done' 
     * (incorrect usage) returns the correct command and error types.
     */
    public void testDoneCommandWithoutID() {
        ParseResult result = Parser.parse("done fishburger 234234 pig sandwich");
        assertEquals(Constants.CommandType.INVALID, result.getCommandType());
        assertTrue(result.getDate() == null);
        assertTrue(result.getSecondDate() == null);
        assertTrue(result.getDateToRemind() == null);
        assertEquals(0, result.getPriorityLevel());
        assertEquals(Constants.NO_ID_SET, result.getId());
        assertEquals("", result.getDescription());
        assertEquals("", result.getTag());
        assertEquals(Constants.ErrorType.INVALID_TASK_ID, result.getErrorType());
        boolean[] flags = {false, false, false, false, false, false, false, false};
        assertTrue(Arrays.equals(flags, result.getCommandFlags()));
        assertEquals("", result.getName());
    }

    @Test
    /**
     * Tests the search command on all possible fields.
     */
    public void testSearchNameTagDescDateReminddate() {
        ParseResult result = Parser.parse("search sushi bar tag food description delicious on 10 Oct 1528 until 11 Oct 1528 remind 9 Oct 1528");
        assertEquals(Constants.CommandType.SEARCH, result.getCommandType());
        assertEquals("Sat Oct 10 00:00:00 SGT 1528", result.getDate().toString());
        assertEquals("Sun Oct 11 00:00:00 SGT 1528", result.getSecondDate().toString());
        assertEquals("Fri Oct 09 00:00:00 SGT 1528", result.getDateToRemind().toString());
        assertEquals(Constants.NO_ID_SET, result.getId());
        assertEquals(0, result.getPriorityLevel());
        assertEquals("delicious", result.getDescription());
        assertEquals("food", result.getTag());
        assertTrue(result.getErrorType() == null);
        boolean[] flags = {true, true, false, false, true, true, true, true};
        assertTrue(Arrays.equals(flags, result.getCommandFlags()));
        assertEquals("sushi bar", result.getName());
    }

    @Test
    /**
     * Test that the help command correctly sets the command type.
     */
    public void testGeneralHelpCommand() {
        ParseResult result = Parser.parse("help me find my fish at 13 Dec 1287");
        assertEquals(Constants.CommandType.HELP, result.getCommandType());
        assertTrue(result.getDate() == null);
        assertTrue(result.getSecondDate() == null);
        assertTrue(result.getDateToRemind() == null);
        assertEquals(0, result.getPriorityLevel());
        assertEquals(Constants.NO_ID_SET, result.getId());
        assertEquals("", result.getDescription());
        assertEquals("", result.getTag());
        assertTrue(result.getErrorType() == null);
        boolean[] flags = {false, false, false, false, false, false, false, false};
        assertTrue(Arrays.equals(flags, result.getCommandFlags()));
        assertEquals("", result.getName());
    }
    
    @Test
    /**
     * Tests that specifying a command together with help sets the correct 
     * command type.
     * NO LONGER IN USE DUE TO HELP WINDOW DISPLAYING EVERYTHING.
     */
    public void testSpecificHelpCommand() {
        ParseResult result = Parser.parse("help add search delete done at 24 Jan 1172");
        assertEquals(Constants.CommandType.HELP_ADD, result.getCommandType());
        assertTrue(result.getDate() == null);
        assertTrue(result.getSecondDate() == null);
        assertTrue(result.getDateToRemind() == null);
        assertEquals(0, result.getPriorityLevel());
        assertEquals(Constants.NO_ID_SET, result.getId());
        assertEquals("", result.getDescription());
        assertEquals("", result.getTag());
        assertTrue(result.getErrorType() == null);
        boolean[] flags = {false, false, false, false, false, false, false, false};
        assertTrue(Arrays.equals(flags, result.getCommandFlags()));
        assertEquals("", result.getName());
    }
    
    /**
     * Tests that correct usage of converting a task to a timed task sets the
     * fields correctly.
     */
    @Test
    public void testConvertToTimedCommand() {
        ParseResult result = Parser.parse("convert 275 timed date 15 Jun 1992 am 3.50 until 27 Jun 1992 am 2.29");
        assertEquals(Constants.CommandType.CONVERT_TIMED, result.getCommandType());
        assertEquals("Mon Jun 15 03:50:00 SGT 1992", result.getDate().toString());
        assertEquals("Sat Jun 27 02:29:00 SGT 1992", result.getSecondDate().toString());
        assertTrue(result.getDateToRemind() == null);
        assertEquals(275, result.getId());
        assertEquals(0, result.getPriorityLevel());
        assertEquals("", result.getDescription());
        assertEquals("", result.getTag());
        assertTrue(result.getErrorType() == null);
        boolean[] flags = {true, false, false, true, false, false, false, true};
        assertTrue(Arrays.equals(flags, result.getCommandFlags()));
        assertEquals("", result.getName());
    }
    
    /**
     * Tests that converting a task to a timed task with only one date sets the 
     * correct command and error types.
     */
    @Test
    public void testConvertToTimedWithOnlyOneDate() {
        ParseResult result = Parser.parse("convert 12616 timed date 15 Jun 1992");
        assertEquals(Constants.CommandType.INVALID, result.getCommandType());
        assertEquals("Mon Jun 15 00:00:00 SGT 1992", result.getDate().toString());
        assertTrue(result.getSecondDate() == null);
        assertTrue(result.getDateToRemind() == null);
        assertEquals(0, result.getPriorityLevel());
        assertEquals(12616, result.getId());
        assertEquals("", result.getDescription());
        assertEquals("", result.getTag());
        assertEquals(Constants.ErrorType.INVALID_NUMBER_OF_DATES, result.getErrorType());
        boolean[] flags = {true, false, false, true, false, false, false, false};
        assertTrue(Arrays.equals(flags, result.getCommandFlags()));
        assertEquals("", result.getName());
    }
    
    /**
     * Tests that correct usage of converting a task to a floating task sets the
     * fields correctly.
     */
    @Test
    public void testConvertToFloatingCommand() {
        ParseResult result = Parser.parse("convert 592 floating date 17 Jun 1992 to 28 Jun 1992");
        assertEquals(Constants.CommandType.CONVERT_FLOATING, result.getCommandType());
        assertEquals("Wed Jun 17 00:00:00 SGT 1992", result.getDate().toString());
        assertEquals("Sun Jun 28 00:00:00 SGT 1992", result.getSecondDate().toString());
        assertTrue(result.getDateToRemind() == null);
        assertEquals(0, result.getPriorityLevel());
        assertEquals(592, result.getId());
        assertEquals("", result.getDescription());
        assertEquals("", result.getTag());
        assertTrue(result.getErrorType() == null);
        boolean[] flags = {true, false, false, true, false, false, false, true};
        assertTrue(Arrays.equals(flags, result.getCommandFlags()));
        assertEquals("", result.getName());
    }    
    
    /**
     * Tests that correct usage of converting a task to a deadline task sets the
     * fields correctly.
     */
    @Test
    public void testConvertToDeadlineCommand() {
        ParseResult result = Parser.parse("convert 491 deadline date 19 Jun 1992 am 4.20 until 24 Jun 1992");
        assertEquals(Constants.CommandType.CONVERT_DEADLINE, result.getCommandType());
        assertEquals("Fri Jun 19 04:20:00 SGT 1992", result.getDate().toString());
        assertEquals("Wed Jun 24 00:00:00 SGT 1992", result.getSecondDate().toString());
        assertTrue(result.getDateToRemind() == null);
        assertEquals(0, result.getPriorityLevel());
        assertEquals(491, result.getId());
        assertEquals("", result.getDescription());
        assertEquals("", result.getTag());
        assertTrue(result.getErrorType() == null);
        boolean[] flags = {true, false, false, true, false, false, false, true};
        assertTrue(Arrays.equals(flags, result.getCommandFlags()));
        assertEquals("", result.getName());
    }
    
    /**
     * Tests that converting a task to a deadline task with no date sets the
     * command and error types correctly.
     */
    @Test
    public void testConvertToDeadLineWithNoDate() {
        ParseResult result = Parser.parse("convert 3516 deadline");
        assertEquals(Constants.CommandType.INVALID, result.getCommandType());
        assertTrue(result.getDate() == null);
        assertTrue(result.getSecondDate() == null);
        assertTrue(result.getDateToRemind() == null);
        assertEquals(0, result.getPriorityLevel());
        assertEquals(3516, result.getId());
        assertEquals("", result.getDescription());
        assertEquals("", result.getTag());
        assertEquals(Constants.ErrorType.INVALID_NUMBER_OF_DATES, result.getErrorType());
        boolean[] flags = {false, false, false, true, false, false, false, false};
        assertTrue(Arrays.equals(flags, result.getCommandFlags()));
        assertEquals("", result.getName());
    }
    
    @Test
    /**
     * Tests that Undo correctly sets the command type.
     */
    public void testUndoCommand() {
        ParseResult result = Parser.parse("undo 1242 date 2 may 3018");
        assertEquals(Constants.CommandType.UNDO, result.getCommandType());
        assertTrue(result.getDate() == null);
        assertTrue(result.getSecondDate() == null);
        assertTrue(result.getDateToRemind() == null);
        assertEquals(0, result.getPriorityLevel());
        assertEquals(0, result.getId());
        assertEquals("", result.getDescription());
        assertEquals("", result.getTag());
        assertTrue(result.getErrorType() == null);
        boolean[] flags = {false, false, false, false, false, false, false, false};
        assertTrue(Arrays.equals(flags, result.getCommandFlags()));
        assertEquals("", result.getName());
    }
    
	// End of segment: C:\Users\GamePro-Pc\Desktop\Work\Y2S2\CS2103\main\source\test\planner\ParserTest.java





	/**
	 * origin: C:\Users\GamePro-Pc\Desktop\Work\Y2S2\CS2103\main\source\test\planner\ParserTest.java
	 */

    @Test
    /**
     * Tests that the savewhere command correctly sets the command type to 
     * SAVEWHERE and that there are no other valid fields in the parse result.
     */
    public void testSaveWhereCommand() {
        ParseResult result = Parser.parse("savewhere date 3 may 2015 priority 5 tag important desc testsavewherecommand");
        assertEquals(Constants.CommandType.SAVEWHERE, result.getCommandType());
        assertTrue(result.getDate() == null);
        assertTrue(result.getSecondDate() == null);
        assertTrue(result.getDateToRemind() == null);
        assertEquals(0, result.getPriorityLevel());
        assertEquals(0, result.getId());
        assertEquals("", result.getDescription());
        assertEquals("", result.getTag());
        assertTrue(result.getErrorType() == null);
        boolean[] flags = {false, false, false, false, false, false, false, false};
        assertTrue(Arrays.equals(flags, result.getCommandFlags()));
        assertEquals("", result.getName());
    }
    
    @Test
    /**
     * Tests that the savehere command correctly sets the command type to 
     * SAVEHERE and that other than the name field, there are no other valid 
     * fields in the parse result.
     */
    public void testSaveHereCommand() {
        ParseResult result = Parser.parse("savehere C:\\Program Files date 3 may 2015 priority 5 tag important desc testsavewherecommand");
        assertEquals(Constants.CommandType.SAVEHERE, result.getCommandType());
        assertTrue(result.getDate() == null);
        assertTrue(result.getSecondDate() == null);
        assertTrue(result.getDateToRemind() == null);
        assertEquals(0, result.getPriorityLevel());
        assertEquals(0, result.getId());
        assertEquals("", result.getDescription());
        assertEquals("", result.getTag());
        assertTrue(result.getErrorType() == null);
        boolean[] flags = {false, false, false, false, true, false, false, false};
        assertTrue(Arrays.equals(flags, result.getCommandFlags()));
        assertEquals("C:\\Program Files", result.getName());
    }
    
    @Test
    /**
     * Tests that the exit command correctly sets the command type to 
     * EXIT and that there are no other valid fields in the parse result.
     */
    public void testExitCommand() {
        ParseResult result = Parser.parse("exit date 15 jun 1346 priority 3 tag sushi desc testexitcommand");
        assertEquals(Constants.CommandType.EXIT, result.getCommandType());
        assertTrue(result.getDate() == null);
        assertTrue(result.getSecondDate() == null);
        assertTrue(result.getDateToRemind() == null);
        assertEquals(0, result.getPriorityLevel());
        assertEquals(0, result.getId());
        assertEquals("", result.getDescription());
        assertEquals("", result.getTag());
        assertTrue(result.getErrorType() == null);
        boolean[] flags = {false, false, false, false, false, false, false, false};
        assertTrue(Arrays.equals(flags, result.getCommandFlags()));
        assertEquals("", result.getName());
    }    
}

	// End of segment: C:\Users\GamePro-Pc\Desktop\Work\Y2S2\CS2103\main\source\test\planner\ParserTest.java





