//@author: a0111333b



	/**
	 * origin: C:\Users\GamePro-Pc\Desktop\Work\Y2S2\CS2103\main\source\src\planner\CommandTextbox.java
	 */


package planner;

import java.awt.BorderLayout;
import java.awt.Color;
import java.awt.Dimension;
import java.awt.Font;
import java.awt.Rectangle;
import java.awt.event.KeyEvent;
import java.util.ArrayList;
import java.util.Map;

import javax.swing.DefaultComboBoxModel;
import javax.swing.JComboBox;
import javax.swing.JScrollBar;
import javax.swing.JScrollPane;
import javax.swing.JTextPane;
import javax.swing.event.DocumentEvent;
import javax.swing.event.DocumentListener;
import javax.swing.text.AbstractDocument;
import javax.swing.text.Document;
import javax.swing.text.Style;
import javax.swing.text.StyleConstants;

/**
* The CommandTextbox class is YOPO's command text field component in which users enter their commands. This command text field also has
* a pop up box embedded within it. The pop up box will show the relevant commands depending on the text typed within the command 
* text field
*
	// End of segment: C:\Users\GamePro-Pc\Desktop\Work\Y2S2\CS2103\main\source\src\planner\CommandTextbox.java





	/**
	 * origin: C:\Users\GamePro-Pc\Desktop\Work\Y2S2\CS2103\main\source\src\planner\CommandTextbox.java
	 */

*/
public class CommandTextbox extends JScrollPane{

    private JTextPane inputCommandBox_;
    
    private JComboBox<String> popUpBox_;
    
    private DefaultComboBoxModel<String> popUpList_;
    
    private String []commandKeywords_;
    private String []nonCommandKeywords_;
    
    private Style originalTextStyle_;
    
    private ArrayList<String> possibleCommands_;
    
    private int currentPopupListIndex_;
    
    private CustomTextFieldDocumentFilter commandPanelDocumentFilter_;
    
    private boolean isCurrentlyHandlingKeyEvent_;
    
    private final int SELF_DEFINED_MINIMUM_IDX_OF_POPUP_LIST = -2;
    private final int MINIMUM_IDX_OF_POPUP_LIST = -1;
    private final int FIRST_ITEM_IDX_IN_POPUP_LIST = 0;
    private final int SIZE_OF_ONE_ITEM_IN_POPUP_LIST = 1;
    private final int SIZE_OF_EMPTY_POPUP_LIST = 0;
    private final int MINIMUM_POPUP_BOX_HEIGHT = 0;
    private final int DEFAULT_POPUP_BOX_STRING_FONT_SIZE = 14;
    private final int DEFAULT_TEXTPANE_STRING_FONT_SIZE = 20;
    private final int MINIMUM_POPUP_BOX_RELATIVE_YCOORDINATE = 0;
    private final int DEFAULT_POPUP_BOX_RELATIVE_YCOORDINATE = 30;
    private final int NUM_WORDS_TO_SPLIT_INTO = 2;
    private final int MIMIMUM_STRING_LENGTH = 0;
    private final int FIRST_WORD_INDEX = 0;
    private final int MINIMUM_SCROLLBAR_WIDTH = 0;
    private final int MINIMUM_SCROLLBAR_HEIGHT = 0;
    private final int ONE_CARET_INCREMENT_LENGTH = 1;
    private final int MINIMUM_CARET_POSITION = 0;
    
    private final String DEFAULT_DELIMITER = " ";
    private final String DEFAULT_POPUP_BOX_STRING_FONT_FAMILY = "Arial";
    private final String DEFAULT_TEXTPANE_STRING_FONT_FAMILY = "Arial";
    private final String DEFAULT_TEXT_STYLE_NAME = "original";
    
    private final Color DEFAULT_TEXTPANE_FONT_COLOR = new Color(128,128,128);
    
    private final int DEFAULT_NUMBER_OF_PIXELS_TO_SHOW_BEYOND_CARET = 2;
    /**
     * Constructs a command text field component with a pop up box embedded within it. The pop up box will show
     * the relevant commands based on the list of command Keywords passed in. Any keyword found within commandKeywords or
     * nonCommandKeywords will be syntax colored when entered in this command text field component
     *
     * @param commandKeywords       The list of command keywords that will be used by YOPO to perform operations
     * @param nonCommandKeywords    The list of non-command keywords that will be used by YOPO to customize the behavior of an operations
     * @param listOfCommands        Several lists of example commands that can be entered into YOPO to perform operations categorized by
     *                              the command keyword used
     */
    public CommandTextbox( String []commandKeywords, String []nonCommandKeywords, 
                           ArrayList<Map.Entry<String, ArrayList<String>>> listOfCommands ){
        
        commandKeywords_ = commandKeywords;
        nonCommandKeywords_ = nonCommandKeywords;
        inputCommandBox_ = new JTextPane();
        prepareTextPane(inputCommandBox_);

        setFocusable(false);
        setBorder(null);
        setOpaque(false);
        
        setViewportView(inputCommandBox_);
        if( inputCommandBox_ != null ){
            getViewport().setOpaque(false);
        }
        JScrollBar horizontalScrollBar = getHorizontalScrollBar();
        
        if( horizontalScrollBar != null ){
            horizontalScrollBar.setUI(new InvisibleScrollBarUI());
            horizontalScrollBar.setFocusable(false);
            horizontalScrollBar.setPreferredSize(new Dimension(MINIMUM_SCROLLBAR_WIDTH,MINIMUM_SCROLLBAR_HEIGHT));
        }
        prepareComboBox( inputCommandBox_, listOfCommands );
        isCurrentlyHandlingKeyEvent_ = false;
    }
    
    /**
     * This method will invoke commandTextBox events that should be called when the up arrow key is registered by the keyboard
     *
     * @param keyEvent   The key event that will be processed
     * @return TRUE if the events are invoked successfully; false otherwise.
     */
    private boolean handleUpKeyEvent( KeyEvent keyEvent ){
        if( keyEvent != null ){
            if( !keyEvent.isShiftDown() && !keyEvent.isControlDown() ){
                currentPopupListIndex_ = Math.max( currentPopupListIndex_ - SIZE_OF_ONE_ITEM_IN_POPUP_LIST, 
                                                  SELF_DEFINED_MINIMUM_IDX_OF_POPUP_LIST );
                popUpBox_.setSelectedIndex(getPopupListIdx(currentPopupListIndex_, popUpList_.getSize() ));
                if( currentPopupListIndex_ <= SELF_DEFINED_MINIMUM_IDX_OF_POPUP_LIST ){
                    currentPopupListIndex_ = popUpList_.getSize() - SIZE_OF_ONE_ITEM_IN_POPUP_LIST;
                }
                if( popUpBox_.getSelectedIndex() < SIZE_OF_EMPTY_POPUP_LIST ){
                    popUpBox_.hidePopup();
                    popUpBox_.setPopupVisible(true);
                }
                return true;
            }
        }
        return false;
    }
    
    /**
     * This method will invoke commandTextBox events that should be called when the down arrow key is registered by the keyboard
     *
     * @param keyEvent   The key event that will be processed
     * @return TRUE if the events are invoked successfully; false otherwise.
     */
    private boolean handleDownKeyEvent( KeyEvent keyEvent ){
        if( keyEvent != null ){
            if( !keyEvent.isShiftDown() && !keyEvent.isControlDown() ){
                currentPopupListIndex_ = Math.min( currentPopupListIndex_ + SIZE_OF_ONE_ITEM_IN_POPUP_LIST, 
                                                  popUpList_.getSize() + SIZE_OF_ONE_ITEM_IN_POPUP_LIST );
                popUpBox_.setSelectedIndex(getPopupListIdx(currentPopupListIndex_ , popUpList_.getSize() ));
                if( currentPopupListIndex_ > popUpList_.getSize() ){
                    currentPopupListIndex_ = (popUpList_.getSize() > SIZE_OF_EMPTY_POPUP_LIST ? FIRST_ITEM_IDX_IN_POPUP_LIST : MINIMUM_IDX_OF_POPUP_LIST);
                }
                if( popUpBox_.getSelectedIndex() < SIZE_OF_EMPTY_POPUP_LIST ){
                    popUpBox_.hidePopup();
                    popUpBox_.setPopupVisible(true);
                }
                return true;
            }
        }
        return false;
    }
    
    /**
     * This method will invoke commandTextBox events that should be called when the left arrow key is registered by the keyboard
     *
     * @param keyEvent   The key event that will be processed
     * @return TRUE if the events are invoked successfully; false otherwise.
     */
    private boolean handleLeftKeyEvent( KeyEvent keyEvent ){
        if( keyEvent != null ){
            int pos = Math.max(inputCommandBox_.getCaretPosition() - ONE_CARET_INCREMENT_LENGTH, MINIMUM_CARET_POSITION );
            inputCommandBox_.setCaretPosition(pos);
            popUpBox_.hidePopup();
            popUpBox_.setPopupVisible(true);
            return true;
        }
        return false;
    }
    
    /**
     * This method will invoke commandTextBox events that should be called when the right arrow key is registered by the keyboard
     *
     * @param keyEvent   The key event that will be processed
     * @return TRUE if the events are invoked successfully; false otherwise.
     */
    private boolean handleRightKeyEvent( KeyEvent keyEvent ){
        if( keyEvent != null ){
            int pos = Math.min(inputCommandBox_.getText().length(), inputCommandBox_.getCaretPosition() + ONE_CARET_INCREMENT_LENGTH );
            inputCommandBox_.setCaretPosition(pos);
            popUpBox_.hidePopup();
            popUpBox_.setPopupVisible(true);
            return true;
        }
        return false;
    }
    
    /**
     * This method will invoke commandTextBox events that should be called when the enter key is registered by the keyboard
     *
     * @param keyEvent   The key event that will be processed
     * @return TRUE if the events are invoked successfully; false otherwise.
     */
    private boolean handleEnterKeyEvent( KeyEvent keyEvent ){
        if( keyEvent != null ){
            if( popUpBox_.getSelectedItem() != null ){
                inputCommandBox_.setText(popUpBox_.getSelectedItem().toString());
                popUpBox_.hidePopup();
                popUpBox_.setPopupVisible(false);
                inputCommandBox_.setCaretPosition(inputCommandBox_.getText().length());
                return true;
            } else{
                popUpBox_.hidePopup();
                popUpBox_.setPopupVisible(false);
            }
        }
        return false;
    }
    
    /**
     * This method will invoke commandTextBox events that should be called when specific keys are registered by the keyboard
     *
     * @param keyEvent   The key event that will be processed
     * @return TRUE if the events are invoked successfully; false otherwise.
     */
    public boolean handleKeyEvent( KeyEvent keyEvent ){
        if( !isCurrentlyHandlingKeyEvent_ && keyEvent != null && popUpBox_ != null && popUpList_ != null ){
            if( popUpBox_ != null && popUpBox_.isPopupVisible() && inputCommandBox_.isFocusOwner() ){
                isCurrentlyHandlingKeyEvent_ = true;
                restrictPopupBoxDimensions( inputCommandBox_, popUpBox_, DEFAULT_POPUP_BOX_RELATIVE_YCOORDINATE );
                keyEvent.setSource( popUpBox_ );
                popUpBox_.dispatchEvent(keyEvent);
                if( keyEvent.getKeyCode() == KeyEvent.VK_UP ){
                    if( !handleUpKeyEvent(keyEvent) ){
                        isCurrentlyHandlingKeyEvent_ = false;
                        return false;
                    }
                } else if( keyEvent.getKeyCode() == KeyEvent.VK_DOWN ){
                    if( !handleDownKeyEvent(keyEvent) ){
                        isCurrentlyHandlingKeyEvent_ = false;
                        return false;
                    }
                } else if( keyEvent.getKeyCode() == KeyEvent.VK_LEFT ){
                    if( !handleLeftKeyEvent(keyEvent) ){
                        isCurrentlyHandlingKeyEvent_ = false;
                        return false;
                    }
                } else if( keyEvent.getKeyCode() == KeyEvent.VK_RIGHT ){
                    if( !handleRightKeyEvent(keyEvent) ){
                        isCurrentlyHandlingKeyEvent_ = false;
                        return false;
                    }
                } else if( keyEvent.getKeyCode() == KeyEvent.VK_ENTER ){
                    if( !handleEnterKeyEvent(keyEvent) ){
                        isCurrentlyHandlingKeyEvent_ = false;
                        return false;
                    }
                }
                isCurrentlyHandlingKeyEvent_ = false;
                return true;
            }
        }
        return false;
    }
    
    /**
     * Returns a self defined index of the currently selected item in the pop-up box based on the current index of the item in the pop up box list
     * and the size of the pop up box list.
     *
     * @param idx              Current index of the item in the pop up box list
     * @param listSize         The size of the pop up box list.
     * @param listOfCommands   Several lists of example commands that can be entered into YOPO to perform operations categorized by
     *                         the command keyword used
     */
    private int getPopupListIdx( int idx, int listSize ){
        if( idx >= FIRST_ITEM_IDX_IN_POPUP_LIST && idx < listSize ){
            return idx;
        } else if( idx == SELF_DEFINED_MINIMUM_IDX_OF_POPUP_LIST ){
            return listSize-SIZE_OF_ONE_ITEM_IN_POPUP_LIST;
        } else if( idx == listSize + SIZE_OF_ONE_ITEM_IN_POPUP_LIST ){
            return (listSize > SIZE_OF_EMPTY_POPUP_LIST ? FIRST_ITEM_IDX_IN_POPUP_LIST : MINIMUM_IDX_OF_POPUP_LIST);
        } else{
            return MINIMUM_IDX_OF_POPUP_LIST;
        }
    }
    
    /**
     * Initializes and set the attributes of the popup box and its list.
     *
     * @param textPane         The text component that the pop up box will be embedded within
     * @param listOfCommands   Several lists of example commands that can be entered into YOPO to perform operations categorized by
     *                         the command keyword used     
     */
    private void prepareComboBox( final JTextPane textPane, 
                                  ArrayList<Map.Entry<String, ArrayList<String>>> listOfCommands){
        
        if( textPane != null && listOfCommands != null ){
            popUpList_ = new DefaultComboBoxModel<String>();
            popUpBox_ = new JComboBox<String>(popUpList_){
                @Override
                public Dimension getPreferredSize(){
                    return new Dimension( textPane.getVisibleRect().width, MINIMUM_POPUP_BOX_HEIGHT );
                }
            };
           
            popUpBox_.setOpaque(false);
            popUpBox_.setFocusable(false);
            popUpBox_.setFont(new Font(DEFAULT_POPUP_BOX_STRING_FONT_FAMILY, Font.PLAIN, DEFAULT_POPUP_BOX_STRING_FONT_SIZE));
            possibleCommands_ = new ArrayList<String>();
            
            ArrayList<String> tempStringList;
            for( Map.Entry<String, ArrayList<String>> tempEntry : listOfCommands ){
                tempStringList = tempEntry.getValue();
                if( tempStringList != null ){
                    for( String tempString : tempStringList ){
                        if( tempString != null ){
                            possibleCommands_.add(tempString);
                        }
                    }
                }
            }
            currentPopupListIndex_ = MINIMUM_IDX_OF_POPUP_LIST;
            popUpBox_.setSelectedIndex(currentPopupListIndex_);
            bindDocumentListener( textPane, popUpBox_, popUpList_ );
            textPane.setLayout(new BorderLayout());
            textPane.add( popUpBox_, BorderLayout.SOUTH );
        }
    }
    
    /**
     * Turns syntax text coloring on within the text component
     */
    public void setSyntaxFilterOn(){
        commandPanelDocumentFilter_.setFilterOn();
    }
    
    /**
     * Turns syntax text coloring off within the text component
     */
    public void setSyntaxFilterOff(){
        commandPanelDocumentFilter_.setFilterOff();
    }
    
    /**
     * Hides the popup box used to display the relevant example commands from view  
     */
    public void hidePopupBox(){
        if( popUpBox_ != null ){
            popUpBox_.removeAllItems();
            popUpBox_.setPopupVisible(false);
            popUpBox_.hidePopup();
        }
    }
    
    /**
     * Displays the popup box used to show the relevant example commands
     */
    public void showPopupBox(){
        if( popUpBox_ != null ){
            popUpBox_.setPopupVisible(true);
            popUpBox_.showPopup();
        }
    }
    
    /**
     * Sets up a listener for the text component to listen for text updates and update the list of relevant example commands to show within
     * the pop up box
     *
     * @param textPane         The text component that will display the text typed in
     * @param popupBox         The pop up box that will show the relevant example commands fetched from the popupBoxList
     * @param popupBoxList     The list that the pop up box will refer to for relevant example commands to display
     */
    private void bindDocumentListener( final JTextPane textPane, final JComboBox<String> popupBox, 
                                       final DefaultComboBoxModel<String> popupBoxList ){
        
        if( textPane != null && popupBox != null && popupBoxList != null ){
            Document doc = textPane.getDocument();
            if( doc != null ){
                doc.addDocumentListener(new DocumentListener(){
                    @Override
                    public void insertUpdate( DocumentEvent documentEvent ){
                        updatePopBoxList();
                    }
                    @Override
                    public void removeUpdate( DocumentEvent documentEvent ){
                        updatePopBoxList();
                    }
                    @Override
                    public void changedUpdate( DocumentEvent documentEvent ){
                        updatePopBoxList();
                    }
                    public void updatePopBoxList(){
                        if( textPane.isFocusOwner() ){
                            restrictPopupBoxDimensions( textPane, popupBox, DEFAULT_POPUP_BOX_RELATIVE_YCOORDINATE );
                            popupBoxList.removeAllElements();
                            String userInput = textPane.getText().trim();
                            if( !userInput.isEmpty() ){
                                String []userInputWords = userInput.split( DEFAULT_DELIMITER, NUM_WORDS_TO_SPLIT_INTO );
                                if( userInputWords.length > MIMIMUM_STRING_LENGTH ){
                                    String firstWordInUserInput = userInputWords[FIRST_WORD_INDEX].toLowerCase();
                                    String []wordsInCommand;
                                    for( String currentCommand : possibleCommands_ ){
                                        wordsInCommand = currentCommand.split( DEFAULT_DELIMITER, NUM_WORDS_TO_SPLIT_INTO );
                                        if( wordsInCommand.length > MIMIMUM_STRING_LENGTH && 
                                            firstWordInUserInput.startsWith(wordsInCommand[FIRST_WORD_INDEX]) ){
                                            popupBoxList.addElement(currentCommand);
                                        }
                                    }
                                }
                            }
                            currentPopupListIndex_ = MINIMUM_IDX_OF_POPUP_LIST;
                            popupBox.setSelectedIndex(currentPopupListIndex_);
                            popupBox.hidePopup();
                            popupBox.setPopupVisible(popupBoxList.getSize() > SIZE_OF_EMPTY_POPUP_LIST);
                        }
                    }
                });
            }
        }
    }
    
    /**
     * Sets the size of the pop up box used to display the relevant example commands
     *
     * @param textPane         The text component that will display the text typed in
     * @param popupBox         The pop up box that will show the relevant example commands fetched from the popupBoxList
     * @param yCoordinate      The y-coordinate of the top left corner of the pop up box that will be displayed at relative to 
     *                         the text component
     */
    private void restrictPopupBoxDimensions( JTextPane textPane, JComboBox<String> popupBox, int yCoordinate ){
        Rectangle tempRectangle = textPane.getVisibleRect();
        if( tempRectangle != null && popupBox != null && yCoordinate >= MINIMUM_POPUP_BOX_RELATIVE_YCOORDINATE ){
            tempRectangle.height = MINIMUM_POPUP_BOX_HEIGHT;
            tempRectangle.y = yCoordinate;
            popupBox.setBounds(tempRectangle);
        }
    }
    
    /**
     * Sets the attributes of the text component
     *
     * @param textPane         The text component that will display the text typed in
     */
    private void prepareTextPane( JTextPane textPane ){
        if( textPane != null ){
            inputCommandBox_.setEditorKit(new CustomNoWrapKit());
            inputCommandBox_.addCaretListener(new CustomCaretListener(DEFAULT_NUMBER_OF_PIXELS_TO_SHOW_BEYOND_CARET));
            inputCommandBox_.setOpaque(false);
            inputCommandBox_.setFont( new Font( DEFAULT_TEXTPANE_STRING_FONT_FAMILY, Font.BOLD, DEFAULT_TEXTPANE_STRING_FONT_SIZE ) );
            inputCommandBox_.setForeground(DEFAULT_TEXTPANE_FONT_COLOR);
            originalTextStyle_ = getStyleOfTextPane(textPane);
            AbstractDocument abstractDocument = (AbstractDocument)inputCommandBox_.getDocument();
            commandPanelDocumentFilter_ = new CustomTextFieldDocumentFilter( commandKeywords_, nonCommandKeywords_, originalTextStyle_);
            abstractDocument.setDocumentFilter(commandPanelDocumentFilter_);
        }
    }
    
    /**
     * Sets text to be displayed within the text component. The keywords within the text will be syntax coloured if turnOffFilter
     * is false.
     *
     * @param textPane         The text component that will display the text typed in
     * @param turnOffFilter    The flag that determines if keywords within the text will be syntax coloured or not. If turnOffFilter
     *                         is false, keywords within the text will be syntax coloured. On the other hand, keywords within the text 
     *                         will not be syntax coloured if turnOffFilter is true.
     */
    public void setText( String text, boolean turnOffFilter ){
        if( text != null ){
            if( turnOffFilter ){
                commandPanelDocumentFilter_.setFilterOff();
            }
            inputCommandBox_.setText(text);
        }
    }
    
    /**
     * Sets the default colour of the text to be displayed within the text component.
     *
     * @param colour    The default colour of the text to be displayed within the text component.
     */
    public void setForegroundColor( Color colour ){
        if( colour != null ){
            inputCommandBox_.setForeground(colour);
            Style tempStyle = getStyleOfTextPane(inputCommandBox_);
            StyleConstants.setForeground(tempStyle, colour);
            commandPanelDocumentFilter_.setTextStyle(tempStyle);
            commandPanelDocumentFilter_.resetTextColor(inputCommandBox_.getStyledDocument());
        }
    }
    
    /**
     * Sets the font attributes of the text to be displayed within the text component.
     *
     * @param newFont    The font whose attributes will be set for the default font attributes of the text to be 
     *                   displayed within the text component.
     */
    public void setFontAttributes( Font newFont ){
        if( newFont != null ){
            inputCommandBox_.setFont(newFont);
            Style tempStyle = getStyleOfTextPane(inputCommandBox_);
            StyleConstants.setFontFamily(tempStyle, newFont.getFamily());
            StyleConstants.setFontSize(tempStyle, newFont.getSize());
            StyleConstants.setBold(tempStyle, newFont.isBold());
            StyleConstants.setItalic(tempStyle, newFont.isItalic());
            commandPanelDocumentFilter_.setTextStyle(tempStyle);
        }
    }
    
    /**
     * Returns the text component responsible for displaying text within the commandTextBox class
     *
     * @return  The text component responsible for displaying text within the commandTextBox class
     */
    public JTextPane getTextDisplay(){
        return inputCommandBox_;
    }
    
    /**
     * Returns the pop up box responsible for showing the example commands.
     *
     * @return  The pop up box responsible for showing the example commands
     */
    public JComboBox<String> getPopupBox(){
        return popUpBox_;
    }
    
    /**
     * Returns true if there is a currently selected item in the pop up box; false otherwise.
     *
     * @return  True if there is a currently selected item in the pop up box; false otherwise.
     */
    public boolean hasSelectedItem(){
        if( popUpList_ != null ){
            return (popUpList_.getSelectedItem() != null);
        } else {
            return false;
        }
    }
    
    /**
     * Returns the original style of the text displayed in the text component. 
     *
     * @param textPane The text component that will display the text typed in
     * @return  The original style of the text displayed in the text component. If there are no
     *          original text style found, it returns a default text style instead.
     */
    private Style getStyleOfTextPane( JTextPane textPane ){
        if( textPane != null ){
            Style tempStyle = textPane.getStyle(DEFAULT_TEXT_STYLE_NAME);
            if( tempStyle == null ){
                tempStyle = textPane.addStyle(DEFAULT_TEXT_STYLE_NAME, null);
                Font tempFont = textPane.getFont();
                StyleConstants.setFontFamily(tempStyle, tempFont.getFamily());
                StyleConstants.setFontSize(tempStyle, tempFont.getSize());
                StyleConstants.setBold(tempStyle, tempFont.isBold());
                StyleConstants.setItalic(tempStyle, tempFont.isItalic());
                StyleConstants.setForeground(tempStyle, textPane.getForeground());
            }
            return tempStyle;
        } else{
            return null;
        }
    }
}

	// End of segment: C:\Users\GamePro-Pc\Desktop\Work\Y2S2\CS2103\main\source\src\planner\CommandTextbox.java





	/**
	 * origin: C:\Users\GamePro-Pc\Desktop\Work\Y2S2\CS2103\main\source\src\planner\CustomCaretListener.java
	 */


package planner;

import java.awt.Rectangle;
import java.util.logging.Logger;

import javax.swing.SwingUtilities;
import javax.swing.event.CaretEvent;
import javax.swing.event.CaretListener;
import javax.swing.text.BadLocationException;
import javax.swing.text.JTextComponent;

/**
* The CustomCaretListener class controls many pixels to be shown beyond the caret
*
	// End of segment: C:\Users\GamePro-Pc\Desktop\Work\Y2S2\CS2103\main\source\src\planner\CustomCaretListener.java





	/**
	 * origin: C:\Users\GamePro-Pc\Desktop\Work\Y2S2\CS2103\main\source\src\planner\CustomCaretListener.java
	 */

*/
public class CustomCaretListener implements CaretListener{

    private int numOfPixelsToShow_;
    
    private final static Logger customCaretListenerLogger_ = Logger.getLogger(CustomCaretListener.class.getName());
    
    private final int MINIMUM_NUMBER_OF_PIXELS_TO_BE_SHOWN = 0;
    
    /**
     * Constructs a listener to handle many pixels to be shown beyond the caret. If negative integers
     * are passed in, it will automatically set itself to show zero pixels beyond the caret.
     *
     * @param numOfPixelsToShow    The number of pixels to be shown beyond the caret.
     */
    public CustomCaretListener( int numOfPixelsToShow ){
        customCaretListenerLogger_.setLevel(java.util.logging.Level.SEVERE);
        setNumOfPixelsToShow(numOfPixelsToShow);
    }
    
    /**
     * Sets the number of pixels to be shown beyond the caret. If negative integers
     * are passed in, it will automatically set itself to show zero pixels beyond the caret.
     *
     * @param numOfPixelsToShow    The number of pixels to be shown beyond the caret.
     */
    public void setNumOfPixelsToShow( int numOfPixelsToShow ){
        numOfPixelsToShow_ = Math.max(numOfPixelsToShow, MINIMUM_NUMBER_OF_PIXELS_TO_BE_SHOWN);
    }
    
    /**
     * Get the number of pixels to be shown beyond the caret.
     *
     * @return  The number of pixels currently set to be shown beyond the caret
     */
    public int getNumOfPixelsShown(){
        return numOfPixelsToShow_;
    }
    
    /**
     * Setup a listener to control the number of pixels to be shown beyond the caret
     *
     * @param caretEvent   The event fired by the caret that is being listened to
     */
    @Override
    public void caretUpdate( final CaretEvent caretEvent ){
        SwingUtilities.invokeLater(new Runnable(){
            @Override
            public void run(){
                try{
                    JTextComponent textComponent = (JTextComponent)caretEvent.getSource();
                    if( textComponent != null ){
                        int caretPosition = textComponent.getCaretPosition();
                        Rectangle visibleRect = textComponent.modelToView(caretPosition);
                        visibleRect.x = visibleRect.x + numOfPixelsToShow_;
                        textComponent.scrollRectToVisible(visibleRect);
                    }
                } catch( BadLocationException badLocationException ){
                    customCaretListenerLogger_.severe(badLocationException.getMessage());
                }
            }
        });
    }
}
	// End of segment: C:\Users\GamePro-Pc\Desktop\Work\Y2S2\CS2103\main\source\src\planner\CustomCaretListener.java





	/**
	 * origin: C:\Users\GamePro-Pc\Desktop\Work\Y2S2\CS2103\main\source\src\planner\CustomNoWrapKit.java
	 */


package planner;

import javax.swing.text.StyledEditorKit;
import javax.swing.text.ViewFactory;

/**
* The CustomNoWrapKit class is a style editor kit used by text components to prevent strings with widths exceeding the 
* width of the text component from being wrapped to the next line but enables the view of the text component to move
* along with the updated string
*
	// End of segment: C:\Users\GamePro-Pc\Desktop\Work\Y2S2\CS2103\main\source\src\planner\CustomNoWrapKit.java





	/**
	 * origin: C:\Users\GamePro-Pc\Desktop\Work\Y2S2\CS2103\main\source\src\planner\CustomNoWrapKit.java
	 */

*/
public class CustomNoWrapKit extends StyledEditorKit{

    private ViewFactory customViewFactory_;
    
    /**
    * Constructs a style editor kit using a custom view factory that handles the logic of scrolling of the text component's
    * view in response to increasing string length
    */
    public CustomNoWrapKit(){
        super();
        customViewFactory_ = new NoWrapTextLogic();
    }
    
    /**
     * Gets the view factory currently used by this editor kit
     * 
     * @return The view factory currently used by this editor kit to handle the logic of scrolling of the text component's
     *         view in response to increasing string length
     */
    @Override
    public ViewFactory getViewFactory(){
        return customViewFactory_;
    }
}

	// End of segment: C:\Users\GamePro-Pc\Desktop\Work\Y2S2\CS2103\main\source\src\planner\CustomNoWrapKit.java





	/**
	 * origin: C:\Users\GamePro-Pc\Desktop\Work\Y2S2\CS2103\main\source\src\planner\CustomScrollBarUI.java
	 */


package planner;

import java.awt.Color;
import java.awt.Graphics;
import java.awt.Graphics2D;
import java.awt.Rectangle;
import java.awt.RenderingHints;

import javax.swing.ImageIcon;
import javax.swing.JButton;
import javax.swing.JComponent;
import javax.swing.JScrollBar;
import javax.swing.plaf.basic.BasicScrollBarUI;

/**
* The CustomScrollBarUI class implements a custom scroll bar with customized thumb and buttons
*
	// End of segment: C:\Users\GamePro-Pc\Desktop\Work\Y2S2\CS2103\main\source\src\planner\CustomScrollBarUI.java





	/**
	 * origin: C:\Users\GamePro-Pc\Desktop\Work\Y2S2\CS2103\main\source\src\planner\CustomScrollBarUI.java
	 */

*/
public class CustomScrollBarUI extends BasicScrollBarUI{

    private final Color SCROLLBAR_THUMB_COLOR = new Color(0,0,0);
            
    private final int SCROLLBAR_THUMB_BORDER_SIZE = 3;
    private final int SCROLLBAR_THUMB_SIZE = 12;
    private final int SCROLLBAR_ALPHA_ROLLBACK_VALUE = 150;
    private final int SCROLLBAR_ALPHA_VALUE = 100;
    private final int SCROLLBAR_THUMB_BORDER_SCALE_FACTOR = 2;
    
    private InvisibleButton downButton_ = null;
    private InvisibleButton upButton_ = null;
    
    private final String UP_ARROW_IMAGE_RESOURCE_LINK = "/planner/arrowUp.png";
    private final String DOWN_ARROW_IMAGE_RESOURCE_LINK = "/planner/arrowDown.png";
    
    /**
    * The CustomScrollBarUI class constructs a custom scroll bar with customized thumb and buttons
    */
    public CustomScrollBarUI(){
        super();
        downButton_ = new InvisibleButton(); 
        prepareDownButton(downButton_);
        upButton_ = new InvisibleButton();
        prepareUpButton(upButton_);
    }
    
    /**
     * Initializes the down arrow button component of the scrollbar with its corresponding image resource
     * 
     * @param currentDownButton     The down arrow button component of the scrollbar to be initialized with its corresponding 
     *                              image resource
     */
    private void prepareDownButton( InvisibleButton currentDownButton ){
        if( currentDownButton != null ){
            currentDownButton.setIcon( new ImageIcon( UserInterface.class.getResource(DOWN_ARROW_IMAGE_RESOURCE_LINK) ) );
        }
    }
    
    /**
     * Initializes the up arrow button component of the scrollbar with its corresponding image resource
     * 
     * @param currentUpButton     The up arrow button component of the scrollbar to be initialized with its corresponding 
     *                            image resource
     */
    private void prepareUpButton( InvisibleButton currentUpButton ){
        if( currentUpButton != null ){
            currentUpButton.setIcon( new ImageIcon( UserInterface.class.getResource(UP_ARROW_IMAGE_RESOURCE_LINK) ) );
        }
    }
    
    /**
     * Returns the button that represent the decrease view 
     * 
     * @param orientation     The orientation of the scrollbar that will be using this button
     */
    @Override
    protected JButton createIncreaseButton( int orientation ){
        return downButton_;
    }
    
    /**
     * Returns the button that represent the increase view 
     * 
     * @param orientation     The orientation of the scrollbar that will be using this button
     */
    @Override
    protected JButton createDecreaseButton( int orientation ){
        return upButton_;
    }
    
    /**
     * Handles the rendering of the scrollbar track
     * 
     * @param graphics     An object that provides access to scrollbar track component rendering
     * @param component    The scrollbar component
     * @param thumbRect    The x coordinates, y coordinates, width and height of the scrollbar thumb
     */
    @Override
    protected void paintTrack( Graphics graphics, JComponent component, Rectangle thumbRect ){
    }
    
    /**
     * Handles the rendering of the scrollbar thumb
     * 
     * @param graphics     An object that provides access to scrollbar thumb component rendering
     * @param component    The scrollbar component
     * @param thumbRect    The x coordinates, y coordinates, width and height of the scrollbar thumb
     */
    @Override
    protected void paintThumb( Graphics graphics, JComponent component, Rectangle thumbRect ){
        int scrollbarOrientation = scrollbar.getOrientation();
        int xCoordinates = thumbRect.x + SCROLLBAR_THUMB_BORDER_SIZE;
        int yCoordinates = thumbRect.y + SCROLLBAR_THUMB_BORDER_SIZE;
        int width;
        int height;
        
        if( scrollbarOrientation == JScrollBar.HORIZONTAL ){
            width = thumbRect.width - (SCROLLBAR_THUMB_BORDER_SIZE*SCROLLBAR_THUMB_BORDER_SCALE_FACTOR);
        } else{
            width = SCROLLBAR_THUMB_SIZE;
        }
        width = Math.max(width, SCROLLBAR_THUMB_SIZE);
        
        if( scrollbarOrientation == JScrollBar.HORIZONTAL ){
            height = SCROLLBAR_THUMB_SIZE;
        } else{
            height = thumbRect.height - (SCROLLBAR_THUMB_BORDER_SIZE*SCROLLBAR_THUMB_BORDER_SCALE_FACTOR);
        }
        height = Math.max(height, SCROLLBAR_THUMB_SIZE);
        
        int alphaColourValue = (isThumbRollover() ? SCROLLBAR_ALPHA_ROLLBACK_VALUE : SCROLLBAR_ALPHA_VALUE);
        Graphics2D graphics2D = (Graphics2D) graphics.create();
        graphics2D.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);
        graphics2D.setColor( new Color(SCROLLBAR_THUMB_COLOR.getRed(), SCROLLBAR_THUMB_COLOR.getGreen(), SCROLLBAR_THUMB_COLOR.getBlue(), alphaColourValue) );
        graphics2D.fillRoundRect(xCoordinates, yCoordinates, width, height, SCROLLBAR_THUMB_SIZE, SCROLLBAR_THUMB_SIZE);
        graphics2D.dispose();
    }
    
    /**
     * Returns the custom down button component used for the custom scrollbar.
     * 
     * @return The down button component used for the custom scrollbar
     */
    public InvisibleButton getDownButtonComponent(){
        return downButton_;
    }
    
    /**
     * Returns the custom up button component used for the custom scrollbar.
     * 
     * @return The up button component used for the custom scrollbar
     */
    public InvisibleButton getUpButtonComponent(){
        return upButton_;
    }
}
    
    


	// End of segment: C:\Users\GamePro-Pc\Desktop\Work\Y2S2\CS2103\main\source\src\planner\CustomScrollBarUI.java





	/**
	 * origin: C:\Users\GamePro-Pc\Desktop\Work\Y2S2\CS2103\main\source\src\planner\CustomTextFieldDocumentFilter.java
	 */


package planner;

import java.awt.Color;
import java.util.logging.Logger;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.util.regex.PatternSyntaxException;

import javax.swing.SwingUtilities;
import javax.swing.text.AttributeSet;
import javax.swing.text.BadLocationException;
import javax.swing.text.DocumentFilter;
import javax.swing.text.Style;
import javax.swing.text.StyleConstants;
import javax.swing.text.StyledDocument;

/**
* The CustomTextFieldDocumentFilter class handles syntax colouring of keywords, filters new line characters and
* imposes a character limit for strings entered in text fields using this filter
*
	// End of segment: C:\Users\GamePro-Pc\Desktop\Work\Y2S2\CS2103\main\source\src\planner\CustomTextFieldDocumentFilter.java





	/**
	 * origin: C:\Users\GamePro-Pc\Desktop\Work\Y2S2\CS2103\main\source\src\planner\CustomTextFieldDocumentFilter.java
	 */

*/

public class CustomTextFieldDocumentFilter extends DocumentFilter{

    private String []commandKeywords_;
    private String []nonCommandKeywords_;
    private String commandKeywordRegexPattern_;
    private String nonCommandKeywordRegexPattern_;
    
    private boolean isFilterTurnedOff_;
    
    private Style originalFontStyle_;
    
    private final Color COLOUR_COMMAND_KEYWORD = new Color( 0, 0, 192 );
    private final Color COLOUR_NONCOMMAND_KEYWORD = new Color( 127, 0, 85 );
    
    private final int CHARACTER_LIMIT = 2000;
    
    private final static Logger customTextFieldDocumentFilterLogger_ = Logger.getLogger(CustomTextFieldDocumentFilter.class.getName());
    
    private final char NONCOMMAND_KEYWORD_NULLIFIER = '/';
    
    private final String NEW_LINE = "\n";
    private final String EMPTY_STRING = "";
    private final String REGEX_NEW_LINE = "\\n";
    private final String REGEX_WORD_BOUNDARY = "\\b";
    private final String REGEX_SEPARATOR = "|";
    private final String REGEX_GROUP_START = "(";
    private final String REGEX_GROUP_END = ")";
    
    private final int MINIMUM_STRING_OFFSET = 0;
    private final int EMPTY_STRING_LENGTH = 0;
    private final int MINIMUM_NON_EMPTY_STRING_LENGTH = 1;
    private final int CHARACTER_LENGTH_IN_STRING = 1;
    
    /**
     * Constructs a filter to filter out new line characters from the document and syntax colours keywords within the document
     *
     * @param commandkeywords    String array containing all command key words (words used to perform an operation).
     * @param nonCommandKeywords String array containing all non-command key words (words used to customize the behavior of an operation).
     * @param originalStyle      The original font style of the document without syntax colouring.
     */
    public CustomTextFieldDocumentFilter( String []commandKeywords, String []nonCommandKeywords, Style originalFontStyle ){
        super();

        customTextFieldDocumentFilterLogger_.setLevel(java.util.logging.Level.SEVERE);
        
        if( commandKeywords != null && nonCommandKeywords != null && originalFontStyle != null ){
            commandKeywords_ = commandKeywords;
            nonCommandKeywords_ = nonCommandKeywords;
            originalFontStyle_ = originalFontStyle;
            commandKeywordRegexPattern_ = generateRegex(commandKeywords_);
            nonCommandKeywordRegexPattern_ = generateRegex(nonCommandKeywords_);
        }
        setFilterOn();
    }
    
    /**
     * Constructs a filter to filter out new line characters from the document but prevents keywords from being syntax coloured 
     * within the document.
     */
    public CustomTextFieldDocumentFilter(){
        this( null, null, null );
        setFilterOff();
    }
    
    /**
     * Turns on syntax colouring filter.
     */
    public void setFilterOn(){
        if( commandKeywords_ != null ){
            isFilterTurnedOff_ = false;
        }
    }
    
    /**
     * Turns off syntax colouring filter.
     */
    public void setFilterOff(){
        isFilterTurnedOff_ = true;
    }
    
    /**
     * Records the original font style used in the document that is to be syntax coloured.
     *
     * @param currentTextStyle  The original font style of the document without syntax colouring.
     */
    public void setTextStyle( Style currentTextStyle ){
        if( currentTextStyle != null ){
            originalFontStyle_ = currentTextStyle;
        }
    }
    
    /**
     * Listens to string insertions in the document currently being filtered
     *
     * @param filterBypass       An object that allows access to the document without any call backs to the document.
     * @param offset             Offset in the document where the string was inserted.
     * @param str                The string that was inserted into the document.
     * @param attribute          The document attributes.
     */
    @Override
    public void insertString( DocumentFilter.FilterBypass filterBypass, int offset, String str, AttributeSet attribute ){
        try{
            StyledDocument doc = null;
            
            if( str != null && filterBypass != null ){
                if( str.contains(NEW_LINE) ){
                    str.replaceAll(REGEX_NEW_LINE, EMPTY_STRING);
                }
                
                doc = (StyledDocument)filterBypass.getDocument();
                
                if( doc.getLength() + str.length() >= CHARACTER_LIMIT ){
                    return; 
                }
            }

            super.insertString(filterBypass, offset, str, originalFontStyle_);
            
            if( doc != null && commandKeywords_ != null ){
                syntaxHighlightingListener( doc );
            }
        } catch( BadLocationException badLocationException ){
            customTextFieldDocumentFilterLogger_.severe(badLocationException.getMessage());
        }
    }
    
    /**
     * Listens to string replacements in the document currently being filtered.
     *
     * @param filterBypass       An object that allows access to the document without any call backs to the document.
     * @param offset             Offset in the document where replacement of string occurs.
     * @param str                The string replacement.
     * @param attribute          The document attributes.
     */
    @Override
    public void replace( DocumentFilter.FilterBypass filterBypass, int offset, int strLength, String str, AttributeSet attribute ){
        try{
            StyledDocument doc = null;
            
            if( str != null && filterBypass != null ){
                
                if( str.contains(NEW_LINE) ){
                    str.replaceAll(REGEX_NEW_LINE, EMPTY_STRING);
                }
                
                doc = (StyledDocument)filterBypass.getDocument();
                
                if( doc.getLength() + str.length() >= CHARACTER_LIMIT ){
                    return; 
                }
            }
            
            super.replace(filterBypass, offset, strLength, str, originalFontStyle_);
            
            if( doc != null && commandKeywords_ != null ){
                syntaxHighlightingListener( doc );
            }
        } catch( BadLocationException badLocationException ){
            customTextFieldDocumentFilterLogger_.severe(badLocationException.getMessage());
        }
    }
    
    /**
     * Listens to string removals in the document currently being filtered
     *
     * @param filterBypass   An object that allows access to the document without any call backs to the document.
     * @param offset         Offset in the document where removal of string occurs.
     * @param strLength      The length of the string removed.
     */
    @Override
    public void remove( DocumentFilter.FilterBypass filterBypass, int offset, int strLength ){
        
        try {
            StyledDocument doc = null;
            
            if( filterBypass != null ){
                doc = (StyledDocument)filterBypass.getDocument();
            }
            
            super.remove( filterBypass, offset, strLength );
            
            if( doc != null && commandKeywords_ != null ){
                syntaxHighlightingListener( doc );
            }
        } catch (BadLocationException badLocationException) {
            customTextFieldDocumentFilterLogger_.severe(badLocationException.getMessage());
        }
    }
    
    /**
     * Changes the color of string with given offset in the document and given length to the given color.
     *
     * @param doc          The document in which string color mutation is going to take place.
     * @param offset       Offset in the document where color mutation is going to take place.
     * @param strLength    The color that the string in the document is going to mutate to.
     */
    private void changeTextColor( StyledDocument doc, int offset, int stringLength, Color color ){
        
        if( doc != null && originalFontStyle_ != null && color != null && 
            offset >= MINIMUM_STRING_OFFSET && stringLength > EMPTY_STRING_LENGTH ){
            
            Color tempColor = StyleConstants.getForeground(originalFontStyle_);
            StyleConstants.setForeground(originalFontStyle_, color);
            doc.setCharacterAttributes(offset, stringLength, originalFontStyle_, true);
            StyleConstants.setForeground(originalFontStyle_, tempColor);
        }
    }
    
    /**
     * Resets the color of string with given offset in the document and given length to the document global font color.
     *
     * @param doc   The document in which string color mutation is going to take place.
     */
    public void resetTextColor( StyledDocument doc ){
        if( doc != null && originalFontStyle_ != null ){
            changeTextColor( doc, MINIMUM_STRING_OFFSET, doc.getLength(), StyleConstants.getForeground(originalFontStyle_) );
        }
    }
    
    /**
     * Parses the document for keywords to highlight provided that syntax coloring filter is turned on.
     *
     * @param doc   The document in which string color mutation is going to take place.
     */
    private void syntaxHighlightingListener( final StyledDocument doc ){
        
        if( doc != null && commandKeywords_ != null && nonCommandKeywords_ != null ){
            SwingUtilities.invokeLater(new Runnable(){
                @Override
                public void run() {
                    if( !isFilterTurnedOff_ ){
                        resetTextColor( doc );
                        Pattern commandPattern = Pattern.compile(commandKeywordRegexPattern_);
                        Pattern nonCommandPattern = Pattern.compile(nonCommandKeywordRegexPattern_);
                        try{
                            if( doc.getLength() > EMPTY_STRING_LENGTH ){
                                String text = doc.getText( MINIMUM_STRING_OFFSET, doc.getLength() ).toLowerCase();
                                Matcher commandStrMatcher = commandPattern.matcher(text);
                                Matcher nonCommandStrMatcher = nonCommandPattern.matcher(text);
                                
                                int startIdx;
                                int endIdx;
                                String stringInFrontOfMatchedWord;
                                while( commandStrMatcher.find() ){
                                    startIdx = commandStrMatcher.start();
                                    endIdx = commandStrMatcher.end();
                                    
                                    stringInFrontOfMatchedWord = text.substring(MINIMUM_STRING_OFFSET, startIdx).trim();
                                    
                                    if( stringInFrontOfMatchedWord.length() <= EMPTY_STRING_LENGTH ){
                                        changeTextColor( doc, startIdx, endIdx-startIdx, COLOUR_COMMAND_KEYWORD );
                                        break;
                                    }
                                }
                                
                                while( nonCommandStrMatcher.find() ){
                                    startIdx = nonCommandStrMatcher.start();
                                    endIdx = nonCommandStrMatcher.end();
                                    
                                    if( startIdx - CHARACTER_LENGTH_IN_STRING < MINIMUM_STRING_OFFSET || 
                                            text.charAt(startIdx - CHARACTER_LENGTH_IN_STRING) != NONCOMMAND_KEYWORD_NULLIFIER ){
                                        
                                        changeTextColor( doc, startIdx, endIdx-startIdx, COLOUR_NONCOMMAND_KEYWORD );
                                    }
                                }
                            }
                        } catch( BadLocationException badLocationException ){
                            customTextFieldDocumentFilterLogger_.severe(badLocationException.getMessage());
                        } catch( IllegalStateException illegalStateException ){
                            customTextFieldDocumentFilterLogger_.severe(illegalStateException.getMessage());
                        } catch(PatternSyntaxException patternSyntaxException){
                            customTextFieldDocumentFilterLogger_.severe(patternSyntaxException.getMessage());
                        } catch(IndexOutOfBoundsException indexOutOfBoundsException){
                            customTextFieldDocumentFilterLogger_.severe(indexOutOfBoundsException.getMessage());
                        }
                    }
                }
            });
        }
    }
    
    /**
     * Generates the regex pattern using the keywords provided.
     *
     * @param keywords   A string array containing keywords to be compiled into a regex pattern.
     * @return           A string representation of regex pattern complied from the keywords provided.
     */
    public String generateRegex( String []keywords ){
        
        try{
            StringBuilder regex = new StringBuilder(EMPTY_STRING);
            regex.append(REGEX_GROUP_START);
            if( keywords != null ){
                for( int i = 0, size = keywords.length; i < size; ++i ){
                    if( keywords[i] != null ){
                        regex.append(REGEX_WORD_BOUNDARY).append(keywords[i]).append(REGEX_WORD_BOUNDARY).append(REGEX_SEPARATOR);
                    }
                }
                if( regex.length() > MINIMUM_NON_EMPTY_STRING_LENGTH ){
                    regex.deleteCharAt(regex.length()-CHARACTER_LENGTH_IN_STRING);
                }
            }
            regex.append(REGEX_GROUP_END);
            return regex.toString();
        } catch( StringIndexOutOfBoundsException stringIndexOutOfBoundsException){
            customTextFieldDocumentFilterLogger_.severe(stringIndexOutOfBoundsException.getMessage());
        }
        return null;
    }
}

	// End of segment: C:\Users\GamePro-Pc\Desktop\Work\Y2S2\CS2103\main\source\src\planner\CustomTextFieldDocumentFilter.java





	/**
	 * origin: C:\Users\GamePro-Pc\Desktop\Work\Y2S2\CS2103\main\source\src\planner\CustomWrapKit.java
	 */


package planner;

import javax.swing.text.StyledEditorKit;
import javax.swing.text.ViewFactory;

/**
* The CustomWrapKit class is a style editor kit used by text components to allow for strings with widths exceeding the 
* width of the text component to wrap around to the next line
*
	// End of segment: C:\Users\GamePro-Pc\Desktop\Work\Y2S2\CS2103\main\source\src\planner\CustomWrapKit.java





	/**
	 * origin: C:\Users\GamePro-Pc\Desktop\Work\Y2S2\CS2103\main\source\src\planner\CustomWrapKit.java
	 */

*/
public class CustomWrapKit extends StyledEditorKit{

    private ViewFactory defaultViewFactory_;
    
    /**
     * Constructs a style editor kit using a custom view factory that handles wrap text logic
     */
    public CustomWrapKit(){
        super();
        defaultViewFactory_ = new WrapTextLogic();
    }
    
    /**
     * Retrieves the view factory currently used by this editor kit
     * 
     * @return The view factory currently used by this editor kit to handle wrap text logic
     */
    @Override
    public ViewFactory getViewFactory(){
        return defaultViewFactory_;
    }
}

	// End of segment: C:\Users\GamePro-Pc\Desktop\Work\Y2S2\CS2103\main\source\src\planner\CustomWrapKit.java





	/**
	 * origin: C:\Users\GamePro-Pc\Desktop\Work\Y2S2\CS2103\main\source\src\planner\DisplayPane.java
	 */


package planner;

import java.awt.Color;
import java.awt.Dimension;
import java.awt.Font;
import java.text.SimpleDateFormat;
import java.util.Arrays;
import java.util.Date;
import java.util.ListIterator;
import java.util.Map;
import java.util.Set;
import java.util.TreeMap;

import javax.swing.JComponent;
import javax.swing.JLabel;
import javax.swing.JScrollBar;
import javax.swing.JScrollPane;
import javax.swing.JTextPane;
import javax.swing.SwingConstants;
import javax.swing.text.BadLocationException;
import javax.swing.text.SimpleAttributeSet;
import javax.swing.text.Style;
import javax.swing.text.StyleConstants;
import javax.swing.text.StyledDocument;

/**
* The DisplayPane class manages the display of all of YOPO's task information and messages.
*
	// End of segment: C:\Users\GamePro-Pc\Desktop\Work\Y2S2\CS2103\main\source\src\planner\DisplayPane.java





	/**
	 * origin: C:\Users\GamePro-Pc\Desktop\Work\Y2S2\CS2103\main\source\src\planner\DisplayPane.java
	 */

*/
public class DisplayPane extends JScrollPane{

	private JTextPane display_;
	
	private TaskBar currentTaskBar_;
	
	private long currentTaskBarID_;
	
	private TreeMap<Long, TaskBar> listOfTasks_;
	private TreeMap<Long, DisplayTask> tasksList_;
	private TreeMap<Integer, Long> taskNumberList_;
	private TreeMap<Integer, Long> jumpList_;
	
	private CustomScrollBarUI scrollBarSkin_;
	
	private final long DEFAULT_INVALID_TASKBAR_ID = -1;
	private final long MINIMUM_VALID_TASKBAR_ID = 0;
	private final long MINIMUM_VALID_TASK_ID = 0;
	private final long MINIMUM_VALID_JUMP_ID = 0;
	private final long DEFAULT_INVALID_LINENUMBER = 0;
	private final long MINIMUM_LINENUMBER = 1;
	private final long SIZE_OF_ONE_LINE = 1;
	private final long SIZE_OF_ONE_TASK = 1;
	private final int DEFAULT_DISPLAY_FONT_SIZE = 2;
    private final int DEFAULT_FONT_SIZE_OF_MESSAGEPANE = 20;
    private final int DEFAULT_FONT_SPACE_SIZE_OF_MESSAGEPANE = 2;
    private final int DEFAULT_RELATIVE_XCOORDINATE_OF_MESSAGEPANE = 0;
    private final int DEFAULT_RELATIVE_YCOORDINATE_OF_MESSAGEPANE = 0;
    private final int DEFAULT_HEIGHT_OF_MESSAGEPANE = 100;
    private final int DEFAULT_HIGHLIGHTED_WORDS_FONT_SIZE = 14;
    private final int DEFAULT_HEADERLABEL_FONT_SIZE = 16;
    private final int MINIMUM_SIZE_OF_ARRAY_TO_SHOW_MESSAGES = 2;
    private final int MINIMUM_SIZE_OF_ARRAY_TO_HIGHTLIGHT_KEYWORDS = 3;
    private final int START_INDEX_OF_HIGHTLIGHT_KEYWORDS_IN_ARRAY = 2;
    private final int INDEX_OF_HEADER_IN_ARRAY = 0;
    private final int INDEX_OF_MESSAGE_IN_ARRAY = 1;
    private final int MINIMUM_ARRAY_INDEX = 0;
    private final int MINIMUM_DOCUMENT_INDEX = 0;
    private final int MINIMUM_STRING_LENGTH = 0;
    private final int DEFAULT_DATEHEADER_FONT_SIZE = 16;
    private final int MINIMUM_LIST_SIZE = 0;
    private final int MAXIMUM_PRIORITY = 5;
    private final int MINIMUM_PRIOIRTY = 1;
    private final int DEFAULT_DATEHEADER_WIDTH = 50;
    private final int DEFAULT_DATEHEADER_HEIGHT = 100;
    private final int MINIMUM_LIST_INDEX = 0;
    
	private final String DEFAULT_DISPLAY_FONT_FAMILY = "Arial";
	private final String EMPTY_STRING = ""; 
	private final String BORDER_SPACING = "               ";
	private final String NEW_LINE = "\n";
	private final String DEFAULT_FONT_FAMILY_OF_MESSAGEPANE = "Arial";
	private final String TOP_BORDER_SPACING = "\n\n";
	private final String BOTTOM_BORDER_SPACING = "\n\n\n";
	private final String BOTTOM_BORDER_SPACING_II = "\n\n\n\n\n\n";
	private final String DEFAULT_HIGHLIGHTED_WORDS_FONT_FAMILY = "Arial";
    private final String DEFAULT_HEADERLABEL_FONT_FAMILY = "Arial";
    private final String SPACING = " ";
    private final String DEFAULT_DATEHEADER_FONT_FAMILY = "Arial";
    private final String PRIORITY_STRING_LABEL = "Priority ";
    private final String NO_PRIORITY_STRING_LABEL = "No Priority";
    private final String NO_TASKS_MESSAGE = " You have no tasks in this section :)";
    private final String DEFAULT_DATEFORMAT = "EEE, d MMM yyyy";
    private final String TODAY_HEADER = "Today";
    private final String FLOATING_TASK_HEADER = "Floating Tasks";
    
	private final Color DEFAULT_COLOR_OF_MESSAGEPANE = new Color( 0, 0, 0, 100 );
    
	/**
    * Constructs a display component that manages the display of all of YOPO's task information and messages and sets up 
    * the scroll functionalities for this display component.
    */
	public DisplayPane(){
		
		listOfTasks_ = new TreeMap<Long, TaskBar>();
		tasksList_ = new TreeMap<Long, DisplayTask>();
		taskNumberList_ = new TreeMap<Integer, Long>();
		jumpList_ = new TreeMap<Integer, Long>();
		currentTaskBarID_ = DEFAULT_INVALID_TASKBAR_ID;
		
		// prepareDisplay() must be called first because it is added as viewport to scrollpane
		prepareDisplay();
		setViewportView(display_);
		setBorder(null);
		setOpaque(false);
		setHorizontalScrollBarPolicy(JScrollPane.HORIZONTAL_SCROLLBAR_NEVER);
		setVerticalScrollBarPolicy(JScrollPane.VERTICAL_SCROLLBAR_AS_NEEDED);
		getViewport().setOpaque(false);
		
		JScrollBar verticalScrollBar = getVerticalScrollBar();
		verticalScrollBar.setOpaque(false);
		scrollBarSkin_ = new CustomScrollBarUI();
		verticalScrollBar.setUI( scrollBarSkin_ );
	}
	
    /**
     * Return true if there are tasks being displayed currently; false otherwise
     * 
     * @return True if there are tasks being displayed currently; false otherwise
     */
	public boolean hasTasksDisplayed(){
	    return (listOfTasks_ != null && !listOfTasks_.isEmpty());
	}
	
	/**
     * Initializes and sets the attributes for the display component of this DisplayPane.
     */
	private void prepareDisplay(){
		display_ = new JTextPane();
		display_.setHighlighter(null);
		display_.setEditable(false);
		display_.setOpaque(false);
		display_.setBorder(null);
		display_.setFont( new Font( DEFAULT_DISPLAY_FONT_FAMILY, Font.PLAIN, DEFAULT_DISPLAY_FONT_SIZE ) );
	}
	
	/**
     * Clears all content currently being displayed on the display component of this DisplayPane.
     */
	public void clearDisplay(){
		display_.setText(EMPTY_STRING);
		currentTaskBar_ = null;
		currentTaskBarID_ = DEFAULT_INVALID_TASKBAR_ID;
		listOfTasks_.clear();
		tasksList_.clear();
		taskNumberList_.clear();
	}
	
	/**
     * Returns task id of the currently highlighted task in the display component of this DisplayPane.
     * 
     * @return The task id of the currently highlighted task in the display component of this DisplayPane.
     */
	public long getCurrentSelectedTaskID(){
	    return currentTaskBarID_;
	}

	/**
     * Returns task id of the currently highlighted task in the display component of this DisplayPane.
     * 
     * @return The task id of the currently highlighted task in the display component of this DisplayPane.
     */
	public boolean selectTask( long lineNumber ){
		if( lineNumber >= MINIMUM_LINENUMBER && lineNumber <= listOfTasks_.size() ){
			TaskBar tempTaskBar = listOfTasks_.get(lineNumber-SIZE_OF_ONE_LINE);
			if( tempTaskBar != null ){
				selectTask( tempTaskBar, lineNumber-SIZE_OF_ONE_LINE );             // Changed this function
				return true;
			}
		} 
		return false;
	}
	
	/**
     * Highlights the task at the given distance away from the currently highlighted task 
     * 
     * @return True if there is no currently highlighted task or the task at the given distance away from 
     *         the currently highlighted task does not exists; false otherwise.
     */
	public boolean selectTaskRelativeToCurrentSelectedTask( int distance ){
	    if( !listOfTasks_.isEmpty() ){
	        long newCurrentTaskBarID = currentTaskBarID_ + distance;
	        newCurrentTaskBarID = Math.max( listOfTasks_.firstKey(), newCurrentTaskBarID ); 
	        newCurrentTaskBarID = Math.min( listOfTasks_.lastKey(),  newCurrentTaskBarID );
	        
	        if( newCurrentTaskBarID == currentTaskBarID_ ){
	            return true;
	        }
	        TaskBar tempTaskBar = listOfTasks_.get( newCurrentTaskBarID );
	        if( tempTaskBar != null ){
	            selectTask( tempTaskBar, newCurrentTaskBarID );
                return true;
	        }
        } 
        return false;
	}
	
	/**
     * Highlights the previous task relative to the currently highlighted task 
     * 
     * @return True if there is no currently highlighted task or the previous task relative to the currently highlighted task 
     *              does not exists; false otherwise.
     */
	public boolean selectPreviousTask(){
		if( !listOfTasks_.isEmpty() && (currentTaskBarID_ - SIZE_OF_ONE_TASK < listOfTasks_.size()) ){
		    
		    long newCurrentTaskBarID;
		    if( currentTaskBarID_ - SIZE_OF_ONE_TASK <= DEFAULT_INVALID_TASKBAR_ID ){
		        newCurrentTaskBarID = listOfTasks_.size() - SIZE_OF_ONE_TASK;
		    } else{
		        newCurrentTaskBarID = currentTaskBarID_ - SIZE_OF_ONE_TASK;
		    }
			TaskBar tempTaskBar = listOfTasks_.get( newCurrentTaskBarID );
			if( tempTaskBar != null ){
				selectTask( tempTaskBar, newCurrentTaskBarID );
				return true;
			}
		}
		return false;         // cHANGED THIS FUNCTION
	}
	
	/**
     * Highlights the next task relative to the currently highlighted task 
     * 
     * @return True if there is no currently highlighted task or the next task relative to the currently highlighted task 
     *              does not exists; false otherwise.
     */
	public boolean selectNextTask(){
	    
		if( !listOfTasks_.isEmpty() && currentTaskBarID_ + SIZE_OF_ONE_TASK >= MINIMUM_VALID_TASKBAR_ID ){
			
		    long newCurrentTaskBarID;
		    if( currentTaskBarID_ + SIZE_OF_ONE_TASK >= listOfTasks_.size() ){
		        newCurrentTaskBarID = MINIMUM_VALID_TASKBAR_ID;
		    } else{
		        newCurrentTaskBarID = currentTaskBarID_ + SIZE_OF_ONE_TASK;
		    }
			TaskBar tempTaskBar = listOfTasks_.get( newCurrentTaskBarID );
			if( tempTaskBar != null ){
				selectTask( tempTaskBar, newCurrentTaskBarID );
				return true;
			}
		} 
		return false;         // cHANGED THIS FUNCTION
	}
	
	/**
     * Highlights the given taskBar, sets the currentTaskBarID as the given id and currentTaskBar as the given taskBar
     * only if both taskBar and id are valid; Otherwise nothing will take place. 
     * 
     * @param taskBar   The taskBar to be highlighted
     * @param id        The id of the taskBar to be highlighted
     */
	private void selectTask( TaskBar taskBar, long id ){
		if( taskBar != null && id >= MINIMUM_VALID_TASKBAR_ID && id < listOfTasks_.size()  ){
			deselectTask( currentTaskBar_ );
			taskBar.setFocusedTaskBar();
			display_.setCaretPosition(taskBar.getPosition());
			currentTaskBarID_ = id;
			currentTaskBar_ = taskBar;
		}
	}
	
	/**
     * Remove the highlights effect on the given taskBar, sets the currentTaskBarID as -1 and currentTaskBar as null if 
     * the given taskBar is valid; Otherwise nothing will take place.
     * 
     * @param taskBar   The taskBar to have its highlight effect removed
     */
	private void deselectTask( TaskBar taskBar ){
		if( taskBar != null ){
			currentTaskBarID_ = DEFAULT_INVALID_TASKBAR_ID;
			taskBar.setUnfocusedTaskBar();
			currentTaskBar_ = null;
		}
	}
	
	/**
     * Adds the given component to the display which is rendered by the display component of this DisplayPane
     * 
     * @param component   The component to add to the display which is rendered by the display component of this DisplayPane
     */
	private void addComponentToDisplay( JComponent component ){
		if( component != null ){
			try{
				StyledDocument styledDocument = (StyledDocument) display_.getDocument();
				Style style = styledDocument.addStyle("component", null);
				StyleConstants.setComponent(style, component);
				styledDocument.insertString( styledDocument.getLength(), "component", style );
			} catch( BadLocationException badLocationException ){}
		}
	}
	
	/**
     * Sets the display contents of the taskBar
     * 
     * @param currentDate   The date which this task is categorized under (This date object only contains
     *                      day of the month, the month and the year)
     * @param taskBar       The taskBar object in which the given task information will be displayed on
     * @param task          The Task object in which its information will be extracted out to fill the display 
     *                      contents of the taskBar
     * @param lineNumber    The id that will be displayed for the taskBar
     */
	private void setTaskBarParameters( Date currentDate, TaskBar taskBar, DisplayTask task, long lineNumber ){
	    Task parentTask;
		if( taskBar != null && task != null ){
		    parentTask = task.getParent();
		    if(parentTask != null){
    			if( lineNumber > DEFAULT_INVALID_LINENUMBER ){
    				taskBar.setLineNumber(lineNumber);
    			}
    			if( parentTask.isDone() ){
    				taskBar.setTaskDone();
    			}	
    			taskBar.setTaskTitle(parentTask);
    			taskBar.setTags(parentTask);
    			taskBar.setTimeDisplayLabel(currentDate, task);
		    }
		}
	}
	
	/**
     * Appends the given strings to the display component rendered using the given style
     * 
     * @param string    String to be appended to display component
     * @param style     The style in which the string will be rendered in
     */
	private void appendString( String string, Style style ){
		if( string != null ){
			try{
				StyledDocument doc = display_.getStyledDocument();
				doc.insertString(doc.getLength(), string, style );
			} catch( BadLocationException badLocationException ){}
		}
	}

	/**
     * Adds the given task to the display component in the form of a TaskBar object
     * 
     * @param currentDate    The date which this task is categorized under (This date object only contains
     *                       day of the month, the month and the year)
     * @param task           The Task object in which its information will be extracted out to fill the display 
     *                       contents of the taskBar
     */
	public boolean addTaskToDisplay( Date currentDate, DisplayTask task ){
		
		if( task == null || task.getParent() == null ){
			return false;
		}
		long taskBarID = listOfTasks_.size();
		TaskBar taskBar = new TaskBar();
		setTaskBarParameters( currentDate, taskBar, task, task.getParent().getID() );
		taskBar.setPosition( display_.getCaretPosition() );
		appendString(BORDER_SPACING, null);
		addComponentToDisplay( taskBar );
		listOfTasks_.put( taskBarID, taskBar );
		tasksList_.put(taskBarID, task);
		taskNumberList_.put(task.getParent().getID(), taskBarID);
		jumpList_.put(task.getID(), taskBarID);
		appendString(NEW_LINE, null);
		selectTask( taskBar, taskBarID );
		return true;
	}
	
	/**
     * Returns the DisplayTask Object representing the currently highlighted taskBar
     */
	public DisplayTask getCurrentSelectedTask(){
	    return tasksList_.get(currentTaskBarID_);
	}
	
	/**
     * Highlights the taskBar corresponding to its jump id specified in its corresponding DisplayTask Object.
     * 
     * @param jumpID    The jump id associated with the taskBar to be highlighted
     * @return TRUE if the taskBar corresponding to the given jump id exists; false otherwise.
     */
	public boolean selectGivenJumpID( int jumpID ){
	    if( jumpID >= MINIMUM_VALID_JUMP_ID ){
            Long internalID = jumpList_.get(jumpID);
            if( internalID != null ){     
                TaskBar tempTaskBar = listOfTasks_.get(internalID);  
                if(tempTaskBar != null){   
                    selectTask( tempTaskBar, internalID );
                    return true;  
                }
            }
	    }
        return false;
	}
	
	/**
     * Highlights the taskBar corresponding to its taskid specified in its corresponding Task Object.
     * 
     * @param taskID    The task id associated with the taskBar to be highlighted
     * @return TRUE if the taskBar corresponding to the given task id exists; false otherwise.
     */
	public boolean selectGivenTaskID( int taskID ){
	    if( taskID >= MINIMUM_VALID_TASK_ID ){
	        Long internalID = taskNumberList_.get(taskID);
	        if( internalID != null ){
                TaskBar tempTaskBar = listOfTasks_.get(internalID);
                if(tempTaskBar != null){
                    selectTask( tempTaskBar, internalID );
                    return true;
                } 
	        }
	    }
	    return false;
	}
	
	/**
     * Highlights the taskBar corresponding to the given Task object.
     * 
     * @param task    The Task object associated with the taskBar to be highlighted
     * @return TRUE if the taskBar corresponding to the given task exists; false otherwise.
     */
	public boolean selectGivenTask( Task task ){
	    if( task != null ){
	        Long internalID = taskNumberList_.get(task.getID());
	        if( internalID != null ){
	            TaskBar tempTaskBar = listOfTasks_.get(internalID);
	            if(tempTaskBar != null){
	                selectTask( tempTaskBar, internalID );
	                return true;
	            } 
	        }
	    }
	    return false;
	}
	
	/**
     * Adds tasks found within taskList to the display component in the form of a TaskBar object
     * 
     * @param currentDate    The current date that the tasks found within taskList are categorized under
     * @param taskList       The list containing the tasks that is going to be added to the display component in 
     *                       the form of a TaskBar object
     * 
     * @return TRUE if all tasks contained within taskList is added successfully to the display component in the 
     *         form of a TaskBar object; false otherwise.
     */
    private boolean addTasksToDisplay( Date currentDate, DisplayTaskList taskList ){
		if( !addTasksToDisplayWithoutSelection(currentDate, taskList) ){
		    return false;
		}
		if( !listOfTasks_.isEmpty() && currentTaskBarID_ != MINIMUM_VALID_TASKBAR_ID ){
			selectTask( listOfTasks_.get(MINIMUM_VALID_TASKBAR_ID), MINIMUM_VALID_TASKBAR_ID );
		}
		return true;
	}
	
    /**
     * Returns the number of tasks currently being displayed on the display component in the form of a TaskBar object
     * 
     * @return The number of tasks currently being displayed on the display component in the form of a TaskBar object
     */
	public int getNumberOfTasksDisplayed(){
	    return listOfTasks_.size();
	}
	
	/**
     * Displays the given message encapsulated in a translucent box onto the display component of this DisplayPane
     * 
     * @param msg   The message to be encapsulated in a translucent box and display onto the display component of this DisplayPane
     */
	public void showMessageOnDisplay( String msg ){
	    if( msg != null ){
	        clearDisplay();
	        TranslucentTextPane messagePane = new TranslucentTextPane( DEFAULT_COLOR_OF_MESSAGEPANE );
	        messagePane.setEditable(false);
	        messagePane.setHighlighter(null);
	        messagePane.setFocusable(false);
	        messagePane.setFont(new Font( DEFAULT_FONT_FAMILY_OF_MESSAGEPANE, Font.BOLD, DEFAULT_FONT_SIZE_OF_MESSAGEPANE ));
	        messagePane.setForeground(Color.WHITE);
	        messagePane.setBounds(DEFAULT_RELATIVE_XCOORDINATE_OF_MESSAGEPANE, 
	                              DEFAULT_RELATIVE_YCOORDINATE_OF_MESSAGEPANE, 
	                              display_.getWidth(), DEFAULT_HEIGHT_OF_MESSAGEPANE);
	        SimpleAttributeSet newLineStyle = new SimpleAttributeSet();
	        StyleConstants.setFontFamily(newLineStyle, DEFAULT_FONT_FAMILY_OF_MESSAGEPANE);
	        StyleConstants.setFontSize(newLineStyle, DEFAULT_FONT_SPACE_SIZE_OF_MESSAGEPANE);
	        StyleConstants.setBold(newLineStyle, false);
	        SimpleAttributeSet TextStyle = new SimpleAttributeSet();
	        StyleConstants.setFontFamily(TextStyle, DEFAULT_FONT_FAMILY_OF_MESSAGEPANE);
	        StyleConstants.setFontSize(TextStyle, DEFAULT_FONT_SIZE_OF_MESSAGEPANE);
	        StyleConstants.setBold(TextStyle, true);
	        messagePane.initialiseForResize();
	        messagePane.appendText(TOP_BORDER_SPACING, newLineStyle);
	        messagePane.appendText(msg, TextStyle);
	        messagePane.appendText(BOTTOM_BORDER_SPACING, newLineStyle);
	        messagePane.adjustComponentSizeToFitText();
	        addComponentToDisplay(messagePane);
	    }
	}
	
	/**
     * Displays messages contained within the 2D String array mappings onto the display component of this DisplayPane and encapsulates
     * each message in a translucent box
     * 
     * @param mappings   The String 2D array containing the messages to be displayed.
     * @param idx        If valid, it will only display messages contained within mappings[idx]; otherwise it will display all messages
     *                   contained within mappings.
     *                   
     * @return True if all messages within mappings are added to the display component of this DisplayPane successfully; false otherwise.
     */
	public boolean addInfoToDisplay( String [][]mappings, int idx ){
	    if( mappings != null ){
	        clearDisplay();
	        SimpleAttributeSet hightlightStyle = new SimpleAttributeSet();
	        StyleConstants.setFontFamily(hightlightStyle, DEFAULT_HIGHLIGHTED_WORDS_FONT_FAMILY);
	        StyleConstants.setFontSize(hightlightStyle, DEFAULT_HIGHLIGHTED_WORDS_FONT_SIZE);
	        StyleConstants.setBold(hightlightStyle, true);
	        StyleConstants.setItalic(hightlightStyle, true);
	        StyleConstants.setForeground(hightlightStyle, Color.GREEN);
	        if( idx >= MINIMUM_ARRAY_INDEX && idx < mappings.length 
	            && mappings[idx].length >= MINIMUM_SIZE_OF_ARRAY_TO_SHOW_MESSAGES ){
	            String []wordsToHighlight = null;
	            if( mappings[idx].length >= MINIMUM_SIZE_OF_ARRAY_TO_HIGHTLIGHT_KEYWORDS ){
	                wordsToHighlight = Arrays.copyOfRange(mappings[idx], 
	                                                      START_INDEX_OF_HIGHTLIGHT_KEYWORDS_IN_ARRAY, mappings[idx].length);
	            }
	            addInfoToDisplayWithoutSelection( mappings[idx][INDEX_OF_MESSAGE_IN_ARRAY], wordsToHighlight, hightlightStyle );
	        } else{
	            String []wordsToHighlight;
	            for( int i = MINIMUM_ARRAY_INDEX, size = mappings.length; i < size; ++i ){
	                if( mappings[i].length > MINIMUM_ARRAY_INDEX ){
	                    
    	                JLabel headerLabel = new JLabel();
    	                headerLabel.setHorizontalAlignment(SwingConstants.LEFT);
    	                headerLabel.setFont(new Font(DEFAULT_HEADERLABEL_FONT_FAMILY, Font.BOLD, DEFAULT_HEADERLABEL_FONT_SIZE));
    	                headerLabel.setForeground(Color.WHITE);
    	                headerLabel.setText(SPACING + mappings[i][INDEX_OF_HEADER_IN_ARRAY]);
    	                addComponentToDisplay(headerLabel);
    	                appendString(NEW_LINE, null);
    	                wordsToHighlight = null;
    	                if( mappings[i].length >= MINIMUM_SIZE_OF_ARRAY_TO_HIGHTLIGHT_KEYWORDS ){
    	                    
    	                    wordsToHighlight = Arrays.copyOfRange(mappings[i], 
    	                                                          START_INDEX_OF_HIGHTLIGHT_KEYWORDS_IN_ARRAY, 
    	                                                          mappings[i].length);
    	                }
    	                addInfoToDisplayWithoutSelection( mappings[i][INDEX_OF_MESSAGE_IN_ARRAY], wordsToHighlight, hightlightStyle );
    	                appendString( BOTTOM_BORDER_SPACING_II, null );
	                }
	            }
	        }
	        if( !listOfTasks_.isEmpty() && currentTaskBarID_ != MINIMUM_VALID_TASKBAR_ID ){
                selectTask( listOfTasks_.get(MINIMUM_VALID_TASKBAR_ID), MINIMUM_VALID_TASKBAR_ID );
            }
	        display_.setCaretPosition(MINIMUM_DOCUMENT_INDEX);
	        return true;
	    }   
	    return false;
	}
	
	/**
     * Displays the given info onto the display component of this DisplayPane and encapsulates the message in a translucent box
     * 
     * @param info              The string to be displayed 
     * @param wordsToHighlight  An array of keywords to be highlighted with the given string to be displayed
     * @param style             The style of the displayed string to be rendered in.   
     * 
     * @return True if the info is added to the display component of this DisplayPane successfully; false otherwise.
     */
	private boolean addInfoToDisplayWithoutSelection( String info, String []wordsToHighlight, SimpleAttributeSet style ){
	    if( info == null ){
	        return false;
	    }
	    SimpleAttributeSet newLineStyle = new SimpleAttributeSet();
        StyleConstants.setFontFamily(newLineStyle, DEFAULT_FONT_FAMILY_OF_MESSAGEPANE);
        StyleConstants.setFontSize(newLineStyle, DEFAULT_FONT_SPACE_SIZE_OF_MESSAGEPANE);
        StyleConstants.setBold(newLineStyle, false);
        SimpleAttributeSet TextStyle = new SimpleAttributeSet();
        StyleConstants.setFontFamily(TextStyle, DEFAULT_FONT_FAMILY_OF_MESSAGEPANE);
        StyleConstants.setFontSize(TextStyle, DEFAULT_HIGHLIGHTED_WORDS_FONT_SIZE);
        StyleConstants.setBold(TextStyle, true);
        
        TranslucentTextPane messagePane = new TranslucentTextPane( DEFAULT_COLOR_OF_MESSAGEPANE );
        messagePane.setEditable(false);
        messagePane.setHighlighter(null);
        messagePane.setFocusable(false);
        messagePane.setFont(new Font( DEFAULT_FONT_FAMILY_OF_MESSAGEPANE, Font.BOLD, DEFAULT_FONT_SIZE_OF_MESSAGEPANE ));
        messagePane.setForeground(Color.WHITE);
        messagePane.setBounds(DEFAULT_RELATIVE_XCOORDINATE_OF_MESSAGEPANE, DEFAULT_RELATIVE_YCOORDINATE_OF_MESSAGEPANE, 
                              display_.getWidth(), DEFAULT_HEIGHT_OF_MESSAGEPANE);
        messagePane.initialiseForResize();
        messagePane.appendText(TOP_BORDER_SPACING, newLineStyle);
        messagePane.appendText(info, TextStyle);
        messagePane.appendText(BOTTOM_BORDER_SPACING, newLineStyle);
        messagePane.adjustComponentSizeToFitText();
        
        addComponentToDisplay(messagePane);
        if( wordsToHighlight != null && wordsToHighlight.length > MINIMUM_STRING_LENGTH ){
            messagePane.highlightWords(wordsToHighlight, style);
        }
        return true;
	}
	
	/**
     * Displays the given task onto the display component of this DisplayPane in the form of a TaskBar object attached 
     * the give header label. NOTE: The first taskBar displayed on the display component of this DisplayPane will not be 
     * automatically highlighted.
     * 
     * @param currentDate       The date that task is categorized under.
     * @param task              The task whose information will be displayed on the display component of this DisplayPane in the form of a TaskBar object
     * @param header            The header label which will be attached to the top of the taskBar containing the contents of the given task
     * 
     * @return True if the given task is displayed successfully onto the display component of this DisplayPane; false otherwise.
     */
	private boolean addTaskWithHeaderToDisplayWithoutSelection( Date currentDate, DisplayTask task, JLabel header ){
	    if( task == null || task.getParent() == null ){
            return false;
        }
	    long taskBarID = listOfTasks_.size();
        TaskBar taskBar = new TaskBar(header);
        setTaskBarParameters( currentDate, taskBar, task, task.getParent().getID() );
        taskBar.setPosition( display_.getCaretPosition() );
        appendString(BORDER_SPACING, null);
        addComponentToDisplay( taskBar );
        listOfTasks_.put( taskBarID, taskBar );
        tasksList_.put(taskBarID, task);
        taskNumberList_.put(task.getParent().getID(), taskBarID);
        jumpList_.put(task.getID(), taskBarID);
        appendString(NEW_LINE, null);
        return true;
	}
	
	/**
     * Displays the tasks contained in the taskList onto the display component of this DisplayPane in the form of a TaskBar object with the first
     * task in a date catergory attached with a header label filled with the contents of currentDate
     * NOTE: The first taskBar displayed on the display component of this DisplayPane will not be automatically highlighted.
     * 
     * @param currentDate       The date that all tasks contained in taskList is categorized under.
     * @param taskList          The list containing the tasks that is going to be added to the display component in 
     *                          the form of a TaskBar object
     *                          
     * @return True if all tasks contained within taskList is displayed successfullyonto the display component of this DisplayPane; false otherwise.
     */
	private boolean addTasksToDisplayWithoutSelection( Date currentDate, DisplayTaskList taskList ){
	    if( taskList == null ){
            return false;
        }
        ListIterator<DisplayTask> iterator = taskList.listIterator();
        DisplayTask currentTask;
        display_.setCaretPosition(display_.getStyledDocument().getLength());
  
        long idxForCurrentTaskBar;
        TaskBar tempTaskBar;
        while( iterator.hasNext() ){
            currentTask = iterator.next();
            if( currentTask != null && currentTask.getParent() != null ){
                appendString(BORDER_SPACING, null);
                tempTaskBar = new TaskBar();
                setTaskBarParameters( currentDate, tempTaskBar, currentTask, currentTask.getParent().getID() );
                tempTaskBar.setPosition( display_.getCaretPosition() );
                addComponentToDisplay( tempTaskBar );
                idxForCurrentTaskBar = listOfTasks_.size();
                listOfTasks_.put( idxForCurrentTaskBar, tempTaskBar );
                tasksList_.put(idxForCurrentTaskBar, currentTask);
                taskNumberList_.put( currentTask.getParent().getID(), idxForCurrentTaskBar );
                jumpList_.put(currentTask.getID(), idxForCurrentTaskBar);
                appendString(NEW_LINE, null);
            }
        }
        return true;
	}
	
	/**
     * Returns the up button component that is used by the scrollbar attached to the display component of this
     * DisplayPanel
     * 
     * @return The up button component that is used by the scrollbar attached to the display component of this
     * DisplayPanel
     */
	public InvisibleButton getUpButtonComponent(){
        return (scrollBarSkin_ != null ? scrollBarSkin_.getUpButtonComponent() : null);
    }
    
	/**
     * Returns the down button component that is used by the scrollbar attached to the display component of this
     * DisplayPanel
     * 
     * @return The down button component that is used by the scrollbar attached to the display component of this
     * DisplayPanel
     */
    public InvisibleButton getDownButtonComponent(){
        return (scrollBarSkin_ != null ? scrollBarSkin_.getDownButtonComponent() : null);
    }
    
    /**
     * Returns the display component of this DisplayPanel
     * 
     * @return The display component of this DisplayPanel
     */
    public JTextPane getDisplayComponent(){
        return display_;
    }
    
    /**
     * Displays the tasks contained in the given displayList by priority from the highest(5) priority to the lowest(1) priority.
     * 
     * @param displayList       A list of DisplayTaskList sorted from the highest(5) priority to the lowest(1) priority.
     */
    public void displayByPriority( Set<Map.Entry<Integer, DisplayTaskList>> displayList ){
        if( displayList != null ){
            Integer priority;
            DisplayTaskList tempTaskList = null;
            JLabel dateHeaderLabel;
            DisplayTask tempDisplayTask;
            for( Map.Entry<Integer, DisplayTaskList> entry : displayList ){
                tempTaskList = entry.getValue();
                if( tempTaskList != null && tempTaskList.size() > MINIMUM_LIST_SIZE ){
                    priority = entry.getKey();
                    dateHeaderLabel = new JLabel();
                    dateHeaderLabel.setHorizontalAlignment(SwingConstants.LEFT);
                    dateHeaderLabel.setFont(new Font(DEFAULT_DATEHEADER_FONT_FAMILY, Font.BOLD, DEFAULT_DATEHEADER_FONT_SIZE));
                    dateHeaderLabel.setForeground(Color.WHITE);
                    if( priority != null && priority >= MINIMUM_PRIOIRTY && priority <= MAXIMUM_PRIORITY ){
                        dateHeaderLabel.setText( PRIORITY_STRING_LABEL + priority );
                    } else{
                        dateHeaderLabel.setText( NO_PRIORITY_STRING_LABEL );
                    }
                    dateHeaderLabel.setPreferredSize(new Dimension( DEFAULT_DATEHEADER_WIDTH, DEFAULT_DATEHEADER_HEIGHT ));
                    dateHeaderLabel.setMaximumSize(new Dimension( DEFAULT_DATEHEADER_WIDTH, DEFAULT_DATEHEADER_HEIGHT ));
                    dateHeaderLabel.setMinimumSize(new Dimension( DEFAULT_DATEHEADER_WIDTH, DEFAULT_DATEHEADER_HEIGHT ));
                    dateHeaderLabel.setSize(DEFAULT_DATEHEADER_WIDTH, DEFAULT_DATEHEADER_HEIGHT);
 
                    tempDisplayTask = tempTaskList.get(MINIMUM_LIST_INDEX );
                    addTaskWithHeaderToDisplayWithoutSelection( null, tempDisplayTask, dateHeaderLabel );
                    tempTaskList.set(MINIMUM_LIST_INDEX , null);
                    addTasksToDisplayWithoutSelection( null, tempTaskList );
                    tempTaskList.set(MINIMUM_LIST_INDEX , tempDisplayTask);
                }
                appendString( BOTTOM_BORDER_SPACING_II, null );
            }
            if( !listOfTasks_.isEmpty() && currentTaskBarID_ != MINIMUM_VALID_TASKBAR_ID ){
                selectTask( listOfTasks_.get(MINIMUM_VALID_TASKBAR_ID), MINIMUM_VALID_TASKBAR_ID );
            }
        }
        if( !hasTasksDisplayed() ){
            showMessageOnDisplay( NO_TASKS_MESSAGE );
        }
    }
    
    /**
     * Displays the tasks contained in the given displayList by date from earliest date in the displayList to the latest date in the displayList.
     * 
     * @param displayList   A list of DisplayTaskList sorted from the earliest date to the latest date
     */
    public void displayByDate( Set<Map.Entry<Date, DisplayTaskList>> displayList ){
        if( displayList != null ){
            Date tempDate;
            DisplayTaskList tempTaskList = null;
            Date todayDate = new Date(System.currentTimeMillis());
            JLabel dateHeaderLabel;
            DisplayTask tempDisplayTask;
            SimpleDateFormat dateFormatterForDisplay = new SimpleDateFormat( DEFAULT_DATEFORMAT );
            for( Map.Entry<Date, DisplayTaskList> entry : displayList ){
                tempTaskList = entry.getValue();
                if( tempTaskList != null && tempTaskList.size() > MINIMUM_LIST_SIZE ){
                    tempDate = entry.getKey();
                    dateHeaderLabel = new JLabel();
                    dateHeaderLabel.setHorizontalAlignment(SwingConstants.LEFT);
                    dateHeaderLabel.setFont(new Font(DEFAULT_DATEHEADER_FONT_FAMILY, Font.BOLD, DEFAULT_DATEHEADER_FONT_SIZE));
                    dateHeaderLabel.setForeground(Color.WHITE);
                    if( tempDate != null ){
                        if( !TaskBar.compareByDateOnly(tempDate, todayDate) ){
                            dateHeaderLabel.setText(dateFormatterForDisplay.format(tempDate));
                        } else{
                            dateHeaderLabel.setText(TODAY_HEADER);
                        }
                    } else{
                        dateHeaderLabel.setText( FLOATING_TASK_HEADER );
                    }
                    tempDisplayTask = tempTaskList.get(MINIMUM_LIST_INDEX);
                    addTaskWithHeaderToDisplayWithoutSelection( tempDate, tempDisplayTask, dateHeaderLabel );
                    tempTaskList.set(MINIMUM_LIST_INDEX, null);
                    addTasksToDisplayWithoutSelection( tempDate, tempTaskList );
                    tempTaskList.set(MINIMUM_LIST_INDEX, tempDisplayTask);
                }
                appendString( BOTTOM_BORDER_SPACING_II, null );
            }
            if( !listOfTasks_.isEmpty() && currentTaskBarID_ != MINIMUM_VALID_TASKBAR_ID ){
                selectTask( listOfTasks_.get(MINIMUM_VALID_TASKBAR_ID), MINIMUM_VALID_TASKBAR_ID );
            }
        }
        if( !hasTasksDisplayed() ){
            showMessageOnDisplay( NO_TASKS_MESSAGE );
        }
    }
}

	// End of segment: C:\Users\GamePro-Pc\Desktop\Work\Y2S2\CS2103\main\source\src\planner\DisplayPane.java





	/**
	 * origin: C:\Users\GamePro-Pc\Desktop\Work\Y2S2\CS2103\main\source\src\planner\DisplayState.java
	 */


package planner;

import java.awt.Component;
import java.awt.event.KeyEvent;

import planner.Constants.DisplayStateFlag;

/**
* The DisplayState class is a container that stores command or key event used to invoke the display state
*
	// End of segment: C:\Users\GamePro-Pc\Desktop\Work\Y2S2\CS2103\main\source\src\planner\DisplayState.java





	/**
	 * origin: C:\Users\GamePro-Pc\Desktop\Work\Y2S2\CS2103\main\source\src\planner\DisplayState.java
	 */

*/
public class DisplayState {

    private DisplayStateFlag displayStateFlag;
    
    private String title;
    private String inputCommand;
    
    private KeyEvent keyEvent;
    
    /**
     * Constructs a DisplayState that stores the command or key event used to invoke the display state, the displayStateFlag and 
     * title related to the displayState. If userCommand and event are both not null values at the same time, only userCommand will
     * be recorded for this displayState. Although both userCommand and event can be null at the same time, it is generally discouraged because
     * this displayState will be regarded as an invalid state.
     *
     * @param currentDisplayStateFlag  An ENUM flag that describes the displayState
     * @param title                    The title shown for this displayState
     * @param userCommand              The user input string used to invoke this displayState
     * @param event                    The key event used to invoke this displayState
     */
    public DisplayState( DisplayStateFlag currentDisplayStateFlag, String title, String userCommand, KeyEvent event ){
        
        displayStateFlag = currentDisplayStateFlag;
        if( title == null ){
            this.title = "";
        } else{
            this.title = title;
        }
        
        inputCommand = null;
        keyEvent = null;
        
        if( userCommand!= null && userCommand.length() > 0 ){
            inputCommand = userCommand;
        } else if( event != null ){
            keyEvent = new KeyEvent( (Component)event.getSource(), event.getID(), 
                                       event.getWhen(), event.getModifiersEx(), 
                                       event.getKeyCode(), event.getKeyChar(), event.getKeyLocation() );
        }
    }
    
    /**
     * Returns the ENUM flag associated with this displayState
     *
     * @return The ENUM flag associated with this displayState  
     */
    public DisplayStateFlag getdisplayStateFlag(){
        return displayStateFlag;
    }
    
    /**
     * Returns the title shown during this displayState
     *
     * @return The title shown during this displayState  
     */
    public String getTitle(){
        return title;
    }
    
    /**
     * Returns the user input string used to invoke this displayState
     *
     * @return The user input string used to invoke this displayState
     */
    public String getCommand(){
        return inputCommand;
    }
    
    /**
     * Returns the key event used to invoke this displayState
     *
     * @return The key event used to invoke this displayState
     */
    public KeyEvent getKeyEvent(){
        return keyEvent;
    }
    
    /**
     * Returns true if the title of the given anotherDisplayState equals to the title of this displayState, false otherwise.
     *
     * @param anotherDisplayState   The displayState in which its title field is to be compared with this displayState's title field
     * @return True if the title of the given anotherDisplayState equals to the title of this displayState, false otherwise.
     */
    public boolean compareTitle( DisplayState anotherDisplayState ){
        if( anotherDisplayState != null ){
            boolean isTitleEqual;
            if( anotherDisplayState.getTitle() != null && title != null ){
                isTitleEqual = title.equals(anotherDisplayState.getTitle());
            } else if( anotherDisplayState.getTitle() != null || title != null ){
                isTitleEqual = false;
            } else{
                isTitleEqual = true;
            }
            return isTitleEqual;
        }
        return false;
    }
    
    /**
     * Returns true if the user input string used to invoke the given anotherDisplayState equals to the user input string used to 
     * invoke this displayState, false otherwise.
     *
     * @param anotherDisplayState   The displayState in which its user input string used is to be compared with this displayState's user input string
     * @return True if the user input string used to invoke the given anotherDisplayState equals to the user input string used to 
     *         invoke this displayState, false otherwise.
     */
    public boolean compareCommandString( DisplayState anotherDisplayState ){
        if( anotherDisplayState != null ){
            boolean isCommandEqual;
            if( anotherDisplayState.getCommand() != null && inputCommand != null ){
                isCommandEqual = inputCommand.equals(anotherDisplayState.getCommand());
            } else if( anotherDisplayState.getCommand() != null || inputCommand != null ){
                isCommandEqual = false;
            } else{
                isCommandEqual = true;
            }
            return isCommandEqual;
        }
        return false;
    }
    
    /**
     * Returns true if the key event used to invoke the given anotherDisplayState equals to the keyevent used to 
     * invoke this displayState, false otherwise.
     *
     * @param anotherDisplayState   The displayState in which its key event is to be compared with this displayState's key event
     * @return True if the key event used to invoke the given anotherDisplayState equals to the keyevent used to 
     *         invoke this displayState, false otherwise.
     */
    public boolean compareKeyEvent( DisplayState anotherDisplayState ){
        if( anotherDisplayState != null ){
            boolean isKeyEventEqual;
            if( anotherDisplayState.getKeyEvent() != null && keyEvent != null ){
                isKeyEventEqual = keyEvent.equals(anotherDisplayState.getKeyEvent());
            } else if( anotherDisplayState.getKeyEvent() != null || keyEvent != null ){
                isKeyEventEqual = false;
            } else{
                isKeyEventEqual = true;
            }
            return isKeyEventEqual;
        }
        return false;
    }
    
    /**
     * Compares this DisplayState to the specified object. The result is true if and only if the argument is not null and 
     * is a DisplayState object that has the same values for its displayStateFlag_, title_, inputStringCommand_ and keyEvent_ member
     * field
     *
     * @param obj   An object to be compared with this DisplayState
     * @return True if the object compared is an instance of DisplayState and has the same values; false otherwise.
     */
    @Override
    public boolean equals( Object obj ){
        if( obj instanceof DisplayState ){
            DisplayState displayState = (DisplayState)obj;
            boolean isTitleEqual = compareTitle(displayState);
            boolean isCommandStringEqual = compareCommandString(displayState);
            boolean isKeyEventEqual = compareKeyEvent(displayState);
          
            return ((displayState.getdisplayStateFlag() == displayStateFlag) &&
                    isTitleEqual && isCommandStringEqual && isKeyEventEqual);
        } else{
            return false;
        }
    }
}

	// End of segment: C:\Users\GamePro-Pc\Desktop\Work\Y2S2\CS2103\main\source\src\planner\DisplayState.java





	/**
	 * origin: C:\Users\GamePro-Pc\Desktop\Work\Y2S2\CS2103\main\source\src\planner\DisplayStateStack.java
	 */


package planner;

import java.util.LinkedList;

/**
* The DisplayStateStack class is a customised stack works like a normal stack but ignores invalid DisplayStates and limits the 
* number of DisplayStates that exist within the stack by removing some of the oldest DisplayStates that exist on the stack
*
	// End of segment: C:\Users\GamePro-Pc\Desktop\Work\Y2S2\CS2103\main\source\src\planner\DisplayStateStack.java





	/**
	 * origin: C:\Users\GamePro-Pc\Desktop\Work\Y2S2\CS2103\main\source\src\planner\DisplayStateStack.java
	 */

*/
public class DisplayStateStack {

    private int maxNumOfDisplayStates_;
    private LinkedList<DisplayState> stack_;
    
    /**
    * Constructs a DisplayState stack used for storing DisplayStates in chronological order. If maxNumOfDisplayStates is passed
    * as an integer less than 1, the DisplayStateStack automatically sets the maximum number of DisplayStates that can be stored
    * within this stack to be 1
    *
    * @param maxNumOfDisplayStates  The maximum number of DisplayStates that can be stored within this stack
    */
    public DisplayStateStack( int maxNumOfDisplayStates ){
        maxNumOfDisplayStates_ = Math.max( 1, maxNumOfDisplayStates );
        stack_ = new LinkedList<DisplayState>();
    }
    
    /**
     * Pushes the provided displayState onto the stack. This method will not add any invalid displayStates and null displayStates.
     * This method will also limit the number of DisplayStates that exist within the stack by removing some of the oldest DisplayStates 
     * that exist on the stack
     *
     * @param displayState  The displayState to be pushed onto the stack
     * @return              The displayState provided
     */
    public DisplayState push( DisplayState displayState ){
        if( displayState != null && (displayState.getKeyEvent() != null || displayState.getCommand() != null) ){
            while( stack_.size() >= maxNumOfDisplayStates_ ){
                stack_.removeLast();
            }
            if( stack_.size() + 1 <= maxNumOfDisplayStates_ ){
                stack_.push(displayState);
            }
        }
        return displayState;
    }
    
    /**
     * Removes and returns the most recent displayState pushed onto the stack.
     *
     * @return   The most recent displayState pushed onto the stack.
     */
    public DisplayState pop(){
        if( !stack_.isEmpty() ){
            return stack_.pop();
        } else{
            return null;
        }
    }
    
    /**
     * Returns true if the stack currently contains no displayStates, false otherwise
     *
     * @return   True if the stack currently contains no displayStates, false otherwise
     */
    public boolean isEmpty(){
        return stack_.isEmpty();
    }
    
    /**
     * Returns the most recent displayState pushed onto the stack.
     *
     * @return   The most recent displayState pushed onto the stack.
     */
    public DisplayState peek(){
        return stack_.peek();
    }
    
    /**
     * Returns the number of displayStates currently present within the stack.
     *
     * @return   The number of displayStates currently present within the stack.
     */
    public int size(){
        return stack_.size();
    }
}

	// End of segment: C:\Users\GamePro-Pc\Desktop\Work\Y2S2\CS2103\main\source\src\planner\DisplayStateStack.java





	/**
	 * origin: C:\Users\GamePro-Pc\Desktop\Work\Y2S2\CS2103\main\source\src\planner\FadedTextField.java
	 */


package planner;
import java.awt.Color;
import java.awt.FontMetrics;
import java.awt.GradientPaint;
import java.awt.Graphics;
import java.awt.Graphics2D;
import java.awt.Insets;
import java.awt.Point;
import java.awt.RenderingHints;
import java.util.logging.Logger;

import javax.swing.JTextField;

/**
* The FadedTextField class is a text field component that truncates very long strings and applies a faded effect to a few characters towards the
* end of such strings. If the text fits within the width of the FadedTextField, the string will be displayed normally.
*
	// End of segment: C:\Users\GamePro-Pc\Desktop\Work\Y2S2\CS2103\main\source\src\planner\FadedTextField.java





	/**
	 * origin: C:\Users\GamePro-Pc\Desktop\Work\Y2S2\CS2103\main\source\src\planner\FadedTextField.java
	 */

*/
public class FadedTextField extends JTextField{

	private Color fromColor_;
	private Color toColor_;
	private Color backgroundColor_;
	
	private Insets componentCoordinates_;
	
	private int maxCharacters_;
	private int numCharactersBeforeFade_;
	
	private final Color DEFAULT_TO_COLOUR = new Color( 192,192,192 );
	
	private final int MIN_NUM_OF_CHARACTERS = 0;
	private final int MAX_NUM_OF_CHARACTERS = 1000;
	private final int MAX_NUM_OF_NONFADED_CHARACTERS = 999;
	private final int DEFAULT_MAX_NUM_OF_CHARACTERS = 15;
	private final int DEFAULT_MAX_NUM_OF_NONFADED_CHARACTERS = 9;
	private final int MINIMUM_STRING_LENGTH = 0;
	private final int LENGTH_OF_ONE_CHARACTER = 1;
	private final int MINIMUM_START_INDEX_OF_STRING = 0;
	private final int NUM_OF_CHARACTERS_TO_APPEND_TO_TRUNCATED_STRING = 3;
	private final int MINIMUM_Y_COORDINATE = 0;
	private final int MINIMUM_TEXT_WIDTH_USED_FOR_RENDER = 30;
	private final int NUM_OF_SUB_INTERVALS = 2;
	
	private final static Logger fadedTextFieldLogger_ = Logger.getLogger(FadedTextField.class.getName());
	
	private final String CHARACTERS_TO_APPEND_TO_TRUNCATED_STRING = "...";
	private final String STRING_ONE_USED_FOR_TEXT_RENDERING_CALCULATION = "ZZZZ";
	private final String STRING_TWO_USED_FOR_TEXT_RENDERING_CALCULATION = "ZZZ";
	
	/**
     * Constructs a text field component that truncates very long strings and applies a fade out effect to a few characters towards the
     * end of such strings. If the text fits within the width of the FadedTextField, the string will be displayed normally.
     *
     * @param fromColor             The colour for the portion of the text that will be shown
     * @param toColor               The colour that the text will faded into in the event that the text string exceed the width of the 
     *                              text field component
     * @param backgroundColor       The colour of the background that the text is rendered on
     * @param maxCharacters         The maximum number of characters that can be typed into this text field component
     * @param numCharactersBefore   The number of characters to be rendered in fromColor before applying the faded out effect on the remaining
     *                              characters
     */
	public FadedTextField( Color fromColor, Color toColor, Color backgroundColor, int maxCharacters, int numCharactersBefore ){
		
	    fadedTextFieldLogger_.setLevel(java.util.logging.Level.SEVERE);
	    
		fromColor_ = fromColor != null ? fromColor : Color.BLACK;
		toColor_ = toColor != null ? toColor : DEFAULT_TO_COLOUR;
		backgroundColor_ = backgroundColor != null ? backgroundColor : Color.BLACK;
		
		if( maxCharacters <= MIN_NUM_OF_CHARACTERS || maxCharacters > MAX_NUM_OF_CHARACTERS ){
		    maxCharacters_ = DEFAULT_MAX_NUM_OF_CHARACTERS;
		} else{
		    maxCharacters_ = maxCharacters;
		}
		
		if( numCharactersBefore <= MIN_NUM_OF_CHARACTERS || numCharactersBefore > MAX_NUM_OF_NONFADED_CHARACTERS ){
		    numCharactersBeforeFade_ = DEFAULT_MAX_NUM_OF_NONFADED_CHARACTERS;
		} else{
		    numCharactersBeforeFade_ = numCharactersBefore;
		}
		componentCoordinates_ = getInsets();
		setBorder(null);
		setHighlighter(null);
		setEditable(false);
		setOpaque( false );
	}
	
	/**
     * Calculates the maximum string length required to fit within the width of the text field component
     *
     * @param str           The string being queried for its maximum string length required to fit within the width of 
     *                      this text field component
     * @param fontMetrics   The font attributes currently being used by the text displayed within this text field component
     * @return The maximum string length required to fit within the width of the text field component given the string and font attributes
     */
	private int locateSuitableMaxStringLength( String str, FontMetrics fontMetrics ){
	    
	    if( str == null || fontMetrics == null ){
	        return MINIMUM_STRING_LENGTH;
	    }
	    
	    String currString = str;
	    int currStringWidth = fontMetrics.stringWidth(currString);
	    int fieldWidth = getWidth();
	    
	    if( currStringWidth <= fieldWidth ){
	        return maxCharacters_;
	    }
	    
	    int startIdx = MINIMUM_START_INDEX_OF_STRING;
	    int endIdx = str.length()-LENGTH_OF_ONE_CHARACTER;
	    int midIdx;
	    fieldWidth -= fontMetrics.stringWidth(CHARACTERS_TO_APPEND_TO_TRUNCATED_STRING);
	    while( startIdx <= endIdx ){
	        
	        midIdx = (startIdx + endIdx)/NUM_OF_SUB_INTERVALS;
	        currString = str.substring(MINIMUM_START_INDEX_OF_STRING, midIdx+LENGTH_OF_ONE_CHARACTER);
	        currStringWidth = fontMetrics.stringWidth(currString);
	        
	        if( currStringWidth == fieldWidth ){
	            return currString.length();
	        } else if( currStringWidth < fieldWidth ){
	            startIdx = midIdx + LENGTH_OF_ONE_CHARACTER;
	        } else{
	            endIdx = midIdx - LENGTH_OF_ONE_CHARACTER;
	        }
	    }
	    return endIdx + LENGTH_OF_ONE_CHARACTER;
	}
	
	/**
     * Renders the appearance of the text field component and text within it;
     *
     * @param graphics  Component that provide access to rendering information and the rendering of the text field component
     */
	@Override
	public void paintComponent( Graphics graphics ) {
		
		setForeground( backgroundColor_ );
		super.paintComponent(graphics);
		getInsets( componentCoordinates_ );
		String inputString = getText();
		int stringLength = inputString.length();
		try{
		    FontMetrics fontMetrics = graphics.getFontMetrics();
		    int tempMaxCharacters = Math.min( maxCharacters_, locateSuitableMaxStringLength( inputString, fontMetrics ) );
		    int tempNumCharactersBeforeFade = Math.max( MINIMUM_STRING_LENGTH, numCharactersBeforeFade_-(maxCharacters_-tempMaxCharacters) );
			int offsetForText = viewToModel( new Point( componentCoordinates_.left, componentCoordinates_.top ) );
			inputString = inputString.substring(offsetForText, Math.min(stringLength, tempMaxCharacters));
			
			if( stringLength > tempMaxCharacters ){
				
				inputString += CHARACTERS_TO_APPEND_TO_TRUNCATED_STRING;
				stringLength = inputString.length();
				tempMaxCharacters += NUM_OF_CHARACTERS_TO_APPEND_TO_TRUNCATED_STRING;
			}
			int textWidth = fontMetrics.stringWidth(STRING_ONE_USED_FOR_TEXT_RENDERING_CALCULATION) - 
			                fontMetrics.stringWidth(STRING_TWO_USED_FOR_TEXT_RENDERING_CALCULATION) + MINIMUM_TEXT_WIDTH_USED_FOR_RENDER ;
			int offsetToPaint = componentCoordinates_.left;
			int heightOfText = fontMetrics.getAscent() + componentCoordinates_.top;
			
			GradientPaint paintForText = new GradientPaint( offsetToPaint, MINIMUM_Y_COORDINATE, 
			                                                toColor_, offsetToPaint + textWidth, MINIMUM_Y_COORDINATE, fromColor_, true );
			Graphics2D textGraphics = (Graphics2D) graphics;
			String nStr = inputString.substring( offsetToPaint, Math.min( stringLength, tempNumCharactersBeforeFade ) );
			textGraphics.setPaint( fromColor_ );
			textGraphics.setRenderingHint(RenderingHints.KEY_TEXT_ANTIALIASING, RenderingHints.VALUE_TEXT_ANTIALIAS_ON);
			textGraphics.drawString( nStr, offsetToPaint, heightOfText );
			
			if( stringLength > tempNumCharactersBeforeFade ){
				String sStr = inputString.substring( offsetForText + tempNumCharactersBeforeFade, Math.min(tempMaxCharacters, stringLength) );
				textGraphics.setPaint(paintForText);
				textGraphics.drawString( sStr, offsetToPaint+fontMetrics.stringWidth(nStr), heightOfText );
			}
			textGraphics.dispose();
		} catch( StringIndexOutOfBoundsException stringIndexOutOfBoundsException ){
		    fadedTextFieldLogger_.severe(stringIndexOutOfBoundsException.getMessage());
		}
	}
}
	// End of segment: C:\Users\GamePro-Pc\Desktop\Work\Y2S2\CS2103\main\source\src\planner\FadedTextField.java





	/**
	 * origin: C:\Users\GamePro-Pc\Desktop\Work\Y2S2\CS2103\main\source\src\planner\InputList.java
	 */

*/
public class InputList {

    private LinkedList<String> commandList_;
    private ListIterator<String> currentStringInput_;
    
    private int maxCommandListSize_;
    
    private String recentlyTypedCommand_;
    private String recentCommandReturned_;
    
    private boolean hasReturnedRecentlyTypedString_;
    private boolean isNextIteratorCalled_;
    private boolean isPrevIteratorCalled_;
    
    private final int MINIMUM_LIST_SIZE = 1;
    private final int SIZE_OF_ONE_COMMAND_INPUT_STRING = 1;
    /**
     * Constructs a command input list that will handle the storage of previous commands and the logic of cycling through
     * previous commands. If maxListSize is < 1, the maximum number of previous commands strings that this list will store
     * will automatically be set to 1.
     *
     * @param maxListSize   The maximum number of previous commands strings that this list will store.
     */
    public InputList( int maxListSize ){
        
        commandList_ = new LinkedList<String>();
        currentStringInput_ = null;
        maxCommandListSize_ = Math.max( MINIMUM_LIST_SIZE, maxListSize ); 
        hasReturnedRecentlyTypedString_ = false;
        isNextIteratorCalled_ = false;
        isPrevIteratorCalled_ = false;
    }
    
    /**
     * Adds a command string to the list. Null strings passed in will be ignored.
     *
     * @param input   The command input string to be added to the list.
     */
    public String addWordToList( String input ){
        
        if( input != null ){
            if( input.equals(recentCommandReturned_) ){
                return input;
            }
            while( commandList_.size() >= maxCommandListSize_ ){
                commandList_.removeLast();
            }
            if( commandList_.size() + SIZE_OF_ONE_COMMAND_INPUT_STRING <= maxCommandListSize_ ){
                commandList_.addFirst(input);
            }
        }
        return input;
    }
    
    /**
     * Resets the position of the list pointer used to decide which command string is to be returned 
     * at the next getNextInputString() or getPrevInputString() call.
     */
    public void resetGetWordPosition(){
        recentlyTypedCommand_ = null;
        currentStringInput_ = commandList_.listIterator();
        hasReturnedRecentlyTypedString_ = false;
        isNextIteratorCalled_ = false;
        isPrevIteratorCalled_ = false;
        if( !commandList_.isEmpty() ){
            recentCommandReturned_ = commandList_.getFirst();
        } else{
            recentCommandReturned_ = null;
        }
    }
    
    /**
     * Returns the next command input string stored in the list. If there no more next command input strings to be returned,
     * the current user typed command string will be returned instead.
     *
     * @return The next command input string stored in the list.
     */
    public String getNextInputString(){
        if( currentStringInput_ != null && currentStringInput_.hasPrevious() ){
            if( isNextIteratorCalled_ ){
                isNextIteratorCalled_ = false;
                currentStringInput_.previous();
            }
            if( currentStringInput_.hasPrevious() ){
                isPrevIteratorCalled_ = true;
                recentCommandReturned_ = currentStringInput_.previous();
                return recentCommandReturned_;
            }
        } 
        isPrevIteratorCalled_ = false;
        if( !hasReturnedRecentlyTypedString_ ){  
            hasReturnedRecentlyTypedString_ = true;
            return recentCommandReturned_ = recentlyTypedCommand_;
        } else{
            return null;
        }
    }
    
    /**
     * Records the current user typed command string that is not yet processed by YOPO. 
     *
     * @param The current user typed command string that is not yet processed by YOPO.
     */
    public void setRecentlyTypedString( String input ){
        if( input != null && !input.equals(recentCommandReturned_) ){
            recentlyTypedCommand_ = input;
        }
    }
    
    /**
     * Returns the previous command input string stored in the list. If there no more previous command input strings 
     * to be returned, a null string will be returned
     *
     * @return The previous command input string stored in the list.
     */
    public String getPrevInputString(){
        if( currentStringInput_ != null && currentStringInput_.hasNext() ){
            hasReturnedRecentlyTypedString_ = false;
            if( isPrevIteratorCalled_ ){
                isPrevIteratorCalled_ = false;
                currentStringInput_.next();
            }
            String tempString = null;
            if( currentStringInput_.hasNext() ){
                recentCommandReturned_ = currentStringInput_.next();
                tempString = recentCommandReturned_;
                isNextIteratorCalled_ = true;
            }
            return tempString;
        } else{
            return null;
        }
    }
}

	// End of segment: C:\Users\GamePro-Pc\Desktop\Work\Y2S2\CS2103\main\source\src\planner\InputList.java





	/**
	 * origin: C:\Users\GamePro-Pc\Desktop\Work\Y2S2\CS2103\main\source\src\planner\InvisibleButton.java
	 */


package planner;

import java.awt.Color;
import java.awt.Dimension;

import javax.swing.BorderFactory;
import javax.swing.JButton;

/**
* The InvisibleButton class is a customised button component that is invisible.
*
	// End of segment: C:\Users\GamePro-Pc\Desktop\Work\Y2S2\CS2103\main\source\src\planner\InvisibleButton.java





	/**
	 * origin: C:\Users\GamePro-Pc\Desktop\Work\Y2S2\CS2103\main\source\src\planner\InvisibleButton.java
	 */

*/
public class InvisibleButton extends JButton{

    private final Color ZERO_ALPHA_BLACK_COLOR = new Color(0,0,0,0);
    
    private final int DEFAULT_WIDTH = 10;
    private final int DEFAULT_HEIGHT = 15;
    
    /**
     * Constructs a button component that is invisible.
     */
    public InvisibleButton(){
        
        setBorderPainted(false);
        setBorder(BorderFactory.createEmptyBorder());
        setFocusable(true);
        setFocusPainted(false);
        setContentAreaFilled(false);
        setOpaque(false);
        setBackground(ZERO_ALPHA_BLACK_COLOR);
    }
    
    /**
     * Returns the preferred size of this button component.
     *
     * @return   The preferred size of this button component.
     */
    @Override
    public Dimension getPreferredSize(){
        return new Dimension(DEFAULT_WIDTH,DEFAULT_HEIGHT);
    }
}

	// End of segment: C:\Users\GamePro-Pc\Desktop\Work\Y2S2\CS2103\main\source\src\planner\InvisibleButton.java





	/**
	 * origin: C:\Users\GamePro-Pc\Desktop\Work\Y2S2\CS2103\main\source\src\planner\InvisibleScrollBarUI.java
	 */


package planner;

import java.awt.Graphics;
import java.awt.Rectangle;

import javax.swing.JButton;
import javax.swing.JComponent;
import javax.swing.plaf.basic.BasicScrollBarUI;

/**
* The InvisibleScrollBarUI class is a customised scroll bar that is invisible
*
	// End of segment: C:\Users\GamePro-Pc\Desktop\Work\Y2S2\CS2103\main\source\src\planner\InvisibleScrollBarUI.java





	/**
	 * origin: C:\Users\GamePro-Pc\Desktop\Work\Y2S2\CS2103\main\source\src\planner\InvisibleScrollBarUI.java
	 */

*/
public class InvisibleScrollBarUI extends BasicScrollBarUI{

    private InvisibleButton downButton_ = null;
    private InvisibleButton upButton_ = null;
    
    /**
     * Constructs a scroll bar that is invisible
     */
    public InvisibleScrollBarUI(){
        super();
        downButton_ = new InvisibleButton(); 
        prepareButton(downButton_);
        upButton_ = new InvisibleButton();
        prepareButton(upButton_);
    }
    
    /**
     * Set attributes of the buttons of the scroll bar so that it will not be focusable
     * 
     * @param currentButton The button of the scroll bar that is going to be set to be unfocusable
     */
    private void prepareButton( InvisibleButton currentButton ){
        if( currentButton != null ){
            currentButton.setFocusable(false);
        }
    }
    
    /**
     * Returns the button that represent the decrease view 
     * 
     * @param orientation     The orientation of the scrollbar that will be using this button
     */
    @Override
    protected JButton createIncreaseButton( int orientation ){
        return downButton_;
    }
    
    /**
     * Returns the button that represent the increase view 
     * 
     * @param orientation     The orientation of the scrollbar that will be using this button
     */
    @Override
    protected JButton createDecreaseButton( int orientation ){
        return upButton_;
    }
    
    /**
     * Handles the rendering of the scrollbar track
     * 
     * @param graphics     An object that provides access to scrollbar track component rendering
     * @param component    The scrollbar component
     * @param thumbRect    The x coordinates, y coordinates, width and height of the scrollbar thumb
     */
    @Override
    protected void paintTrack( Graphics graphics, JComponent component, Rectangle thumbRect ){
    }
    
    /**
     * Handles the rendering of the scrollbar thumb
     * 
     * @param graphics     An object that provides access to scrollbar thumb component rendering
     * @param component    The scrollbar component
     * @param thumbRect    The x coordinates, y coordinates, width and height of the scrollbar thumb
     */
    @Override
    protected void paintThumb( Graphics graphics, JComponent component, Rectangle thumbRect ){
    }
    
    /**
     * Returns the custom down button component used for the invisible scrollbar.
     * 
     * @return The down button component used for the invisible scrollbar
     */
    public InvisibleButton getDownButtonComponent(){
        return downButton_;
    }
    
    /**
     * Returns the custom up button component used for the invisible scrollbar.
     * 
     * @return The up button component used for the invisible scrollbar.
     */
    public InvisibleButton getUpButtonComponent(){
        return upButton_;
    }
}

	// End of segment: C:\Users\GamePro-Pc\Desktop\Work\Y2S2\CS2103\main\source\src\planner\InvisibleScrollBarUI.java





	/**
	 * origin: C:\Users\GamePro-Pc\Desktop\Work\Y2S2\CS2103\main\source\src\planner\NavigationBar.java
	 */


package planner;

import java.awt.Color;
import java.awt.Dimension;

import javax.swing.ImageIcon;
import javax.swing.JComponent;
import javax.swing.JLabel;
import javax.swing.JTextPane;
import javax.swing.text.BadLocationException;
import javax.swing.text.SimpleAttributeSet;
import javax.swing.text.Style;
import javax.swing.text.StyleConstants;
import javax.swing.text.StyledDocument;

/**
* The NavigationBar class is a component that stores and displays navigation information for YOPO
*
	// End of segment: C:\Users\GamePro-Pc\Desktop\Work\Y2S2\CS2103\main\source\src\planner\NavigationBar.java





	/**
	 * origin: C:\Users\GamePro-Pc\Desktop\Work\Y2S2\CS2103\main\source\src\planner\NavigationBar.java
	 */

*/
public class NavigationBar extends JComponent{

    private JLabel background_;
    
    private JTextPane infoPanel_;
    
    private Style boldText_;
    private Style smallerText_;
    
    private boolean isVisible_;
    
    private final int DEFAULT_WIDTH = 253;
    private final int DEFAULT_HEIGHT = 47;
    private final int MINIMUM_STRING_LENGTH = 0;
    private final int MINIMUM_STRING_INDEX = 0;
    private final int FONT_SIZE_FOR_BOLDTEXTSTYLE = 13;
    private final int FONT_SIZE_FOR_SMALLTEXTSTYLE = 12;
    private final int MINIMUM_RELATIVE_XCOORDINATE = 0;
    private final int MIMIMUM_RELATIVE_YCOORDINATE = 0;
    private final int DEFAULT_RELATIVE_XCOORDINATE_OF_INFOPANEL = 10;
    private final int DEFAULT_RELATIVE_YCOORDINATE_OF_INFOPANEL = 7;
    private final int DEFAULT_WIDTH_OF_INFOPANEL = 180;
    private final int DEFAULT_HEIGHT_OF_INFOPANEL = 38;
    
    private final String NAME_FOR_BOLDTEXTSTYLE = "BigBoldText";
    private final String FONT_FAMILY_FOR_BOLDTEXTSTYLE = "Arial";
    private final String NAME_FOR_SMALLTEXTSTYLE = "SmallerText";
    private final String FONT_FAMILY_FOR_SMALLTEXTSTYLE = "Calibri";
    private final String EMPTY_STRING = "";
    private final String DEFAULT_NAVIGATION_MESSAGE = "<Insert navigation screen type here>";
    private final String DEFAULT_NAVIGATION_STATUS = "\nCurrently viewing";
    private final String DEFAULT_NAVIGATION_KEY = "<Insert key here>";
    private final String NAVIGATION_KEY_MSG_I = "\nPress ";
    private final String NAVIGATION_KEY_MSG_II = " to view";
    private final String NAVIGATION_BAR_IMAGE_RESOURCE_LINK = "/planner/NavigationBar.png";
    
    private final float DEFAULT_LINE_SPACING = -0.2f;
    
    /**
     * Constructs a NavigationBar component that displays its default navigation messages
     */
    public NavigationBar(){
        this( null, null );
    }
    
    /**
     * Constructs a NavigationBar component that displays the provided navigation information in message and
     * navigation key involved for this navigation
     * 
     * @param message       The navigation information to be displayed
     * @param navigationKey The navigation key involved for this navigation
     */
    public NavigationBar( String message, String navigationKey ){
        prepareInfoPanel();
        prepareBackground();
        intialiseTextStyles();
        setMessageToView( message, navigationKey );
    }
    
    /**
     * Constructs a NavigationBar component that displays the provided navigation information in message and
     * will be set to display a "currently viewing message"
     * 
     * @param message       The navigation information to be displayed
     */
    public NavigationBar( String message ){
        prepareInfoPanel();
        prepareBackground();
        intialiseTextStyles();
        setMessageToCurrentView(message);
    }
    
    /**
     * Returns the preferred width and height of the component
     * 
     * @return A dimension container that stores the preferred width and height of the component
     */
    @Override
    public Dimension getPreferredSize(){
        return new Dimension( DEFAULT_WIDTH, DEFAULT_HEIGHT );
    }
    
    /**
     * Initializes the text styles required by the text shown within the text component in the NavigationBar component
     */
    private void intialiseTextStyles(){
        boldText_ = infoPanel_.addStyle( NAME_FOR_BOLDTEXTSTYLE, null );
        StyleConstants.setBold(boldText_, true);
        StyleConstants.setFontSize(boldText_, FONT_SIZE_FOR_BOLDTEXTSTYLE);
        StyleConstants.setFontFamily(boldText_, FONT_FAMILY_FOR_BOLDTEXTSTYLE);
        StyleConstants.setForeground(boldText_, Color.WHITE);
        smallerText_ = infoPanel_.addStyle( NAME_FOR_SMALLTEXTSTYLE, null );
        StyleConstants.setBold(smallerText_, true);
        StyleConstants.setItalic(smallerText_, true);
        StyleConstants.setFontSize(smallerText_, FONT_SIZE_FOR_SMALLTEXTSTYLE);
        StyleConstants.setFontFamily(smallerText_, FONT_FAMILY_FOR_SMALLTEXTSTYLE);
        StyleConstants.setForeground(smallerText_, Color.WHITE);
    }
 
    /**
     * Initializes and sets attributes for the text component that will display the messages
     */
    private void prepareInfoPanel(){
        infoPanel_ = new JTextPane();
        infoPanel_.setBounds(DEFAULT_RELATIVE_XCOORDINATE_OF_INFOPANEL, 
                            DEFAULT_RELATIVE_YCOORDINATE_OF_INFOPANEL, 
                            DEFAULT_WIDTH_OF_INFOPANEL, 
                            DEFAULT_HEIGHT_OF_INFOPANEL);
        infoPanel_.setOpaque(false);
        infoPanel_.setFocusable(false);
        infoPanel_.setEditable(false);
        infoPanel_.setHighlighter(null);
        infoPanel_.setBorder(null);
        add(infoPanel_);
    }
    
    /**
     * Sets the navigation information to be displayed in the text component within the NavigationBar component
     * 
     * @param message   The navigation information to be displayed in the text component within the NavigationBar component
     */
    public void setMessageToCurrentView( String message ){
        
        StyledDocument doc = infoPanel_.getStyledDocument();
        try{
            isVisible_ = true;
            infoPanel_.setText(EMPTY_STRING);
            
            if(message == null || message.length() <= MINIMUM_STRING_LENGTH ){
                message = DEFAULT_NAVIGATION_MESSAGE;
                isVisible_ = false;
            }
            
            doc.insertString(doc.getLength(), message, boldText_);
            doc.insertString(doc.getLength(), DEFAULT_NAVIGATION_STATUS, smallerText_ );
            
            SimpleAttributeSet centerStyle = new SimpleAttributeSet();
            StyleConstants.setAlignment(centerStyle, StyleConstants.ALIGN_LEFT);
            StyleConstants.setLineSpacing(centerStyle, DEFAULT_LINE_SPACING);
            doc.setParagraphAttributes(MINIMUM_STRING_INDEX, doc.getLength(), centerStyle, true);
        } catch( BadLocationException badLocationException ){}
    }
    
    /**
     * Sets the provided navigation information in message and navigation key involved for this navigation
     * 
     * @param message       The navigation information to be displayed
     * @param navigationKey The navigation key involved for this navigation
     */
    public void setMessageToView( String message, String navigationKey ){
        
        StyledDocument doc = infoPanel_.getStyledDocument();
        try{
            isVisible_ = true;
            infoPanel_.setText(EMPTY_STRING);
            
            if(message == null || message.length() <= MINIMUM_STRING_LENGTH ){
                message = DEFAULT_NAVIGATION_MESSAGE;
                isVisible_ = false;
            }
            doc.insertString(doc.getLength(), message, boldText_);
            if( navigationKey == null || navigationKey.length() <= MINIMUM_STRING_LENGTH ){
                
                navigationKey = DEFAULT_NAVIGATION_KEY;
                
                isVisible_ = false;
            }
            doc.insertString(doc.getLength(), NAVIGATION_KEY_MSG_I + navigationKey + NAVIGATION_KEY_MSG_II, smallerText_ );
            SimpleAttributeSet centerStyle = new SimpleAttributeSet();
            StyleConstants.setAlignment(centerStyle, StyleConstants.ALIGN_LEFT);
            StyleConstants.setLineSpacing(centerStyle, DEFAULT_LINE_SPACING);
            doc.setParagraphAttributes(MINIMUM_STRING_INDEX, doc.getLength(), centerStyle, true);
        } catch( BadLocationException badLocationException ){}
    }
    
    /**
     * Initializes and sets attributes for background component of this NavigationBar component
     */
    private void prepareBackground(){
        background_ = new JLabel();
        background_.setIcon(new ImageIcon(NavigationBar.class.getResource(NAVIGATION_BAR_IMAGE_RESOURCE_LINK)));
        background_.setBounds(MINIMUM_RELATIVE_XCOORDINATE, MIMIMUM_RELATIVE_YCOORDINATE, DEFAULT_WIDTH, DEFAULT_HEIGHT);
        add(background_);
    }
    
    /**
     * Returns true if navigation bar is shown; false otherwise
     * 
     * @return True if navigation bar is shown; false otherwise
     */
    public boolean isVisible(){
        return isVisible_;
    }
}

	// End of segment: C:\Users\GamePro-Pc\Desktop\Work\Y2S2\CS2103\main\source\src\planner\NavigationBar.java





	/**
	 * origin: C:\Users\GamePro-Pc\Desktop\Work\Y2S2\CS2103\main\source\src\planner\NonWrappingParagraphLayout.java
	 */


package planner;

import javax.swing.text.Element;
import javax.swing.text.ParagraphView;

/**
* The NonWrappingParagraphLayout class handles the layout of the editor kit used for non wrapping text
*
	// End of segment: C:\Users\GamePro-Pc\Desktop\Work\Y2S2\CS2103\main\source\src\planner\NonWrappingParagraphLayout.java





	/**
	 * origin: C:\Users\GamePro-Pc\Desktop\Work\Y2S2\CS2103\main\source\src\planner\NonWrappingParagraphLayout.java
	 */

*/
public class NonWrappingParagraphLayout extends ParagraphView{

    /**
     * Constructs the layout for the editor kit used for non wrapping text
     */
    public NonWrappingParagraphLayout( Element element ){
        super(element);
    }
    
    /**
     * Sets the width and height of the layout for the editor kit used for non wrapping text
     * 
     * @param width     The width of the layout to be set
     * @param height    The height of the layout to be set
     */
    @Override
    public void layout( int width, int height ){
        super.layout( Integer.MAX_VALUE, height );
    }
    
    /**
     * Returns the minimum span of the layout
     * 
     * @param axis     The orientation of the layout
     * @return         The minimum span of the layout
     */
    @Override
    public float getMinimumSpan( int axis ){
        return super.getPreferredSpan(axis);
    }
}

	// End of segment: C:\Users\GamePro-Pc\Desktop\Work\Y2S2\CS2103\main\source\src\planner\NonWrappingParagraphLayout.java





	/**
	 * origin: C:\Users\GamePro-Pc\Desktop\Work\Y2S2\CS2103\main\source\src\planner\NoWrapTextLogic.java
	 */


package planner;

import javax.swing.text.AbstractDocument;
import javax.swing.text.BoxView;
import javax.swing.text.Element;
import javax.swing.text.LabelView;
import javax.swing.text.View;
import javax.swing.text.ViewFactory;

/**
* The NoWrapTextLogic class handles the logic of non wrapping text for the editor kit implementing non wrapping text behavior
*
	// End of segment: C:\Users\GamePro-Pc\Desktop\Work\Y2S2\CS2103\main\source\src\planner\NoWrapTextLogic.java





	/**
	 * origin: C:\Users\GamePro-Pc\Desktop\Work\Y2S2\CS2103\main\source\src\planner\NoWrapTextLogic.java
	 */

*/
public class NoWrapTextLogic implements ViewFactory{

    /**
     * Returns the view required for the document containing the text to be displayed
     * 
     * @param element     An object representing the document containing the text to be displayed
     * @return            The view required for the document containing the text to be displayed
     */
    @Override
    public View create( Element element ){
        
        if( element == null ){
            return null;
        }
        
        String property = element.getName();
        if( property != null ){
            if( property.equals( AbstractDocument.ParagraphElementName ) ){
                return new NonWrappingParagraphLayout(element);
            } else if( property.equals( AbstractDocument.SectionElementName ) ){
                return new BoxView(element, View.Y_AXIS );
            }
        }
        return new LabelView(element);
    }
}

	// End of segment: C:\Users\GamePro-Pc\Desktop\Work\Y2S2\CS2103\main\source\src\planner\NoWrapTextLogic.java





	/**
	 * origin: C:\Users\GamePro-Pc\Desktop\Work\Y2S2\CS2103\main\source\src\planner\SliderPanel.java
	 */


package planner;

import java.awt.Color;
import java.awt.Dimension;
import java.awt.Point;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.awt.event.AdjustmentEvent;
import java.awt.event.AdjustmentListener;

import javax.swing.ImageIcon;
import javax.swing.JComponent;
import javax.swing.JLabel;
import javax.swing.JScrollBar;
import javax.swing.JScrollPane;
import javax.swing.JTextPane;
import javax.swing.Timer;
import javax.swing.text.BadLocationException;
import javax.swing.text.SimpleAttributeSet;
import javax.swing.text.Style;
import javax.swing.text.StyleConstants;
import javax.swing.text.StyledDocument;

import planner.Constants.TipType;

/**
* The SliderPanel class is a component that will display additional task information. This display panel can slide
* in or out of view.
*
	// End of segment: C:\Users\GamePro-Pc\Desktop\Work\Y2S2\CS2103\main\source\src\planner\SliderPanel.java





	/**
	 * origin: C:\Users\GamePro-Pc\Desktop\Work\Y2S2\CS2103\main\source\src\planner\SliderPanel.java
	 */

*/
public class SliderPanel extends JComponent{
    
    private JLabel background_;
    private JLabel downArrow_;
    private JLabel upArrow_;
    private JLabel tips_;
    
    private JTextPane infoPanel_;
    
    private JScrollPane infoPanelScrollPane_;
    
    private InvisibleScrollBarUI scrollBarSkin_;
    
    private JScrollBar verticalScrollBar_;
    
    private int initialXCoordinate_ = 0;
    private int initialYCoordinate_ = 0;
    private int parentWidth_;
    private int widthNotToMoveInto_;
    private Integer firstXCoordinate_ = null;
    
    private int currentXCoordinate_;
    
    private boolean isCurrentlyVisible_ = true;
    
    private Timer timerSlideOut_;
    private Timer timerSlideIn_;
    
    private static final long NANOSECOND_PER_MILLISECOND = 1000000;
    private final long DEFAULT_INITIAL_START_TIME = -1;
    
    private final int MILLISECOND_TO_WAIT_BEFORE_NEXT_ANIMATION_FRAME = 2;
    private final int XCOORDINATE_INCREMENT_FOR_ANIMATION = 1;
    private final int MINIMUM_DISTANCE_MULTIPLIER = 0;
    private final int DEFAULT_SLIDERPANEL_WIDTH = 198;
    private final int DEFAULT_SLIDERPANEL_HEIGHT = 520;
    private final int DEFAULT_DISTANCE_MULTIPLIER = 1;
    private final int DEFAULT_UP_ARROW_RELATIVE_XCOORDINATE = 94;
    private final int DEFAULT_UP_ARROW_RELATIVE_YCOORDINATE = 66;
    private final int DEFAULT_UP_ARROW_WIDTH = 20;
    private final int DEFAULT_UP_ARROW_HEIGHT = 8;
    private final int DEFAULT_DOWN_ARROW_RELATIVE_XCOORDINATE = 94;
    private final int DEFAULT_DOWN_ARROW_RELATIVE_YCOORDINATE = 430;
    private final int DEFAULT_DOWN_ARROW_WIDTH = 20;
    private final int DEFAULT_DOWN_ARROW_HEIGHT = 8;
    private final int DEFAULT_TIPLABEL_RELATIVE_XCOORDINATE = 10;
    private final int DEFAULT_TIPLABEL_RELATIVE_YCOORDINATE = 452;
    private final int DEFAULT_TIPLABEL_WIDTH = 184;
    private final int DEFAULT_TIPLABEL_HEIGHT = 67;
    private final int MINIMUM_DOCUMENT_INDEX = 0;
    private final int DEFAULT_INVALID_CARET_POSITION = -1;
    private final int DEFAULT_BACKGROUND_RELATIVE_XCOORDINATE = 0;
    private final int DEFAULT_BACKGROUND_RELATIVE_YCOORDINATE = 0;
    private final int DEFAULT_INFOPANEL_RELATIVE_XCOORDINATE = 10;
    private final int DEFAULT_INFOPANEL_RELATIVE_YCOORDINATE = 78;
    private final int DEFAULT_INFOPANEL_WIDTH = 182;
    private final int DEFAULT_INFOPANEL_HEIGHT = 347;
    private final int DEFAULT_INTITIAL_XCOORDINATE_FOR_SLIDERPANEL = 0;
    private final int DEFAULT_INTITIAL_YCOORDINATE_FOR_SLIDERPANEL = 0;
    private final int DEFAULT_BOLD_TEXT_FONT_SIZE = 15;
    private final int DEFAULT_SMALL_TEXT_FONT_SIZE = 12;
    private final int EMPTY_STRING_LENGTH = 0;
    private final int MINIMUM_PARENT_WIDTH = 0;
    
    private final String NO_TASK_TAG_MESSAGE = "This task has no tags";
    private final String TASK_TAG_HEADER = "\n\nTask Tags:\n";
    private final String EMPTY_STRING = "";
    private final String DEFAULT_BOLD_TEXT_STYLE_NAME = "big bold text";
    private final String DEFAULT_SMALL_TEXT_STYLE_NAME = "small text";
    private final String TASK_HEADER_STRING = "Task ";
    private final String TASK_NAME_HEADER_STRING = "Task Name:\n";
    private final String TASK_INFORMATION_SEPARATOR = "\n\n";
    private final String DEFAULT_TASK_NAME = "This task has no name :/\n\n";
    private final String TASK_DESCRIPTION_HEADER_STRING = "Description:\n";
    private final String DEFAULT_TASK_DESCRIPTION = "No description is entered for this task\n\n";
    private final String FLOATING_TASK_STRING = "This is a floating task";
    private final String COMPLETED_TASK_STRING = "Completed on:\n";
    private final String FROM_DATE_STRING = "From:\n";
    private final String TO_DATE_STRING = "To:\n";
    private final String BY_DATE_STRING = "By:\n";
    private final String UP_ARROW_IMAGE_RESOURCE_LINK = "/planner/WhiteUpArrow.png";
    private final String DOWN_ARROW_IMAGE_RESOURCE_LINK = "/planner/WhiteDownArrow.png";
    private final String UP_TIP_IMAGE_RESOURCE_LINK = "/planner/Up.png";
    private final String DOWN_TIP_IMAGE_RESOURCE_LINK = "/planner/Down.png";
    private final String UPANDDOWN_TIP_IMAGE_RESOURCE_LINK = "/planner/UpAndDown.png";
    private final String BACKGROUND_IMAGE_RESOURCE_LINK = "/planner/SliderPanel.png";
    
    /**
     * Constructs a SliderPanel component that will display additional task information.
     *
     * @param widthNotToMoveInto    The x coordinate in the parent frame that the SliderPanel will have to stop moving upon reaching
     * @param parentWidth           The width of the parent frame
     */
    public SliderPanel( int widthNotToMoveInto, int parentWidth ) {
        prepareDisplayInfoPanel();
        prepareUpArrow();
        prepareDownArrow();
        prepareTips();
        prepareBackground();
        this.parentWidth_ = parentWidth > MINIMUM_PARENT_WIDTH ? parentWidth : MINIMUM_PARENT_WIDTH;
        this.widthNotToMoveInto_ = widthNotToMoveInto > MINIMUM_PARENT_WIDTH ? widthNotToMoveInto : MINIMUM_PARENT_WIDTH;
        setupTimerForSlideOut();
        setupTimerForSlideIn();
        setToInvisible();
    }
    
    /**
     * Returns A Dimension container containing the preferred width and height of this SliderPanel component
     *
     * @return A Dimension container containing the preferred width and height of this SliderPanel component
     */
    @Override
    public Dimension getPreferredSize(){
        return new Dimension(DEFAULT_SLIDERPANEL_WIDTH,DEFAULT_SLIDERPANEL_HEIGHT);
    }
    
    /**
     * Sets up the timer for the slide out animation for this SliderPanel component 
     */
    private void setupTimerForSlideOut(){
        timerSlideOut_ = new Timer( MILLISECOND_TO_WAIT_BEFORE_NEXT_ANIMATION_FRAME, new ActionListener(){
            private long time = DEFAULT_INITIAL_START_TIME;
            @Override
            public void actionPerformed(ActionEvent actionEvent) {

                if( currentXCoordinate_ == initialXCoordinate_ ){
                    setToVisible();
                }
                int increments = XCOORDINATE_INCREMENT_FOR_ANIMATION;
                
                if( time <= DEFAULT_INITIAL_START_TIME ){
                    time = System.nanoTime();
                } else{
                    long timeDifference = System.nanoTime() - time;
                    int multiplier = (int)(timeDifference/(NANOSECOND_PER_MILLISECOND*MILLISECOND_TO_WAIT_BEFORE_NEXT_ANIMATION_FRAME));
                    multiplier = (multiplier > MINIMUM_DISTANCE_MULTIPLIER ? multiplier : DEFAULT_DISTANCE_MULTIPLIER);
                    increments = Math.min(increments*multiplier, currentXCoordinate_-widthNotToMoveInto_);
                }
                currentXCoordinate_ = currentXCoordinate_ - increments;
                setLocation(currentXCoordinate_, initialYCoordinate_ );
                if( timerSlideIn_.isRunning() || currentXCoordinate_ <= widthNotToMoveInto_ ){
                    timerSlideOut_.stop();
                    time = DEFAULT_INITIAL_START_TIME;
                }
            }
        });
    }

    /**
     * Sets up the timer for the slide in animation for this SliderPanel component 
     */
    private void setupTimerForSlideIn(){
        timerSlideIn_ = new Timer( MILLISECOND_TO_WAIT_BEFORE_NEXT_ANIMATION_FRAME, new ActionListener(){
            private long time = DEFAULT_INITIAL_START_TIME;
            @Override
            public void actionPerformed(ActionEvent actionEvent) {
                
                int increments = XCOORDINATE_INCREMENT_FOR_ANIMATION;
                if( time <= DEFAULT_INITIAL_START_TIME ){
                    time = System.nanoTime();
                } else{
                    long timeDifference = System.nanoTime() - time;
                    int multiplier = (int)(timeDifference/(NANOSECOND_PER_MILLISECOND*MILLISECOND_TO_WAIT_BEFORE_NEXT_ANIMATION_FRAME));
                    multiplier = (multiplier > MINIMUM_DISTANCE_MULTIPLIER ? multiplier : DEFAULT_DISTANCE_MULTIPLIER);
                    increments = Math.min(increments*multiplier, parentWidth_-currentXCoordinate_);
                }
                currentXCoordinate_ = currentXCoordinate_ + increments;
                setLocation(currentXCoordinate_, initialYCoordinate_ );
                if( currentXCoordinate_ >= parentWidth_ ){
                    setToInvisible();
                    timerSlideIn_.stop();
                    time = DEFAULT_INITIAL_START_TIME;
                    System.out.println( "Slide in stopped" );
                }
            }
        });
    }
    
    /**
     * Initializes and set attributes for the up arrow component.
     */
    private void prepareUpArrow(){
        upArrow_ = new JLabel();
        upArrow_.setIcon(new ImageIcon(SliderPanel.class.getResource(UP_ARROW_IMAGE_RESOURCE_LINK)));
        upArrow_.setBounds(DEFAULT_UP_ARROW_RELATIVE_XCOORDINATE, DEFAULT_UP_ARROW_RELATIVE_YCOORDINATE, 
                          DEFAULT_UP_ARROW_WIDTH, DEFAULT_UP_ARROW_HEIGHT);
        add(upArrow_);
        hideUpArrow();
    }
    
    /**
     * Displays the up arrow component.
     */
    private void showUpArrow(){
        upArrow_.setVisible(true);
    }
    
    /**
     * Hides the up arrow component from view.
     */
    private void hideUpArrow(){
        upArrow_.setVisible(false);
    }
    
    /**
     * Initializes and set attributes for the down arrow component.
     */
    private void prepareDownArrow(){
        downArrow_ = new JLabel();
        downArrow_.setIcon(new ImageIcon(SliderPanel.class.getResource(DOWN_ARROW_IMAGE_RESOURCE_LINK)));
        downArrow_.setBounds(DEFAULT_DOWN_ARROW_RELATIVE_XCOORDINATE, DEFAULT_DOWN_ARROW_RELATIVE_YCOORDINATE, 
                            DEFAULT_DOWN_ARROW_WIDTH, DEFAULT_DOWN_ARROW_HEIGHT);
        add(downArrow_);
        hideDownArrow();
    }
    
    /**
     * Displays the down arrow component.
     */
    private void showDownArrow(){
        downArrow_.setVisible(true);
    }
    
    /**
     * Hides the down arrow component from view.
     */
    private void hideDownArrow(){
        downArrow_.setVisible(false);
    }

    /**
     * Initializes and set attributes for the tips label component.
     */
    private void prepareTips(){
        tips_ = new JLabel();
        tips_.setBounds(DEFAULT_TIPLABEL_RELATIVE_XCOORDINATE, DEFAULT_TIPLABEL_RELATIVE_YCOORDINATE,
                       DEFAULT_TIPLABEL_WIDTH, DEFAULT_TIPLABEL_HEIGHT);
        add(tips_);
        hideTip();
    }
    
    /**
     * Hides the tips label component from view.
     */
    private void hideTip(){
        tips_.setVisible(false);
    }
    
    /**
     * Inserts the given string into the document displayed by the infopanel at the position given and 
     * rendered using the given style. 
     *
     * @param position  The position in the document that the given string is going to be inserted at. If the position
     *                  given is invalid, the string will not be inserted into the document.
     * @param str       The string to be inserted into the document
     * @param style     The style that the inserted string is going to be rendered in
     */
    public void insertStringToDisplay( int position, String str, SimpleAttributeSet style ){
        if( infoPanel_ != null && str != null ){
            StyledDocument doc = infoPanel_.getStyledDocument();
            if( doc != null ){
                try {
                    doc.insertString(position, str, style);
                } catch (BadLocationException e) {}
            }
        }
    }
    
    /**
     * Returns the current caret position of the document displayed by the infopanel
     *
     * @return The current caret position of the document displayed by the infopanel
     */
    public int getDisplayCaretPosition(){
        if( infoPanel_ != null ){
            return infoPanel_.getCaretPosition();
        } else{
            return DEFAULT_INVALID_CARET_POSITION;
        }
    }
    
    /**
     * Sets the current caret position of the document displayed by the infopanel. If the caret position
     * is invalid, the current caret position will remain the same as before.
     *
     * @param caretPosition The caret position to be set
     */
    public void setDisplayCaretPosition( int caretPosition ){
        try{
            if( infoPanel_ != null ){
                String currentTxt = infoPanel_.getText();
                if( caretPosition >= MINIMUM_DOCUMENT_INDEX && caretPosition <= currentTxt.length() ){
                    infoPanel_.setCaretPosition(caretPosition);
                }
            }
        } catch( IllegalArgumentException illegalArgumentException ){}
    }
    
    /**
     * Display the tip message corresponding to the ENUM tipType value
     *
     * @param tipType   The type of tip message to show to the user
     */
    private void showTip( TipType tipType ){
        tips_.setVisible(true);
        switch(tipType){
            case UP_TIP:
                tips_.setIcon(new ImageIcon(SliderPanel.class.getResource(UP_TIP_IMAGE_RESOURCE_LINK)));
                break;
                
            case DOWN_TIP:
                tips_.setIcon(new ImageIcon(SliderPanel.class.getResource(DOWN_TIP_IMAGE_RESOURCE_LINK)));
                break;
                
            case UPDOWN_TIP:
                tips_.setIcon(new ImageIcon(SliderPanel.class.getResource(UPANDDOWN_TIP_IMAGE_RESOURCE_LINK)));
                break;
                
            default:
                hideTip();
                break;
        }
    }

    /**
     * Initializes and set attributes for the background component.
     */
    private void prepareBackground(){
        background_ = new JLabel();
        background_.setIcon(new ImageIcon(SliderPanel.class.getResource(BACKGROUND_IMAGE_RESOURCE_LINK)));
        background_.setBounds(DEFAULT_BACKGROUND_RELATIVE_XCOORDINATE, DEFAULT_BACKGROUND_RELATIVE_YCOORDINATE, DEFAULT_SLIDERPANEL_WIDTH, DEFAULT_SLIDERPANEL_HEIGHT);
        add(background_);
    }
    
    /**
     * Initializes and set attributes for the display component for this sliderpanel
     */
    private void prepareDisplayInfoPanel(){
        infoPanelScrollPane_ = new JScrollPane();
        infoPanelScrollPane_.setBounds(DEFAULT_INFOPANEL_RELATIVE_XCOORDINATE, DEFAULT_INFOPANEL_RELATIVE_YCOORDINATE, 
                                      DEFAULT_INFOPANEL_WIDTH, DEFAULT_INFOPANEL_HEIGHT);
        add(infoPanelScrollPane_);
        infoPanel_ = new JTextPane();
        infoPanel_.setBorder(null);
        infoPanel_.setOpaque(false);
        infoPanel_.setEditable(false);
        infoPanel_.setHighlighter(null);
        infoPanel_.setFocusable(false);
        infoPanel_.setEditorKit(new CustomWrapKit());
        infoPanelScrollPane_.setViewportView(infoPanel_);
        infoPanelScrollPane_.setBorder(null);
        infoPanelScrollPane_.setOpaque(false);
        infoPanelScrollPane_.getViewport().setOpaque(false);
        infoPanelScrollPane_.setHorizontalScrollBarPolicy(JScrollPane.HORIZONTAL_SCROLLBAR_NEVER);
        infoPanelScrollPane_.setVerticalScrollBarPolicy(JScrollPane.VERTICAL_SCROLLBAR_AS_NEEDED);
        infoPanelScrollPane_.setFocusable(false);
        attachScrollAdjustmentListener(infoPanelScrollPane_);
        verticalScrollBar_ = infoPanelScrollPane_.getVerticalScrollBar();
        verticalScrollBar_.setOpaque(false);
        scrollBarSkin_ = new InvisibleScrollBarUI();
        verticalScrollBar_.setUI( scrollBarSkin_ );
    }
    
    /**
     * Set up a listener for the scroll bar attached to the display component for this SliderPanel so that
     * appropriate tips can be shown depending on the position of the scroll bar thumb.
     * 
     * @param scrollPane The ScrollPane which the display component for this SliderPanel is embedded within
     */
    private void attachScrollAdjustmentListener( JScrollPane scrollPane ){
        if( scrollPane != null ){
            verticalScrollBar_ = scrollPane.getVerticalScrollBar();
            if( verticalScrollBar_ != null ){
                verticalScrollBar_.addAdjustmentListener(new AdjustmentListener(){
                    @Override
                    public void adjustmentValueChanged(AdjustmentEvent event) {
                        if( !verticalScrollBar_.isVisible() ){
                            hideDownArrow();
                            hideUpArrow();
                            hideTip();
                        } else{
                            int scrollBarExtent = verticalScrollBar_.getModel().getExtent();
                            if( verticalScrollBar_.getValue() <= verticalScrollBar_.getMinimum() ){
                                hideUpArrow();
                                showDownArrow();
                                showTip( TipType.DOWN_TIP );
                            } else if( verticalScrollBar_.getValue() + scrollBarExtent >= verticalScrollBar_.getMaximum() ){
                                hideDownArrow();
                                showUpArrow();
                                showTip( TipType.UP_TIP );
                            } else{
                                showUpArrow();
                                showDownArrow();
                                showTip( TipType.UPDOWN_TIP );
                            }
                        }
                    }
                });
            }
        }
    }
    
    /**
     * Make this SliderPanel invisible.
     */
    private void setToInvisible(){
        setVisible(false);
        isCurrentlyVisible_ = false;
    }
    
    /**
     * Make this SliderPanel visible.
     */
    private void setToVisible(){
        setVisible(true);
        isCurrentlyVisible_ = true;
    }
    
    /**
     * This method will start the slide out (moving into view) animation for this SliderPanel component. It will display the information
     * found in task by overriding previous display contents if canOverrideContents is true or append this information to 
     * the previous display contents if canOverrideContents is false.
     * 
     * @param task                  The task in which its information will be displayed by the infoPanel of this SliderPanel component.
     *                              It the task is null, all previous display contents will be cleared if canOverrideContents is true;
     *                              otherwise all previous display contents will remain if canOverrideContents is false
     * @param canOverrideContents   Flag to indicate if all previous display contents can be overwritten.
     */
    public void slideOut( Task task, boolean canOverrideContents ){
        Point pointInParent = getLocation();
        if( firstXCoordinate_ != null ){
            initialXCoordinate_ = firstXCoordinate_;
        } else{
            firstXCoordinate_ = (pointInParent != null ? pointInParent.x : null);
            initialXCoordinate_ = firstXCoordinate_ != null ? firstXCoordinate_ : DEFAULT_INTITIAL_XCOORDINATE_FOR_SLIDERPANEL;
        }
        initialYCoordinate_ = pointInParent != null ? pointInParent.y : DEFAULT_INTITIAL_YCOORDINATE_FOR_SLIDERPANEL;
        if( initialXCoordinate_ <= widthNotToMoveInto_ ){
            return;
        }
        if( canOverrideContents ){
            populateDisplay(task);
        }
        currentXCoordinate_ = initialXCoordinate_;
        if( timerSlideOut_.isRunning() ){
            timerSlideOut_.stop();
        }
        setLocation( currentXCoordinate_, initialYCoordinate_ );
        timerSlideOut_.start();
    }
    
    /**
     * This method will start the slide in (moving out of view) animation for this SliderPanel component.
     */
    public void slideIn(){
        if( currentXCoordinate_ >= parentWidth_ ){
            return;
        }
        setLocation( parentWidth_, initialYCoordinate_ );
        if( timerSlideIn_.isRunning() ){
            timerSlideIn_.stop();
        }
        timerSlideIn_.start();
    }
    
    /**
     * Returns true if this SliderPanel is currently in view; False otherwise.
     * 
     * @return TRUE if this SliderPanel is currently in view; False otherwise.
     */
    public boolean isVisible(){
        return isCurrentlyVisible_;
    }
    
    /**
     * Set the policy of the vertical scrollbar of the infoPanel to never show itself regardless of how tall the contents
     * within the infoPanel is
     */
    public void hideScrollBar(){
        infoPanelScrollPane_.setVerticalScrollBarPolicy(JScrollPane.VERTICAL_SCROLLBAR_NEVER);
    }
    
    /**
     * Set the policy of the vertical scrollbar of the infoPanel to show itself if the contents displayed within the infoPanel
     * is too tall to fit into the infoPanel
     */
    public void showScrollBar(){
        infoPanelScrollPane_.setVerticalScrollBarPolicy(JScrollPane.VERTICAL_SCROLLBAR_AS_NEEDED);
    }
    
    /**
     * This method will display task name and description
     * 
     * @param doc           The document where it will insert the task name and description to
     * @param task          The task object where it will retrieve information to display
     * @param bigBoldText   The bold and larger sized text font style
     * @param smallText     The smaller sized text font style
     */
    private void displayBasicTaskInfomation( StyledDocument doc, Task task,
                                             Style bigBoldText, Style smallText) throws BadLocationException{
        if( doc != null && task != null ){
            doc.insertString( doc.getLength(), TASK_HEADER_STRING, bigBoldText );
            doc.insertString( doc.getLength(), task.getID() + TASK_INFORMATION_SEPARATOR, bigBoldText );
            doc.insertString( doc.getLength(), TASK_NAME_HEADER_STRING, bigBoldText );
            if( task.getName() != null && task.getName().length() > EMPTY_STRING_LENGTH ){
                doc.insertString( doc.getLength(), task.getName() + TASK_INFORMATION_SEPARATOR, smallText );
            } else{
                doc.insertString( doc.getLength(), DEFAULT_TASK_NAME, smallText );
            }
            doc.insertString( doc.getLength(), TASK_DESCRIPTION_HEADER_STRING, bigBoldText );
            if( task.getDescription() != null && task.getDescription().length() > EMPTY_STRING_LENGTH ){
                doc.insertString( doc.getLength(), task.getDescription() + TASK_INFORMATION_SEPARATOR, smallText );
            } else{
                doc.insertString( doc.getLength(), DEFAULT_TASK_DESCRIPTION, smallText );
            }
        }
    }
    
    /**
     * This method will display timed task dates
     * 
     * @param doc           The document where it will insert the timed task dates to
     * @param task          The task object where it will retrieve information to display
     * @param bigBoldText   The bold and larger sized text font style
     * @param smallText     The smaller sized text font style
     */
    private void displayTimedTask( StyledDocument doc, Task task,
                                   Style bigBoldText, Style smallText ) throws BadLocationException {
        if( doc != null && task != null ){
            if( task.getDueDate() != null && task.getEndDate() != null ){
                doc.insertString( doc.getLength(), FROM_DATE_STRING, bigBoldText );
                doc.insertString( doc.getLength(), task.getDueDate() + TASK_INFORMATION_SEPARATOR, smallText );
                doc.insertString( doc.getLength(), TO_DATE_STRING, bigBoldText );
                doc.insertString( doc.getLength(), task.getEndDate().toString(), smallText );
            } else if( task.getEndDate() != null ){
                doc.insertString( doc.getLength(), BY_DATE_STRING, bigBoldText );
                doc.insertString( doc.getLength(), task.getEndDate().toString(), smallText );
            } else if( task.getDueDate() != null ){
                doc.insertString( doc.getLength(), BY_DATE_STRING, bigBoldText );
                doc.insertString( doc.getLength(), task.getDueDate().toString(), smallText );
            } else{
                doc.insertString( doc.getLength(), FLOATING_TASK_STRING, bigBoldText );
            }
        }
    }
    
    /**
     * This method will display task information
     * 
     * @param doc           The document where it will insert the task information to
     * @param task          The task object where it will retrieve information to display
     * @param bigBoldText   The bold and larger sized text font style
     * @param smallText     The smaller sized text font style
     */
    public void populateDisplay( Task task ){
        
        infoPanel_.setText(EMPTY_STRING);
        if( task != null ){
            infoPanel_.setForeground(Color.WHITE);
            Style bigBoldText = infoPanel_.addStyle(DEFAULT_BOLD_TEXT_STYLE_NAME, null);
            StyleConstants.setFontSize(bigBoldText, DEFAULT_BOLD_TEXT_FONT_SIZE);
            Style smallText = infoPanel_.addStyle(DEFAULT_SMALL_TEXT_STYLE_NAME, null);
            StyleConstants.setFontSize(smallText, DEFAULT_SMALL_TEXT_FONT_SIZE);
            StyledDocument doc = infoPanel_.getStyledDocument();
            try{
                displayBasicTaskInfomation( doc, task, bigBoldText, smallText );
                if( task.isFloating() ){
                    doc.insertString( doc.getLength(), FLOATING_TASK_STRING, bigBoldText );
                } else if( task.isDone() ){
                    doc.insertString( doc.getLength(), COMPLETED_TASK_STRING, bigBoldText );
                    doc.insertString( doc.getLength(), task.getDateCompleted().toString(), smallText );
                } else{
                    displayTimedTask( doc, task, bigBoldText, smallText );
                }
                displayTags(doc, task, bigBoldText, smallText);
                infoPanel_.setCaretPosition(MINIMUM_DOCUMENT_INDEX);
            } catch( BadLocationException badLocationException ){}
              catch( IllegalArgumentException illegalArgumentException ){}
        }
    }
    
    /**
     * This method will display task tag information
     * 
     * @param doc           The document where it will insert the task information to
     * @param task          The task object where it will retrieve information to display
     * @param bigBoldText   The bold and larger sized text font style
     * @param smallText     The smaller sized text font style
     */
    private void displayTags(StyledDocument doc, Task task,
                             Style bigBoldText, Style smallText) throws BadLocationException{
        if( doc != null && task != null ){
            doc.insertString( doc.getLength(), TASK_TAG_HEADER, bigBoldText );
            if (task.getTag() != null && task.getTag().length() > 0){
                doc.insertString(doc.getLength(), task.getTag(), smallText);
            }else{
                doc.insertString(doc.getLength(), NO_TASK_TAG_MESSAGE, smallText);
            }
        }
    }
    
    /**
     * Returns the up arrow component used by the scroll bar attached to the infoPanel which displays information
     * 
     * @return The up arrow component used by the scroll bar attached to the infoPanel which displays information
     */
    public InvisibleButton getUpArrowComponent(){
        return scrollBarSkin_ != null ? scrollBarSkin_.getUpButtonComponent() : null;
    }
    
    /**
     * Returns the down arrow component used by the scroll bar attached to the infoPanel which displays information
     * 
     * @return The down arrow component used by the scroll bar attached to the infoPanel which displays information
     */
    public InvisibleButton getDownArrowComponent(){
        return scrollBarSkin_ != null ? scrollBarSkin_.getDownButtonComponent() : null;
    }
    
    /**
    * Returns the display component which this sliderPanel use to display information
    * 
    * @return The display component which this sliderPanel use to display information
    */
    public JTextPane getDisplayComponent(){
        return infoPanel_;
    }
    
    /**
     * Returns the scrollPane which the display component of this sliderPanel is embedded within
     * 
     * @return The scrollPane which the display component of this sliderPanel is embedded within
     */
    public JScrollPane getDisplayScrollComponent(){
        return infoPanelScrollPane_;
    }
}

	// End of segment: C:\Users\GamePro-Pc\Desktop\Work\Y2S2\CS2103\main\source\src\planner\SliderPanel.java





	/**
	 * origin: C:\Users\GamePro-Pc\Desktop\Work\Y2S2\CS2103\main\source\src\planner\TaskBar.java
	 */


package planner;
import java.awt.Color;
import java.awt.Component;
import java.awt.Dimension;
import java.awt.Font;
import java.awt.Insets;
import java.awt.Point;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.text.SimpleDateFormat;
import java.util.Calendar;
import java.util.Date;
import java.util.Random;

import javax.swing.ImageIcon;
import javax.swing.JComponent;
import javax.swing.JLabel;
import javax.swing.JTextPane;
import javax.swing.SwingConstants;
import javax.swing.text.BadLocationException;
import javax.swing.text.Style;
import javax.swing.text.StyleConstants;
import javax.swing.text.StyledDocument;

/**
 * The DisplayPane class is a visual container that stores and displays information about a task
 */
public class TaskBar extends JComponent {

    private Insets componentCoordinates;
	
	private final int m_width = 597;
	private final int m_height = 50;
	
	private int heightOfLabel;
	
	private JLabel taskBarBackground;
	private JLabel taskCheckBox;
	private JLabel lineNumberLabel;
	private JLabel timeDisplayLabel;
	private JLabel timeDisplayLabelEx;
	private JLabel dateHeader;
	
	private JTextPane tagsPane;
	private JTextPane infoPane;
	
	private FadedTextField taskTitleLabel;
	
	private int position;
	
	private boolean hasMovedUp;
	private boolean hasMovedDown;
	
	private final static int DEFAULT_DISPLAY_POSITION = 0;
	private final int DEFAULT_LABEL_HEIGHT = 20;
    private final int MINIMUM_HEIGHT_OF_LABEL = 0;
    private final int MINIMUM_POSITION_IN_DISPLAY = 0;
    private final int DEFAULT_INFOPANEL_RELATIVE_XCOORDINATES = 40;
    private final int DEFAULT_INFOPANEL_RELATIVE_YCOORDINATES = 13;
    private final int DEFAULT_INFOPANEL_WIDTH = 330;
    private final int DEFAULT_INFOPANEL_HEIGHT = 20;
    private final int DEFAULT_INFOPANEL_FONT_SIZE = 14;
    private final int DEFAULT_TASKCHECKBOX_RELATIVE_XCOORDINATES = 562;
    private final int DEFAULT_TASKCHECKBOX_RELATIVE_YCOORDINATES = 12;
    private final int DEFAULT_TASKCHECKBOX_WIDTH = 26;
    private final int DEFAULT_TASKCHECKBOX_HEIGHT = 26;
    private final int DEFAULT_TASKTITLELABEL_RELATIVE_XCOORDINATES = 60;
    private final int DEFAULT_TASKTITLELABEL_RELATIVE_YCOORDINATES = 17;
    private final int DEFAULT_TASKTITLELABEL_WIDTH = 330;
    private final int DEFAULT_TASKTITLELABEL_HEIGHT = 20;
    private final int DEFAULT_TASKTITLELABEL_FONT_SIZE = 14;
    private final int DEFAULT_TASKTITLELABEL_MAX_CHARACTERS = 45;
    private final int DEFAULT_LINENUMBERLABEL_FONT_SIZE = 12;
    private final int DEFAULT_LINENUMBERLABEL_RELATIVE_XCOORDINATES = 5;
    private final int DEFAULT_LINENUMBERLABEL_RELATIVE_YCOORDINATES = 3;
    private final int DEFAULT_LINENUMBERLABEL_WIDTH = 50;
    private final int DEFAULT_LINENUMBERLABEL_HEIGHT = 45;
    private final int MINIMUM_LINENUMBER = 0;
    private final int NUMBER_OF_PRIORIIES = 5;
    private final int INDEX_OF_COLOUR_FOR_PRIORITY_ONE = 4;
    private final int PRIORITY_FIVE = 5;
    private final int PRIORITY_FOUR = 4;
    private final int PRIORITY_THREE = 3;
    private final int PRIORITY_TWO = 2;
    private final int PRIORITY_ONE = 1;
    private final int DEFAULT_TAGSPANE_RELATIVE_XCOORDINATES = 56;
    private final int DEFAULT_TAGSPANE_RELATIVE_YCOORDINATES = 25;
    private final int DEFAULT_TAGSPANE_WIDTH = 335;
    private final int DEFAULT_TAGSPANE_HEIGHT = 17;
    private final int DEFAULT_TAGSPANE_FONT_SIZE = 12;
    private final int MINIMUM_STRING_LENGTH = 0;
    private final int DEFAULT_MOVE_OFFSET = 8;
    private final int DEFAULT_TIMEDISPLAYLABEL_RELATIVE_XCOORDINATES = 395;
    private final int DEFAULT_TIMEDISPLAYLABEL_RELATIVE_YCOORDINATES = 18;
    private final int DEFAULT_TIMEDISPLAYLABEL_WIDTH = 164;
    private final int DEFAULT_TIMEDISPLAYLABEL_HEIGHT = 14;
    private final int DEFAULT_TIMEDISPLAYLABEL_FONT_SIZE = 11;
    private final int FIRST_COMPONENT_ORDER_INDEX = 0;
    private final int MOVE_OFFSET = 8;
    private final int MAX_TAG_CHARACTERS = 30;
    private final int MAX_TAG_INDEX = 29;
    private final int MIN_STRING_OFFSET = 0;
    
    private final String STRING_BREAK = "...";
    private final String FLOATING_TASK_DATE_STRING = "No Due Date Set";
    private final String DEFAULT_COMPARE_DATE_FORMAT = "h:mma";
    private final String DONE_TASK_DATE_STRING = "Completed at ";
    private final String FROM_DATE_STRING = "From ";
    private final String TO_DATE_STRING = " to ";
    private final String TO_DATE_STRING_II = "To";
    private final String BY_DATE_STRING = "By ";
    private final String DISPLAY_DATE_FORMAT = "d MMM yyyy 'at' h:mma";
    private final String BACKGROUND_IMAGE_RESOURCE_LINK = "/planner/TaskBar.png";
    private final String DEFAULT_TIMEDISPLAYLABEL_FONT_FAMILY = "Arial";
    private final String DEFAULT_DATE_STRING = "By 11:59PM";
    private final String DEFAULT_TAGSPANE_FONT_STYLE_NAME = "color";
    private final String PRIORITY_STRING = "priority ";
    private final String SPACING = " ";
    private final String TAGS_DIVIDER = "/ ";
    private final String EMPTY_STRING = "";
    private final String DEFAULT_TAGSPANE_FONT_FAMILY = "Arial";
    private final String DEFAULT_LINENUMBERLABEL_FONT_FAMILY = "Arial";
    private final String DEFAULT_LINENUMBER_STRING = "#11111";
    private final String NUMBER_SYMBOL = "#";
    private final String TASKCHECKBOX_IMAGE_RESOURCE_LINK = "/planner/NotDoneCheckBox.png";
    private final String FLOATING_TASK_STATUS_IMAGE_RESOURCE_LINK = "/planner/FloatingTaskStatus.png";
    private final String TIMED_TASK_STATUS_IMAGE_RESOURCE_LINK = "/planner/TimedTaskStatus.png";
    private final String DEADLINE_TASK_STATUS_IMAGE_RESOURCE_LINK = "/planner/DeadlineTaskStatus.png";
    private final String ACTIVATED_TASKBAR_IMAGE_RESOURCE_LINK = "/planner/TaskBarActivated.png";
    private final String TASKBAR_IMAGE_RESOURCE_LINK = "/planner/TaskBar.png";
    private final String TASK_WITH_DATE_IMAGE_RESOURCE_LINK = "/planner/Alarm.png";
    private final String DEFAULT_INFOPANEL_FONT_STYLE_NAME = "Original";
    private final String DEFAULT_INFOPANEL_FONT_FAMILY = "Arial";
    private final String DEFAULT_TASKTITLELABEL_FONT_FAMILY = "Arial";
    private final String DEFAULT_TASKTITLELABEL_TEXT = "This is a sample text testing one two three four five";
    
	/**
     * Constructs a TaskBar object without a header on the top of it and sets the default display position of 0
     */
	public TaskBar() {
		this(DEFAULT_DISPLAY_POSITION);
	}
	
	/**
     * Constructs a TaskBar object without a header on the top of it
     * 
     * @param  position         The caret position of the taskBar object within the displayPane
     */
	public TaskBar( int position ){
	    this(null, position);
	}
	
	/**
	 * Constructs a TaskBar object with a newDateHeader header on the top of it
	 * 
	 * @param  newDateHeader    The header to be placed above the TaskBar object
	 * @param  position         The caret position of the taskBar object within the displayPane
	 */
	public TaskBar( JLabel newDateHeader, int position ){
	    
	    this.position = position >= MINIMUM_POSITION_IN_DISPLAY ? position : MINIMUM_POSITION_IN_DISPLAY;
	    dateHeader = newDateHeader;
	    componentCoordinates = getInsets();
        if( dateHeader != null ){
            heightOfLabel = DEFAULT_LABEL_HEIGHT;
            dateHeader.setBounds(componentCoordinates.left, componentCoordinates.top, m_width, heightOfLabel);
            dateHeader.setPreferredSize(new Dimension(m_width, heightOfLabel));
            add(dateHeader);
        } else{
            heightOfLabel = MINIMUM_HEIGHT_OF_LABEL;
        }
        setSize(m_width, m_height+heightOfLabel);
        setOpaque(false);
        setBorder(null);
        setFocusable(false);
        setLayout(null);
        prepareTaskCheckBox();
        prepareTaskTitleLabel();
        prepareLineNumberLabel();
        prepareTagsPane();
        prepareTimeDisplayLabel();
        prepareTaskBarBackground();
	}
	
	/**
     * Constructs a TaskBar object with a newDateHeader header on the top of it and displays the given info string
     * 
     * @param  newDateHeader    The header to be placed above the TaskBar object
     * @param  info             The string to be displayed on the TaskBar object
     */
	public TaskBar( JLabel newTitleHeader, String info ){
	    this.position = position >= MINIMUM_POSITION_IN_DISPLAY ? position : MINIMUM_POSITION_IN_DISPLAY;
        dateHeader = newTitleHeader;
        componentCoordinates = getInsets();
        if( dateHeader != null ){
            heightOfLabel = DEFAULT_LABEL_HEIGHT;
            dateHeader.setBounds(componentCoordinates.left, componentCoordinates.top, m_width, heightOfLabel);
            dateHeader.setPreferredSize(new Dimension(m_width, heightOfLabel));
            add(dateHeader);
        } else{
            heightOfLabel = MINIMUM_HEIGHT_OF_LABEL;
        }
        setSize(m_width, m_height+heightOfLabel);
        setOpaque(false);
        setBorder(null);
        setFocusable(false);
        setLayout(null);
        prepareInfoPane(info);
        prepareTaskBarBackground();
	}
	
	/**
     * Initializes and set the attributes of the InfoPane text component
     * 
     * @param  info             The string to be displayed in the InfoPane text component
     */
	private void prepareInfoPane( String info ){
        infoPane = new JTextPane();
        infoPane.setBounds(DEFAULT_INFOPANEL_RELATIVE_XCOORDINATES, 
                           DEFAULT_INFOPANEL_RELATIVE_YCOORDINATES+heightOfLabel, 
                           DEFAULT_INFOPANEL_WIDTH, DEFAULT_INFOPANEL_HEIGHT);
        infoPane.setFocusable(false);
        infoPane.setEditable(false);
        infoPane.setHighlighter(null);
        infoPane.setOpaque(false);
        infoPane.setFont(new Font( DEFAULT_INFOPANEL_FONT_FAMILY, Font.BOLD, DEFAULT_INFOPANEL_FONT_SIZE));
        infoPane.setForeground( Color.WHITE );
        add(infoPane);
        Style tempStyle = infoPane.addStyle(DEFAULT_INFOPANEL_FONT_STYLE_NAME, null);
        StyleConstants.setFontFamily(tempStyle, DEFAULT_INFOPANEL_FONT_FAMILY);
        StyleConstants.setFontSize(tempStyle, DEFAULT_INFOPANEL_FONT_SIZE);
        StyleConstants.setBold(tempStyle, true);
        StyleConstants.setForeground(tempStyle, Color.WHITE);
        infoPane.setText(info);
        
        assert infoPane.isFocusable() == false;
        assert infoPane.isEditable() == false;
        assert infoPane.isOpaque() == false;
    }
	
	/**
     * Constructs a TaskBar object with a newDateHeader header on the top of it and sets the default display position of 0
     * 
     * @param  newDateHeader    The header to be placed above the TaskBar object
     */
	public TaskBar( JLabel newDateHeader ){
	    this( newDateHeader, DEFAULT_DISPLAY_POSITION );
	}

	/**
     * Returns the stored display position of this taskBar object
     * 
     * @return  The stored display position of this taskBar object
     */
	public int getPosition(){
		return position;
	}
	
	/**
     * Sets display position of this taskBar object
     * 
     * @param position  The display position of this taskBar object
     */
	public void setPosition( int position ){
		this.position = position;
	}

	/**
     * Initializes and set the attributes of the Checkbox label component
     */
	private void prepareTaskCheckBox(){
		
		taskCheckBox = new JLabel();
		taskCheckBox.setIcon(new ImageIcon(TaskBar.class.getResource(TASKCHECKBOX_IMAGE_RESOURCE_LINK)));
		taskCheckBox.setFocusable(false);
		taskCheckBox.setBounds(DEFAULT_TASKCHECKBOX_RELATIVE_XCOORDINATES, 
		                       DEFAULT_TASKCHECKBOX_RELATIVE_YCOORDINATES+heightOfLabel, 
		                       DEFAULT_TASKCHECKBOX_WIDTH, DEFAULT_TASKCHECKBOX_HEIGHT);
		add(taskCheckBox);
		removeMouseListener(taskCheckBox);
	}
	
	/**
     * Changes the Checkbox label component's image to a done check box image.
     */
	public void setTaskDone(){
		taskCheckBox.setIcon(new ImageIcon(TaskBar.class.getResource("/planner/DoneCheckBox.png")));
	}
	
	/**
     * Changes the Checkbox label component's image to a not done check box image.
     */
	public void setTaskNotDone(){
		taskCheckBox.setIcon(new ImageIcon(TaskBar.class.getResource("/planner/NotDoneCheckBox.png")));
	}
	
	/**
     * Changes the Checkbox label component's image to a half done check box image.
     */
	public void setTaskHalfDone(){
		taskCheckBox.setIcon(new ImageIcon(TaskBar.class.getResource("/planner/HalfDoneCheckBox.png")));
	}

	/**
     * Initializes and set the attributes of the TaskTitleLabel component
     */
	private void prepareTaskTitleLabel(){
		taskTitleLabel = new FadedTextField(Color.WHITE, Color.BLACK, Color.BLACK, 
		                                    DEFAULT_TASKTITLELABEL_MAX_CHARACTERS, DEFAULT_TASKTITLELABEL_MAX_CHARACTERS);
		taskTitleLabel.setBounds(DEFAULT_TASKTITLELABEL_RELATIVE_XCOORDINATES, 
		                         DEFAULT_TASKTITLELABEL_RELATIVE_YCOORDINATES+heightOfLabel, 
		                         DEFAULT_TASKTITLELABEL_WIDTH, DEFAULT_TASKTITLELABEL_HEIGHT);
		taskTitleLabel.setFocusable(false);
		taskTitleLabel.setFont(new Font( DEFAULT_TASKTITLELABEL_FONT_FAMILY, Font.BOLD, 
		                                 DEFAULT_TASKTITLELABEL_FONT_SIZE));
		add(taskTitleLabel);
		taskTitleLabel.setText(DEFAULT_TASKTITLELABEL_TEXT);
		hasMovedDown = true;
		hasMovedUp = false;
	}
	
	/**
     * Sets the task title of the TaskBar with the title string found within the given task
     * 
     * @param task  The Task object in which its title is extracted to set the task title of this TaskBar
     */
	public void setTaskTitle( Task task ){
	    if( task != null ){
	        String taskName = task.getName();
	        if( taskName != null ){
	            if( !task.isDone() ){
        	        if( task.isFloating() ){
        	            taskCheckBox.setIcon(new ImageIcon(TaskBar.class.getResource(FLOATING_TASK_STATUS_IMAGE_RESOURCE_LINK)));
        	        } else if( task.isTimed() ){
        	            taskCheckBox.setIcon(new ImageIcon(TaskBar.class.getResource(TIMED_TASK_STATUS_IMAGE_RESOURCE_LINK)));
        	        } else{
        	            taskCheckBox.setIcon(new ImageIcon(TaskBar.class.getResource(DEADLINE_TASK_STATUS_IMAGE_RESOURCE_LINK)));
        	        }
	            }
    	        taskTitleLabel.setText( taskName );
	        }
	    }
	}
	
	/**
     * Move the title of this TaskBar given the distance offset relative to its current position
     * 
     * @param relativeIncrements  The distance offset to move the title of this TaskBar relative to its current position
     */
	private void moveTitleLabelVertically( int relativeIncrements ){
	    Point currentLocationOfTitle = taskTitleLabel.getLocation();
	    if( currentLocationOfTitle != null ){
	        taskTitleLabel.setLocation(currentLocationOfTitle.x, currentLocationOfTitle.y + relativeIncrements);
	    }
	}
	
	/**
     * Initializes and set the attributes of the LineNumberLabel component
     */
	private void prepareLineNumberLabel(){
		lineNumberLabel = new JLabel(DEFAULT_LINENUMBER_STRING);
		lineNumberLabel.setBounds(DEFAULT_LINENUMBERLABEL_RELATIVE_XCOORDINATES, 
		                          DEFAULT_LINENUMBERLABEL_RELATIVE_YCOORDINATES+heightOfLabel, 
		                          DEFAULT_LINENUMBERLABEL_WIDTH, DEFAULT_LINENUMBERLABEL_HEIGHT);
		lineNumberLabel.setForeground(Color.WHITE);
		lineNumberLabel.setFont(new Font( DEFAULT_LINENUMBERLABEL_FONT_FAMILY, Font.BOLD, DEFAULT_LINENUMBERLABEL_FONT_SIZE ));
		lineNumberLabel.setFocusable(false);
		lineNumberLabel.setHorizontalAlignment(SwingConstants.CENTER);
		add(lineNumberLabel);
		removeMouseListener(lineNumberLabel);
	}
	
	/**
     * Sets the id of the TaskBar to be displayed
     * 
     * @param lineNumber  The id of the TaskBar to be displayed
     */
	public void setLineNumber( long lineNumber ){
		if( lineNumber > MINIMUM_LINENUMBER ){
			lineNumberLabel.setText(NUMBER_SYMBOL+lineNumber);
		}
	}
	
	/**
     * Initializes and set the attributes of the TagsPane component
     */
	private void prepareTagsPane(){
	    tagsPane = new JTextPane();
        tagsPane.setBounds(DEFAULT_TAGSPANE_RELATIVE_XCOORDINATES, DEFAULT_TAGSPANE_RELATIVE_YCOORDINATES+heightOfLabel, 
                           DEFAULT_TAGSPANE_WIDTH, DEFAULT_TAGSPANE_HEIGHT);
        add(tagsPane);
        tagsPane.setEditable(false);
        tagsPane.setHighlighter(null);
        tagsPane.setFocusable(false);
        tagsPane.setOpaque(false);
        tagsPane.setFont( new Font( DEFAULT_TAGSPANE_FONT_FAMILY, Font.BOLD, DEFAULT_TAGSPANE_FONT_SIZE ) );
	}
	
	/**
     * Returns the color corresponding to the given priority. If a priority < 1 or > 5 is given, it will return priority one's
     * color. It will also mark the color returned in the colorsToExclude array as used.
     * 
     * @param colors            The array of colors to find a corresponding color for the given priority
     * @param priority          The priority of a task
     * @param colorsToExclude   An array that records the colours that have already been used
     * 
     * @return The color corresponding to the given priority
     */
	private Color getPriorityColor( Color []colors, int priority, boolean []colorsToExclude ){
	    if( colors != null && 
	        colors.length >= NUMBER_OF_PRIORIIES &&
	        colorsToExclude != null &&
	        colorsToExclude.length >= PRIORITY_FIVE){
	        switch( priority ){
	            case PRIORITY_FIVE:
	            case PRIORITY_FOUR:
	            case PRIORITY_THREE:
	            case PRIORITY_TWO:
	                if( colors[PRIORITY_FIVE-priority] != null ){
	                    colorsToExclude[PRIORITY_FIVE-priority] = true;
	                    return colors[PRIORITY_FIVE-priority];
	                } else{
	                    return Color.WHITE;
	                }
	                
	            default:
	                if( colors[INDEX_OF_COLOUR_FOR_PRIORITY_ONE] != null ){
	                    colorsToExclude[INDEX_OF_COLOUR_FOR_PRIORITY_ONE] = true;
                        return colors[INDEX_OF_COLOUR_FOR_PRIORITY_ONE];
                    } else{
                        return Color.WHITE;
                    }
	        }
	    } else{
	        return Color.WHITE;
	    }
	}
	
	/**
     * This method will append the given string at the back of the given document and will be rendered with 
     * the given color and style.
     * 
     * @param doc               The document in which the string will be appended to
     * @param style             The style to render the appended string in
     * @param color             The color to set for the appended string
     * @param str               The string to be appended
     */
	private void appendColoredStringsToDisplay( StyledDocument doc, Style style, Color color, String str ){
	    if( doc != null && style != null && color != null && str != null){
	        try{
	            StyleConstants.setForeground(style, color);
                doc.insertString(doc.getLength(), str, style);
	        } catch( BadLocationException badLocationException ){}
	    }
	}
	
	/**
     * This method will return a random color that has not been used based on the colorsToExclude boolean array from 
     * the colors array
     * 
     * @param colors            The array of colors to find a random color from
     * @param colorsToExclude   The array of flags to indicate which colors have already been used
     */
	private Color getRandomColor( Color []colors, boolean []colorsToExclude ){
	    
	    if( colors != null && 
	        colorsToExclude != null && 
	        colors.length == colorsToExclude.length ){
	        
	        Random random = new Random( System.nanoTime() );
	        int numOfColors = colors.length; 
	        int selectedColorIdx;
	        boolean allColorsUnavaliable = true;
	        for( int i = 0, size = colorsToExclude.length; i < size; ++i ){  
	            if( !colorsToExclude[i] ){
	                allColorsUnavaliable = false;
	                break;
	            }
	        }
	        if( allColorsUnavaliable ){
	            return Color.WHITE;
	        }
	        while( colorsToExclude[selectedColorIdx = random.nextInt(numOfColors)] );
	        if( colors[selectedColorIdx] != null ){
	            return colors[selectedColorIdx];
	        } else{
	            return Color.WHITE;
	        }
	    } else{
	        return Color.WHITE;
	    }
	}
	
	/**
     * This method will set tags on the TaskBar Object, retrieved from the given task
     * 
     * @param task     The Task object which will have its tags retrieved to set tags on the TaskBar Object
     */
	public void setTags( Task task ){
	    if( task != null && planner.Constants.COLOR_SERIES != null ){
	        boolean hasTags = false;
	        boolean previousTextExist = false;
	        StyledDocument doc = tagsPane.getStyledDocument();
	        Style colorStyle = tagsPane.addStyle(DEFAULT_TAGSPANE_FONT_STYLE_NAME, null);
	        StyleConstants.setItalic(colorStyle, true);
	        boolean []colorsToExclude = new boolean[planner.Constants.COLOR_SERIES.length];
	        if( task.getPriority() >= PRIORITY_ONE ){
	            int priority = task.getPriority();
	            priority = (priority <= PRIORITY_FIVE ? priority : PRIORITY_FIVE);
	            appendColoredStringsToDisplay( doc, 
	                                           colorStyle, 
	                                           getPriorityColor(planner.Constants.COLOR_SERIES, priority, colorsToExclude), 
	                                           PRIORITY_STRING + priority + SPACING );
	            previousTextExist = true;
	            hasTags = true;
	        }
	        if( task.getTag() != null && task.getTag().length() > MINIMUM_STRING_LENGTH ){
	            String divider = (previousTextExist ? TAGS_DIVIDER : EMPTY_STRING);
	            String tag = divider + task.getTag();
	            if(tag.length() > MAX_TAG_CHARACTERS){
	                tag = tag.substring(MIN_STRING_OFFSET,MAX_TAG_INDEX);
	                tag += STRING_BREAK;
	            }
	            appendColoredStringsToDisplay( doc, 
	                                           colorStyle, 
	                                           getRandomColor(planner.Constants.COLOR_SERIES, colorsToExclude), 
	                                           tag );
	            hasTags = true;
	        }
	        if( hasTags ){
	            if( !hasMovedUp ){
	                moveTitleLabelVertically( -DEFAULT_MOVE_OFFSET );
	                hasMovedUp = true;
	                hasMovedDown = false;
	            }
	        } else{
	            if( !hasMovedDown ){    
                    moveTitleLabelVertically( DEFAULT_MOVE_OFFSET ); 
                    hasMovedDown = true;
                    hasMovedUp = false;
                }
	        }
	    }
	}
    
	/**
     * Initializes and set the attributes of the TimeDisplayLabel component
     */
	private void prepareTimeDisplayLabel(){
	    timeDisplayLabel = new JLabel();
	    setNotificationImageOn();
        timeDisplayLabel.setBounds(DEFAULT_TIMEDISPLAYLABEL_RELATIVE_XCOORDINATES, 
                                   DEFAULT_TIMEDISPLAYLABEL_RELATIVE_YCOORDINATES+heightOfLabel, 
                                   DEFAULT_TIMEDISPLAYLABEL_WIDTH, DEFAULT_TIMEDISPLAYLABEL_HEIGHT);
        add(timeDisplayLabel);
        setTimeDisplayLabelAttributes(timeDisplayLabel);
        timeDisplayLabel.setText(DEFAULT_DATE_STRING);
        timeDisplayLabel.setHorizontalAlignment(SwingConstants.CENTER);
        timeDisplayLabelEx = null;
	}
	
	/**
     * Set the attributes of the TimeDisplayLabel component
     * 
     * @param targetTimeDisplayLabel    The TimeDisplayLabel component in which its attributes are to be set
     */
	private void setTimeDisplayLabelAttributes( JLabel targetTimeDisplayLabel ){
	    if( targetTimeDisplayLabel != null ){
	        targetTimeDisplayLabel.setForeground(Color.WHITE);
	        targetTimeDisplayLabel.setFont( new Font( DEFAULT_TIMEDISPLAYLABEL_FONT_FAMILY, Font.BOLD, 
	                                                  DEFAULT_TIMEDISPLAYLABEL_FONT_SIZE ) );
	    }
	}
	
	/**
     * This method compares two dates only based on their day of the month, month and year.
     * 
     * @param dateOne    The first date object to be compared with the second date object
     * @param dateTwo    The second date object to be compared with the first date object
     */
	public static boolean compareByDateOnly( Date dateOne, Date dateTwo ){
	    if( dateOne != null && dateTwo != null ){
	        Calendar c1 = Calendar.getInstance();
            Calendar c2 = Calendar.getInstance();
            c1.setTime(dateOne);
            c2.setTime(dateTwo);
            return (c1.get(Calendar.DAY_OF_MONTH) == c2.get(Calendar.DAY_OF_MONTH)) &&
                   (c1.get(Calendar.MONTH) == c2.get(Calendar.MONTH) ) &&
                   (c1.get(Calendar.YEAR) == c2.get(Calendar.YEAR));
	    } else if( dateOne != null || dateTwo != null ){
	        return false;
	    } else{
	        return true;
	    }
	}
	
	/**
     * This method display the time label for floating tasks
     */
	private void displayFloatingTimeLabel(){
	    setNotificationImageOff();
        timeDisplayLabel.setText( FLOATING_TASK_DATE_STRING );
        if( timeDisplayLabelEx != null ){
            Point currentLocation = timeDisplayLabel.getLocation();
            if( currentLocation != null ){
                timeDisplayLabel.setLocation(currentLocation.x, currentLocation.y+MOVE_OFFSET);
            }
            remove(timeDisplayLabelEx);
            timeDisplayLabelEx = null;
        }
	}
	
	/**
     * This method display the time label for done tasks
     * 
     * @param task     Task object to extract due date from to fill in the contents of the time label
     */
	private void displayDoneTimeLabel( DisplayTask task ){
	    
	    if( task != null && task.getParent() != null ){
    	    SimpleDateFormat dateFormatter = new SimpleDateFormat( DEFAULT_COMPARE_DATE_FORMAT );
            setNotificationImageOff();
            
            String time = EMPTY_STRING;
            if( task.getParent().getDateCompleted() != null ){
                time = DONE_TASK_DATE_STRING + dateFormatter.format(task.getParent().getDateCompleted());
            }
            timeDisplayLabel.setText( time );
            if( timeDisplayLabelEx != null ){
                Point currentLocation = timeDisplayLabel.getLocation();
                if( currentLocation != null ){
                    timeDisplayLabel.setLocation(currentLocation.x, currentLocation.y+MOVE_OFFSET);
                }
                remove(timeDisplayLabelEx);
                timeDisplayLabelEx = null;
            }
	    }
	}
	
	/**
     * This method display the time label for timed and deadline tasks they are displayed in chronological order
     * 
     * @param currentDate    The date (Only day of the month, month and year) that the given is classified under
     * @param task           The DisplayTask object for which dues dates of a task can be extracted from
     */
	private void displayTimeLabelByDateFormat( Date currentDate, DisplayTask task ){
	    if( currentDate != null && task != null && task.getParent() != null ){
	        SimpleDateFormat dateFormatter = new SimpleDateFormat( DEFAULT_COMPARE_DATE_FORMAT );
            SimpleDateFormat dateFormatterWithDay = new SimpleDateFormat( DISPLAY_DATE_FORMAT );
	        setNotificationImageOn();
            Date tempDate;
            if( task.getDueDate() != null && task.getEndDate() != null ){
                timeDisplayLabel.setText( FROM_DATE_STRING + dateFormatter.format(task.getDueDate()) + 
                                          TO_DATE_STRING + dateFormatter.format(task.getEndDate()) );
            } else if( task.getEndDate() != null ){
                tempDate = task.getEndDate();
                if( !compareByDateOnly( tempDate, currentDate ) ){
                    timeDisplayLabel.setText( BY_DATE_STRING + dateFormatterWithDay.format(task.getEndDate()) );
                } else{
                    timeDisplayLabel.setText( BY_DATE_STRING + dateFormatter.format(task.getEndDate()) );
                }
            } else if( task.getDueDate() != null ){
                tempDate = task.getDueDate();
                if( !compareByDateOnly( tempDate, currentDate ) ){
                    timeDisplayLabel.setText( FROM_DATE_STRING + dateFormatterWithDay.format(task.getDueDate()) );
                } else{
                    if( task.getParent().getEndDate() != null ){
                        timeDisplayLabel.setText( FROM_DATE_STRING + dateFormatter.format(task.getDueDate()) );
                    } else{
                        timeDisplayLabel.setText( BY_DATE_STRING + dateFormatter.format(task.getDueDate()) );
                    }
                }
            } else{
                setNotificationImageOff();
                timeDisplayLabel.setText( FLOATING_TASK_DATE_STRING );
            }
            if( timeDisplayLabelEx != null ){
                Point currentLocation = timeDisplayLabel.getLocation();
                if( currentLocation != null ){
                    timeDisplayLabel.setLocation(currentLocation.x, currentLocation.y+MOVE_OFFSET);
                }
                remove(timeDisplayLabelEx);
                timeDisplayLabelEx = null;
            }
	    }
	}
	
	/**
     * This method display the time label for timed and deadline tasks they are displayed br priority
     * 
     * @param task           The DisplayTask object for which dues dates of a task can be extracted from
     */
	private void displayTimeLabelByPriorityFormat( DisplayTask task ){
	    if( task != null && task.getParent() != null  ){
	        SimpleDateFormat dateFormatterWithDay = new SimpleDateFormat( DISPLAY_DATE_FORMAT );
    	    timeDisplayLabel.setHorizontalAlignment(SwingConstants.LEFT);
            setNotificationImageOff();
            if( task.getDueDate() != null && task.getEndDate() != null ){
                timeDisplayLabel.setText( FROM_DATE_STRING + dateFormatterWithDay.format(task.getDueDate()) );
                Point currentLocation = timeDisplayLabel.getLocation();
                if( timeDisplayLabelEx == null ){
                    if( currentLocation != null ){
                        timeDisplayLabel.setLocation(currentLocation.x, currentLocation.y-MOVE_OFFSET);
                    }
                } else{
                    remove(timeDisplayLabelEx);
                    timeDisplayLabelEx = null;
                }
                timeDisplayLabelEx = new JLabel();
                setTimeDisplayLabelAttributes(timeDisplayLabelEx);
                timeDisplayLabelEx.setHorizontalAlignment(SwingConstants.LEFT);
                timeDisplayLabelEx.setText(TO_DATE_STRING_II + dateFormatterWithDay.format(task.getEndDate()) );
                timeDisplayLabelEx.setBounds(currentLocation.x, currentLocation.y + MOVE_OFFSET, 
                                             timeDisplayLabel.getWidth(), timeDisplayLabel.getHeight());
                add(timeDisplayLabelEx);
                if( timeDisplayLabelEx.getParent() != null ){
                    timeDisplayLabelEx.getParent().setComponentZOrder(timeDisplayLabelEx, FIRST_COMPONENT_ORDER_INDEX);
                }
                timeDisplayLabelEx.setForeground(Color.WHITE);
            } else if( task.getEndDate() != null ){
                timeDisplayLabel.setText( BY_DATE_STRING + dateFormatterWithDay.format(task.getEndDate()) );
                if( timeDisplayLabelEx != null ){
                    Point currentLocation = timeDisplayLabel.getLocation();
                    if( currentLocation != null ){
                        timeDisplayLabel.setLocation(currentLocation.x, currentLocation.y+MOVE_OFFSET);
                    }
                    remove(timeDisplayLabelEx);
                    timeDisplayLabelEx = null;
                }
            } else if( task.getDueDate() != null ){
                if( task.getParent() != null && task.getParent().getEndDate() != null ){
                    timeDisplayLabel.setText( FROM_DATE_STRING + dateFormatterWithDay.format(task.getDueDate()) );
                } else{
                    timeDisplayLabel.setText( BY_DATE_STRING + dateFormatterWithDay.format(task.getDueDate()) );
                }
                if( timeDisplayLabelEx != null ){
                    Point currentLocation = timeDisplayLabel.getLocation();
                    if( currentLocation != null ){
                        timeDisplayLabel.setLocation(currentLocation.x, currentLocation.y+MOVE_OFFSET);
                    }
                    remove(timeDisplayLabelEx);
                    timeDisplayLabelEx = null;
                }
            } else{
                setNotificationImageOff();
                timeDisplayLabel.setText( FLOATING_TASK_DATE_STRING );
            }
	    }
	}
	
	/**
     * This method controls the way how due dates of tasks are displayed
     * 
     * @param currentDate    The date (Only day of the month, month and year) that the given is classified under
     * @param task           The DisplayTask object for which dues dates of a task can be extracted from
     */
	public void setTimeDisplayLabel( Date currentDate, DisplayTask task ){
	    if( task != null && task.getParent() != null ){
	        timeDisplayLabel.setHorizontalAlignment(SwingConstants.CENTER);
	        if( task.getParent().isFloating() ){
	            displayFloatingTimeLabel();
	        } else if( task.getParent().isDone() ){
	            displayDoneTimeLabel(task);
	        } else{
               
	            if( currentDate != null ){
	                displayTimeLabelByDateFormat(currentDate, task);
	            } else{
	                displayTimeLabelByPriorityFormat(task);
	            }
	        }
	    }
	}
	
	/**
     * Returns the preferred size of this TaskBar component
     */
    @Override
    public Dimension getPreferredSize() {
        return new Dimension(m_width, m_height+heightOfLabel);
    }
    
    /**
     * Prevents the given component from receiving inputs from mouse clicks
     * 
     * @param component     The component fow which mouse clicks events must be prevented from 
     *                      reaching it
     */
    private void removeMouseListener( Component component ){
        if( component != null ){
            component.addMouseListener( new MouseAdapter(){
                @Override
                public void mouseClicked(MouseEvent mouseEvent) {}
            });
        }
    }
	
	/**
     * Initializes and set the attributes of the background component of the TaskBar
     */
	private void prepareTaskBarBackground(){
		taskBarBackground = new JLabel();
		taskBarBackground.setBackground(Color.WHITE);
		taskBarBackground.setIcon(new ImageIcon(TaskBar.class.getResource(BACKGROUND_IMAGE_RESOURCE_LINK)));
		taskBarBackground.setFocusable(false);
		taskBarBackground.setBounds( componentCoordinates.left, componentCoordinates.top+heightOfLabel, m_width, m_height );
		add(taskBarBackground);
		removeMouseListener(taskBarBackground);
	}
	
	/**
     * This method changes the image of the taskbar to a activated task bar image
     */
	public void setFocusedTaskBar(){
		taskBarBackground.setIcon(new ImageIcon(TaskBar.class.getResource(ACTIVATED_TASKBAR_IMAGE_RESOURCE_LINK)));
	}
	

	/**
     * This method changes the image of the taskbar to a non-activated task bar image
     */
	public void setUnfocusedTaskBar(){
		taskBarBackground.setIcon(new ImageIcon(TaskBar.class.getResource(TASKBAR_IMAGE_RESOURCE_LINK)));
	}
	
	/**
     * This method removes the image used to indicate tasks with a date set from the timeDisplayLabel component
     */
	public void setNotificationImageOff(){
	    timeDisplayLabel.setIcon(null);
	}
	
	/**
     * This method adds the image used to indicate tasks with a date set from the timeDisplayLabel component
     */
	public void setNotificationImageOn(){
	    timeDisplayLabel.setIcon(new ImageIcon(TaskBar.class.getResource(TASK_WITH_DATE_IMAGE_RESOURCE_LINK)));
	}
}

	// End of segment: C:\Users\GamePro-Pc\Desktop\Work\Y2S2\CS2103\main\source\src\planner\TaskBar.java





	/**
	 * origin: C:\Users\GamePro-Pc\Desktop\Work\Y2S2\CS2103\main\source\src\planner\TranslucentTextPane.java
	 */


package planner;

import java.awt.Color;
import java.awt.Dimension;
import java.awt.Graphics;
import java.awt.Insets;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import javax.swing.JTextPane;
import javax.swing.text.AttributeSet;
import javax.swing.text.BadLocationException;
import javax.swing.text.SimpleAttributeSet;
import javax.swing.text.Style;
import javax.swing.text.StyledDocument;

/**
* The TranslucentTextPane class is a text component that can render a translucent background color for itself and automatically
* adjust its size to fit the text displayed within it.
*
	// End of segment: C:\Users\GamePro-Pc\Desktop\Work\Y2S2\CS2103\main\source\src\planner\TranslucentTextPane.java





	/**
	 * origin: C:\Users\GamePro-Pc\Desktop\Work\Y2S2\CS2103\main\source\src\planner\TranslucentTextPane.java
	 */

*/
public class TranslucentTextPane extends JTextPane{

    private Color backgroundColor_;
    
    private final String EMPTY_STRING = "";
    private final String REGEX_KEYWORD_SEPERATOR = "|";
    
    private final int MINIMUM_NONEMPTY_STRING_LENGTH = 1;
    private final int LENGTH_OF_ONE_CHARACTER_IN_STRING = 1;
    private final int MINIMUM_STRING_LENGTH = 0;
    
    /**
    * Constructs a text component that can render a translucent background color for itself and automatically
    * adjust its size to fit the text displayed within it. For a translucent background, the alpha value
    * of the backgroundColor should be set as well.
    *
    * @param backgroundColor    The background color that is going to be set for the text component.
    */
    public TranslucentTextPane( Color backgroundColor ){
        setOpaque(false);
        if( backgroundColor != null ){
            backgroundColor_ = backgroundColor;
        } else{
            backgroundColor_ = Color.BLACK;
        }
        setEditorKit(new CustomWrapKit());
    }
    
    /**
     * Sets the text component to be opaque or not. In this case, this method will prevent the text
     * component to be set as opaque.
     *
     * @param isOpaque    Flag to indicate if text component is to be set to be opaque or not
     */
    @Override
    public void setOpaque( boolean isOpaque ){
        super.setOpaque(false);
    }
    
    /**
     * Renders the appearance of the text field component and text within it;
     *
     * @param graphics  Component that provide access to rendering information and the rendering of the text field component
     */
    @Override
    public void paintComponent( Graphics graphics ){
        
        graphics.setColor(backgroundColor_);
        Insets posAttribute = getInsets();
        int yCoordinate = posAttribute.top;
        int xCoordinate = posAttribute.left;
        int componentWidth = getWidth() - posAttribute.right - posAttribute.left;
        int componentHeight = getHeight() - posAttribute.bottom - posAttribute.top;
        graphics.fillRoundRect(xCoordinate, yCoordinate, componentWidth, componentHeight, 10, 10);
        super.paintComponent(graphics);
    }
    
    /**
     * Adjusts the text component's size to fit the text displayed within it
     */
    public void adjustComponentSizeToFitText(){
        int newHeightOfComponent = (getPreferredSize() != null ? getPreferredSize().height : getHeight());
        super.setSize(getWidth(), newHeightOfComponent);
    }
    
    /**
     * Sets the text to be displayed in this text component. The text component will then adjust its size to fit the text. This
     * method will overwrite any text previously displayed within this text component.
     * 
     * @param text  The text to be displayed in this text component
     */
    @Override
    public void setText( String text ){
        setSize(getWidth(), Short.MAX_VALUE);
        super.setText(text);
        adjustComponentSizeToFitText();
    }
    
    /**
     * Sets the appropriate attributes of the text component so that the appropriate text component's size can be accurately 
     * calculated by adjustComponentSizeToFitText() method to fit the text displayed within it. NOTE: This method should be 
     * called before calling the adjustComponentSizeToFitText() method.
     */
    public void initialiseForResize(){
        setSize(getWidth(), Short.MAX_VALUE);
    }
    
    /**
     * Inserts the text at the end of the document displayed in this text component. This method will not resize the text component
     * to fit the text. If resizing text component is necessary, the user should call the initialiseForResize() method -> this method ->
     * adjustComponentSizeToFitText() method to adjust its size to fit the text displayed within it.
     * 
     * @param text      The text to be appended to the document displayed in this text component
     * @param style     The font style of the appended text to be rendered in
     */
    public void appendText( String text, AttributeSet style ){
        try {
            if( text != null ){
                StyledDocument doc = getStyledDocument();
                doc.insertString(doc.getLength(), text, style);
                doc.setCharacterAttributes(doc.getLength(), doc.getLength()+1, style, false);
            }
        } catch (BadLocationException e) {}
    }
    
    
    /**
     * Generates a regex pattern without word boundaries from the list of keywords given. Null keywords will not be included
     * in the generated regex pattern.
     * 
     * @param keywords      List of keywords to be compiled into a regex pattern without word boundaries
     * @return              The regex pattern generated from the list of keywords given
     */
    private String generateRegexWithoutWordBoundary( String []keywords ){
        StringBuilder regex = new StringBuilder(EMPTY_STRING);
        if( keywords != null ){
            for( int i = 0, size = keywords.length; i < size; ++i ){
                if( keywords[i] != null ){
                    regex.append(keywords[i]).append(REGEX_KEYWORD_SEPERATOR);
                }
            }
            if( regex.length() > MINIMUM_NONEMPTY_STRING_LENGTH ){
                regex.deleteCharAt(regex.length()-LENGTH_OF_ONE_CHARACTER_IN_STRING);
            }
        }
        return regex.toString();
    }
    
    /**
     * Renders the keywords that are found in the list with the given style
     * 
     * @param list     List of keywords to be syntax colour with the given style
     * @param style    The style that the keywords will be rendered in
     */
    public void highlightWords( String []list, SimpleAttributeSet style ){
         try {
            if( list != null && list.length > MINIMUM_STRING_LENGTH ){
                StyledDocument doc = getStyledDocument();
                if( doc != null && doc.getLength() > MINIMUM_STRING_LENGTH ){
                    String regex = generateRegexWithoutWordBoundary(list);
                    Pattern pattern = Pattern.compile(regex);
                    String currentString = doc.getText(MINIMUM_STRING_LENGTH, doc.getLength()); 
                    Matcher matcher = pattern.matcher(currentString);
                    
                    int startIdx;
                    int endIdx;
                    while( matcher.find() ){
                        startIdx = matcher.start();
                        endIdx = matcher.end();
                        doc.setCharacterAttributes(startIdx, endIdx-startIdx, style, true);
                    }
                }
            }
        } catch (BadLocationException e) {}
    }
}

	// End of segment: C:\Users\GamePro-Pc\Desktop\Work\Y2S2\CS2103\main\source\src\planner\TranslucentTextPane.java





	/**
	 * origin: C:\Users\GamePro-Pc\Desktop\Work\Y2S2\CS2103\main\source\src\planner\UserInterface.java
	 */


package planner;

import java.awt.Color;
import java.awt.Cursor;
import java.awt.EventQueue;
import java.awt.Font;
import java.awt.event.FocusEvent;
import java.awt.event.FocusListener;
import java.awt.event.KeyAdapter;
import java.awt.event.KeyEvent;
import java.awt.event.KeyListener;
import java.awt.event.MouseEvent;
import java.awt.event.MouseMotionAdapter;
import java.awt.event.WindowAdapter;
import java.awt.event.WindowEvent;
import java.util.AbstractMap;
import java.util.ArrayList;
import java.util.Date;
import java.util.Iterator;
import java.util.Map;
import java.util.Set;
import java.util.logging.Logger;

import javax.swing.ImageIcon;
import javax.swing.JComboBox;
import javax.swing.JFrame;
import javax.swing.JLabel;
import javax.swing.JOptionPane;
import javax.swing.JPanel;
import javax.swing.JScrollBar;
import javax.swing.JScrollPane;
import javax.swing.JTextPane;
import javax.swing.SwingConstants;
import javax.swing.event.MouseInputAdapter;
import javax.swing.text.BadLocationException;
import javax.swing.text.SimpleAttributeSet;
import javax.swing.text.Style;
import javax.swing.text.StyleConstants;
import javax.swing.text.StyledDocument;

import planner.Constants.CommandType;
import planner.Constants.DisplayStateFlag;

// This class handles all GUI logic and processing
public class UserInterface extends JFrame {

    private JPanel contentPane;
    private JPanel slidePanelFrame;
    
    private SliderPanel infoPanel;
    private SliderPanel lastCommandPanel;
    
    private CommandTextbox commandPanel;
    private JTextPane commandInputField;
    
    private DisplayPane displayPane;
    
    private JLabel closeButton;
    private JLabel minimiseButton;
    private JLabel dragPanel;
    private JLabel sectionTitle;
    private JLabel sectionTitleLine;
    private JLabel background;
    
    private InvisibleButton upArrowButton;
    private InvisibleButton downArrowButton;
    
    private JTextPane taskDisplayPanel;
    private JTextPane navigationPanel;
    
    // Used for drag logic
    private int mouseXCoordinate;
    private int mouseYCoordinate;
    
    private int caretPositionToAppendLastCommandString;
    
    private DisplayTaskList currentList;
    
    private Set<Map.Entry<Integer, DisplayTaskList>> currentDisplayListForPriority;
    private Set<Map.Entry<Date, DisplayTaskList>> currentDisplayListForDate;
    
    private boolean isMessageDisplayed;
    
    private ArrayList<NavigationBar> currentNavigationBars;
    
    private final static Logger userInterfaceLogger = Logger.getLogger(UserInterface.class.getName());
    
    private char characterToTransfer;
    private boolean isBackspacePressed;

    private int messageType;  // 0 - success message, 1 - error message, anything else - normal message
    
    private JComboBox<String> popupBox;
    
    private DisplayStateStack displayStateStack;
    private final int maxNumOfDisplayStates = 100;
    
    private InputList inputList;
    private final int MAX_INPUT_LIST_SIZE = 1000;
    
    public void processCommand( String input ){
        
        planner.Constants.CommandType commandType = Engine.process(input);
        
        switch( commandType ){
        
            case ADD:
                
                handleAddOperation();
                
                break;
                
            case ADD_CLASH:
                
                handleAddClashOperation();
                
                break;
                
            case UPDATE:
                
                handleUpdateOperation();
                
                break;
                
            case DELETE:
                
                handleDeleteOperation();
                
                break;
                
            case DONE:
                    
                handleDoneOperation();
                
                break;
                
            case INVALID:
                
                handleInvalidOperation();
                
                break;
                
            case SEARCH:
                
                handleSearch( input, false );
                
                break;
            
            case SETNOTDONE:
                
                handleSetNotDone();
                
                break;
                
            case UNDO:
                
                handleUndo();
                
                break;
                
            case CONVERT_FLOATING:
                
                handleConvertToFloatingTaskOperation();
                
                break;
                
            case CONVERT_DEADLINE:
                
                handleConvertToDeadlineTaskOperation();
                
                break;
                
            case CONVERT_TIMED:
                
                handleConvertToTimedTaskOperation();
                
                break;
                
            case SAVEWHERE:
                
                handleSaveWhere(input, false);
                
                break;
                
            case SAVEHERE:
                
                handleSaveHere(false);
                
                break;
            
            case HELP:
                
                showTutorialScreen( -1, input, false );
                
                break;
                
            case HELP_ADD:
            
                showTutorialScreen( Constants.ADD_TUTORIAL, input, false );
                
                break;
                
            case HELP_DELETE:
                
                showTutorialScreen( Constants.DELETE_TUTORIAL, input, false );
                
                break;
                
            case HELP_UPDATE:
                
                showTutorialScreen( Constants.UPDATE_TUTORIAL, input, false );
                
                break;
                
            case HELP_DONE:
                
                showTutorialScreen( Constants.DONE_TUTORIAL, input, false );
                
                break;
                
            case HELP_SEARCH:
                
                showTutorialScreen( Constants.SEARCH_TUTORIAL, input, false );
                
                break;
                
            case HELP_UNDO:
                
                showTutorialScreen( Constants.UNDO_TUTORIAL, input, false );
                
                break;
             
            case EXIT:
                
                handleExit();
                
                break;
            
            default:
                
                handleUnexpectedOperation();
            
                break;
        }
        
        
        if( commandInputField != null ){
            
            String msg = commandInputField.getText();
            updateCommandPanel( input, msg, messageType );
        }
        
        if( inputList != null ){
   
            inputList.resetGetWordPosition();
            
            inputList.addWordToList(input);
        }
    }
    
    private void handleExit(){
        
        Engine.exit();
        System.exit(0);
    }
    
    private void handleSaveWhere(String userInput, boolean isAPrevCall ){
        
        displayStateStack.push(new DisplayState( planner.Constants.DisplayStateFlag.SETTINGS, 
                "YOPO's Settings", 
                userInput, null ) );
        
        DisplayState currentDisplayState =  displayStateStack.peek();
        DisplayState upcomingDisplayState = updateCurrentList( currentDisplayState );
        
        String sectionTitleString = upcomingDisplayState.getTitle();
        
        updateGUIView( currentDisplayListForDate, currentDisplayListForPriority, sectionTitleString, null );
        
        String fileSavePath = Engine.getStoragePath();
        
        displayPane.showMessageOnDisplay(" YOPO's Current File Storage Location:\n\n " + fileSavePath);
        
        if( !isAPrevCall ){
            
            messageType = 2;
            isMessageDisplayed = true;
            commandPanel.setText( "Enter commands here", true );
        }
    }
    
    private void handleSaveHere( boolean isAPrevCall ){
        
        displayStateStack.push(new DisplayState( planner.Constants.DisplayStateFlag.SETTINGS, 
                "YOPO's Settings", 
                "savewhere", null ) );
        
        DisplayState currentDisplayState =  displayStateStack.peek();
        DisplayState upcomingDisplayState = updateCurrentList( currentDisplayState );
        
        String sectionTitleString = upcomingDisplayState.getTitle();
        
        updateGUIView( currentDisplayListForDate, currentDisplayListForPriority, sectionTitleString, null );
        
        String fileSavePath = Engine.getStoragePath();
        
        displayPane.showMessageOnDisplay(" YOPO's Current File Storage Location:\n\n " + fileSavePath);
        
        if( !isAPrevCall ){
                
            messageType = 0;
            isMessageDisplayed = true;
            commandPanel.setText( "YOPO's file storage location changed successfully", true );
        }
    }
    
    private void handleUndo(){
        
        DisplayState currentDisplayState =  displayStateStack.peek();
        DisplayState upcomingDisplayState = updateCurrentList( currentDisplayState );
        
        String sectionTitleString = upcomingDisplayState.getTitle();
        
        if( currentDisplayState.getdisplayStateFlag() != upcomingDisplayState.getdisplayStateFlag() ){
            
            displayStateStack.push(upcomingDisplayState);
        }
        
        updateGUIView( currentDisplayListForDate, currentDisplayListForPriority, sectionTitleString, null );
        
        messageType = 0;
        isMessageDisplayed = true;
        commandPanel.setText( "Previous keyboard command undone successfully", true );
    }
    
    private void handleSetNotDone(){
        
        DisplayState currentDisplayState =  displayStateStack.peek();
        DisplayState upcomingDisplayState = updateCurrentList( currentDisplayState );
        
        String sectionTitleString = upcomingDisplayState.getTitle();
        
        int modifiedTaskID = Engine.lastModifiedTask();
        DisplayTask modifiedTask = (currentList != null ? currentList.getTaskByParentID(modifiedTaskID) : null);
        
        if( modifiedTask != null ){
            
            if( currentDisplayState.getdisplayStateFlag() != upcomingDisplayState.getdisplayStateFlag() ){
                
                displayStateStack.push(upcomingDisplayState);
            }
            
            updateGUIView( currentDisplayListForDate, currentDisplayListForPriority, sectionTitleString, modifiedTask.getParent() );
            
        } else{
            
            if( currentDisplayState.getdisplayStateFlag() != DisplayStateFlag.ALL ){
                
                Set<Map.Entry<Date, DisplayTaskList>> tempTaskList = Engine.getAllTasks();
                
                modifiedTask = getDisplayTaskByParentID(tempTaskList, modifiedTaskID);
                
                if( modifiedTask != null ){
                    
                    currentList = convertToDisplayTaskList(tempTaskList);
                    currentDisplayListForDate = tempTaskList;
                    currentDisplayListForPriority = null;
                    
                    displayStateStack.push(upcomingDisplayState);
                    
                    updateGUIView( currentDisplayListForDate, currentDisplayListForPriority, "All Tasks", modifiedTask.getParent() );
                    
                } else{
                    
                    messageType = 1;
                    isMessageDisplayed = true;
                    commandPanel.setText( "Fail to mark task as not done", true );
                    
                    return;
                }
                
            } else{
                
                messageType = 1;
                isMessageDisplayed = true;
                commandPanel.setText( "Fail to mark task as not done", true );
                
                return;
            }
        }

        messageType = 0;
        isMessageDisplayed = true;
        commandPanel.setText( "Task #" + modifiedTaskID + " marked not done successfully", true );
    }
    
    private void handleSearch( String userInput, boolean isAPrevCall ){
        
        Set<Map.Entry<Date, DisplayTaskList>> tempList = Engine.getSearchResult();
        
        DisplayTaskList tempTaskList = convertToDisplayTaskList(tempList);
        Task tempTask;
        
        if( tempTaskList != null ){
            
            currentList = tempTaskList;
            currentDisplayListForDate = tempList;
            currentDisplayListForPriority = null;
            
            displayStateStack.push(new DisplayState( planner.Constants.DisplayStateFlag.WORD_SEARCH, userInput, userInput, null ));
            
            tempTask = displayPane.getCurrentSelectedTask() != null ? displayPane.getCurrentSelectedTask().getParent() : null;
            
            updateGUIView(currentDisplayListForDate, currentDisplayListForPriority, userInput, tempTask);
           
            if( displayPane.hasTasksDisplayed() ){
                
                if( !isAPrevCall ){
                    
                    messageType = 0;
                    isMessageDisplayed = true;
                    commandPanel.setText( "Search success", true );
                }
                
                return;
            }
        }
        
        displayPane.showMessageOnDisplay(" There are no tasks containing your search phrase");
        
        if( !isAPrevCall ){
            
            messageType = 1;
            isMessageDisplayed = true;
            commandPanel.setText( "We cannot find any task containing the search phrase :/", true );
        }
    }
    
    private void updateGUIView( Set<Map.Entry<Date, DisplayTaskList>> dateDisplayList, 
                                Set<Map.Entry<Integer, DisplayTaskList>> priorityDisplayList,
                                String sectionTitleString, Task task){
        
        displayPane.clearDisplay();
        
        if( dateDisplayList != null ){
            
            displayPane.displayByDate(dateDisplayList);
            
        } else if( priorityDisplayList != null ){
            
            displayPane.displayByPriority(priorityDisplayList);
        } 
        
        updateGUIView( sectionTitleString, task );
    }
    
    private void updateGUIView( String sectionTitleString, Task task ){
        
        displayPane.selectGivenTask(task);
        
        currentNavigationBars = generateContentForNavigationBars( displayStateStack.peek() );
        addNavigationBarsToPanel(currentNavigationBars);
        
        if( task != null ){
            
            infoPanel.populateDisplay(task);
            
        } else{
            
            if( displayPane.getCurrentSelectedTask() != null && displayPane.getCurrentSelectedTask().getParent() != null ){
                
                infoPanel.populateDisplay(displayPane.getCurrentSelectedTask().getParent());
            }
        }
        
        if(sectionTitleString != null){
            
            sectionTitle.setText(sectionTitleString);
        }
        
        if( !displayPane.hasTasksDisplayed() ){
            
            infoPanel.slideIn();
        }
    }
    
    private <T>DisplayTaskList convertToDisplayTaskList( Set<Map.Entry<T, DisplayTaskList>> displayList ){
        
        DisplayTaskList newDisplayTaskList = new DisplayTaskList();
        
        if( displayList != null ){
            
            DisplayTaskList tempDisplayTaskList;
            
            for( Map.Entry<T, DisplayTaskList> entry : displayList ){
                
                tempDisplayTaskList = entry.getValue();
                
                if( tempDisplayTaskList != null ){
                    
                    for( DisplayTask tempDisplayTask : tempDisplayTaskList ){
                        
                        if( tempDisplayTask != null ){
                            
                            newDisplayTaskList.add(tempDisplayTask);
                        }
                    }
                }
            }
        }
        
        return newDisplayTaskList;
    }
    
    private <T>DisplayTask getDisplayTaskByParentID( Set<Map.Entry<T, DisplayTaskList>> displayList, int parentID ){
        
        if( displayList != null ){
            
            DisplayTaskList tempDisplayTaskList;
            
            for( Map.Entry<T, DisplayTaskList> entry : displayList ){
                
                tempDisplayTaskList = entry.getValue();
                
                if( tempDisplayTaskList != null ){
                    
                    for( DisplayTask tempDisplayTask : tempDisplayTaskList ){
                        
                        if( tempDisplayTask != null && tempDisplayTask.getParent() != null &&
                            tempDisplayTask.getParent().getID() == parentID){
                            
                            return tempDisplayTask;
                        }
                    }
                }
            }
        }
        
        return null;
    }
    
    private DisplayState updateCurrentList( DisplayState currentDisplayState ){
        
        if( currentDisplayState != null ){
            
            DisplayStateFlag currentDisplayStateFlag  = currentDisplayState.getdisplayStateFlag();
            
            String searchString;
            
            switch(currentDisplayStateFlag){
            
                case TENTATIVE:
                    
                    currentDisplayListForPriority = Engine.getFloatingTasks();
                    currentDisplayListForDate = null;
                    
                    currentList = convertToDisplayTaskList( currentDisplayListForPriority );
                    
                    return currentDisplayState;
                    
                case TODAY:
                    
                    currentDisplayListForPriority = Engine.getTodayTasks();
                    currentDisplayListForDate = null;
                    
                    currentList = convertToDisplayTaskList( currentDisplayListForPriority );
                    
                    return currentDisplayState;
                    
                case OVERDUE:
                    
                    currentDisplayListForPriority = null;
                    currentDisplayListForDate = Engine.getOverdueTasks();
                    
                    currentList = convertToDisplayTaskList( currentDisplayListForDate );
                    
                    return currentDisplayState;
                    
                case UPCOMING:
                    
                    currentDisplayListForPriority = null;
                    currentDisplayListForDate = Engine.getUpcomingTasks();
                    
                    currentList = convertToDisplayTaskList( currentDisplayListForDate );
                    
                    return currentDisplayState;
                    
                case NOTDONE:
                    
                    currentDisplayListForPriority = null;
                    currentDisplayListForDate = Engine.getUndoneTasks();
                    
                    currentList = convertToDisplayTaskList( currentDisplayListForDate );
                    
                    return currentDisplayState;
                
                case DONE:
                    
                    currentDisplayListForPriority = null;
                    currentDisplayListForDate = Engine.getDoneTasks();
                    
                    currentList = convertToDisplayTaskList( currentDisplayListForDate );
                    
                    return currentDisplayState;
                    
                case WORD_SEARCH:
                    
                    searchString = currentDisplayState.getCommand();
                    
                    if ( Engine.process(searchString) == CommandType.SEARCH ){
                        
                        currentDisplayListForPriority = null;
                        currentDisplayListForDate = Engine.getSearchResult();
                        
                        currentList = convertToDisplayTaskList(currentDisplayListForDate);

                        return currentDisplayState;
                    } 

                    break;
                    
                case HELP:
                case HELP_ADD:
                case HELP_UPDATE:
                case HELP_DELETE:
                case HELP_DONE:
                case HELP_UNDO:
                case HELP_SEARCH:
                case HELP_PRIORITY_SEARCH:
                case SETTINGS:
                    
                    currentDisplayListForPriority = null;
                    currentDisplayListForDate = null;
                    
                    currentList = null;
                    
                    return currentDisplayState;
                    
                default:
                    
                    break;
            }
        }
            
        currentDisplayListForPriority = null;
        currentDisplayListForDate = Engine.getAllTasks();
        
        currentList = convertToDisplayTaskList(currentDisplayListForDate);
        
        return new DisplayState( planner.Constants.DisplayStateFlag.ALL, "All tasks", null, 
                                 new KeyEvent( displayPane, KeyEvent.KEY_PRESSED, System.currentTimeMillis(),
                                 0, KeyEvent.VK_F5, '\0', KeyEvent.KEY_LOCATION_STANDARD) ); 
    }
    
    private void handleAddOperation(){
        
        DisplayState currentDisplayState =  displayStateStack.peek();
        DisplayState upcomingDisplayState = updateCurrentList( currentDisplayState );
        
        String sectionTitleString = upcomingDisplayState.getTitle();
        
        int modifiedTaskID = Engine.lastModifiedTask();
        
        DisplayTask modifiedTask = (currentList != null ? currentList.getTaskByParentID(modifiedTaskID) : null);
        
        if( modifiedTask != null ){
            
            if( currentDisplayState.getdisplayStateFlag() != upcomingDisplayState.getdisplayStateFlag() ){
                
                displayStateStack.push(upcomingDisplayState);
            }
            
            updateGUIView( currentDisplayListForDate, currentDisplayListForPriority, sectionTitleString, modifiedTask.getParent() );
            
        } else{
            
            if( currentDisplayState.getdisplayStateFlag() != DisplayStateFlag.ALL ){
                
                Set<Map.Entry<Date, DisplayTaskList>> tempTaskList = Engine.getAllTasks();
                
                modifiedTask = getDisplayTaskByParentID(tempTaskList, modifiedTaskID);
                
                if( modifiedTask != null ){
                    
                    currentList = convertToDisplayTaskList(tempTaskList);
                    currentDisplayListForDate = tempTaskList;
                    currentDisplayListForPriority = null;
                    
                    displayStateStack.push(upcomingDisplayState);
                    
                    updateGUIView( currentDisplayListForDate, currentDisplayListForPriority, "All Tasks", modifiedTask.getParent() );
                    
                } else{
                    
                    messageType = 1;
                    isMessageDisplayed = true;
                    commandPanel.setText( "Failed to add task", true );
                    
                    return;
                }
                
            } else{
                
                messageType = 1;
                isMessageDisplayed = true;
                commandPanel.setText( "Failed to add task", true );
                
                return;
            }
        }

        messageType = 0;
        isMessageDisplayed = true;
        commandPanel.setText( "Task #"+ modifiedTaskID + " added successfully", true );
    }
    
    private void handlePreviousViewOperation( DisplayStateStack displayStateStack ){
        
        if( displayStateStack != null && displayStateStack.size() > 1 ){
            
            DisplayState currentDisplayState = displayStateStack.pop();
            DisplayState previousDisplayState = displayStateStack.pop();
            
            displayStateStack.push(currentDisplayState);
            
            if( previousDisplayState != null ){
                
                boolean isValidDisplayState = false;
                
                KeyEvent keyEvent = previousDisplayState.getKeyEvent();
                String userCommand = previousDisplayState.getCommand();
                
                if( keyEvent != null ){
                    
                    handleKeyEvent(keyEvent);
                    
                    isValidDisplayState = true;
                    
                } else if( userCommand != null ){
                    
                    updateCurrentList(previousDisplayState);
                    
                    switch( Engine.process(userCommand) ){
                    
                        case SEARCH:
                            
                            handleSearch(userCommand, true);
                            
                            break;
                            
                        case SAVEWHERE:
                            
                            handleSaveWhere(userCommand, true);
                            
                            break;
                            
                        case SAVEHERE:
                            
                            handleSaveWhere(userCommand, true);
                            
                            break;
                            
                        case HELP:
                            
                            showTutorialScreen(-1, userCommand, true );
                            
                            break;
                            
                        case HELP_ADD:
                            
                            showTutorialScreen(Constants.ADD_TUTORIAL, userCommand, true );
                            
                            break;
                            
                        case HELP_UPDATE:
                            
                            showTutorialScreen(Constants.UPDATE_TUTORIAL, userCommand, true );
                            
                            break;
                            
                        case HELP_DELETE:
                            
                            showTutorialScreen(Constants.DELETE_TUTORIAL, userCommand, true );
                            
                            break;
                            
                        case HELP_DONE:
                            
                            showTutorialScreen(Constants.DONE_TUTORIAL, userCommand, true );
                            
                            break;
                            
                        case HELP_UNDO:
                            
                            showTutorialScreen(Constants.UNDO_TUTORIAL, userCommand, true );
                            
                            break;
                            
                        case HELP_SEARCH:
                            
                            showTutorialScreen(Constants.SEARCH_TUTORIAL, userCommand, true );
                            
                            break;
                            
                        default:
                            
                            break;
                    }
                    
                    isValidDisplayState = true;
                }
                
                if( isValidDisplayState ){
                    
                    DisplayState newCurrentDisplayState = displayStateStack.pop();
                    
                    // Removed old current state
                    displayStateStack.pop();
                    
                    if( newCurrentDisplayState != null ){
                        
                        displayStateStack.push(newCurrentDisplayState);
                    }
                    
                    currentNavigationBars = generateContentForNavigationBars( displayStateStack.peek() );
                    addNavigationBarsToPanel(currentNavigationBars);
                }
            }
        }
    }
    
    private void handleAddClashOperation(){
        
        DisplayState currentDisplayState =  displayStateStack.peek();
        DisplayState upcomingDisplayState = updateCurrentList( currentDisplayState );
        
        String sectionTitleString = upcomingDisplayState.getTitle();
        
        int modifiedTaskID = Engine.lastModifiedTask();
        
        DisplayTask modifiedTask = (currentList != null ? currentList.getTaskByParentID(modifiedTaskID) : null);
        
        if( modifiedTask != null ){
            
            if( currentDisplayState.getdisplayStateFlag() != upcomingDisplayState.getdisplayStateFlag() ){
                
                displayStateStack.push(upcomingDisplayState);
            }
            
            updateGUIView( currentDisplayListForDate, currentDisplayListForPriority, sectionTitleString, modifiedTask.getParent() );
            
        } else{
            
            if( currentDisplayState.getdisplayStateFlag() != DisplayStateFlag.ALL ){
                
                Set<Map.Entry<Date, DisplayTaskList>> tempTaskList = Engine.getAllTasks();
                
                modifiedTask = getDisplayTaskByParentID(tempTaskList, modifiedTaskID);
                
                if( modifiedTask != null ){
                    
                    currentList = convertToDisplayTaskList(tempTaskList);
                    currentDisplayListForDate = tempTaskList;
                    currentDisplayListForPriority = null;
                    
                    displayStateStack.push(upcomingDisplayState);
                    
                    updateGUIView( currentDisplayListForDate, currentDisplayListForPriority, "All Tasks", modifiedTask.getParent() );
                    
                } else{
                    
                    messageType = 1;
                    isMessageDisplayed = true;
                    commandPanel.setText( "Failed to add task", true );
                    
                    return;
                }
                
            } else{
                
                messageType = 1;
                isMessageDisplayed = true;
                commandPanel.setText( "Failed to add task", true );
                
                return;
            }
        }

        int conflictTaskID = Engine.getClashingTask();
        
        messageType = 1;
        isMessageDisplayed = true;
        commandPanel.setText( "Task #" + modifiedTaskID + " conflicts with task #" + conflictTaskID, true );
    }
    
    private void handleConvertToTimedTaskOperation(){
        
        DisplayState currentDisplayState =  displayStateStack.peek();
        DisplayState upcomingDisplayState = updateCurrentList( currentDisplayState );
        
        String sectionTitleString = upcomingDisplayState.getTitle();
        
        int modifiedTaskID = Engine.lastModifiedTask();
        DisplayTask modifiedTask = (currentList != null ? currentList.getTaskByParentID(modifiedTaskID) : null);
        
        if( modifiedTask != null ){
            
            if( currentDisplayState.getdisplayStateFlag() != upcomingDisplayState.getdisplayStateFlag() ){
                
                displayStateStack.push(upcomingDisplayState);
            }
            
            updateGUIView( currentDisplayListForDate, currentDisplayListForPriority, sectionTitleString, modifiedTask.getParent() );
            
        } else{
            
            if( currentDisplayState.getdisplayStateFlag() != DisplayStateFlag.ALL ){
                
                Set<Map.Entry<Date, DisplayTaskList>> tempTaskList = Engine.getAllTasks();
                
                modifiedTask = getDisplayTaskByParentID(tempTaskList, modifiedTaskID);
                
                if( modifiedTask != null ){
                    
                    currentList = convertToDisplayTaskList(tempTaskList);
                    currentDisplayListForDate = tempTaskList;
                    currentDisplayListForPriority = null;
                    
                    displayStateStack.push(upcomingDisplayState);
                    
                    updateGUIView( currentDisplayListForDate, currentDisplayListForPriority, "All Tasks", modifiedTask.getParent() );
                    
                } else{
                    
                    messageType = 1;
                    isMessageDisplayed = true;
                    commandPanel.setText( "Failed to convert task into a deadline task", true );
                    
                    return;
                }
            }
        }
        
        messageType = 0;
        isMessageDisplayed = true;
        commandPanel.setText( "Task #" + modifiedTaskID + " converted into a deadline task successfully", true );
    }
    
    private void handleConvertToDeadlineTaskOperation(){
        
        DisplayState currentDisplayState =  displayStateStack.peek();
        DisplayState upcomingDisplayState = updateCurrentList( currentDisplayState );
        
        String sectionTitleString = upcomingDisplayState.getTitle();
        
        int modifiedTaskID = Engine.lastModifiedTask();
        DisplayTask modifiedTask = (currentList != null ? currentList.getTaskByParentID(modifiedTaskID) : null);
        
        if( modifiedTask != null ){
            
            if( currentDisplayState.getdisplayStateFlag() != upcomingDisplayState.getdisplayStateFlag() ){
                
                displayStateStack.push(upcomingDisplayState);
            }
            
            updateGUIView( currentDisplayListForDate, currentDisplayListForPriority, sectionTitleString, modifiedTask.getParent() );
            
        } else{
            
            if( currentDisplayState.getdisplayStateFlag() != DisplayStateFlag.ALL ){
                
                Set<Map.Entry<Date, DisplayTaskList>> tempTaskList = Engine.getAllTasks();
                
                modifiedTask = getDisplayTaskByParentID(tempTaskList, modifiedTaskID);
                
                if( modifiedTask != null ){
                    
                    currentList = convertToDisplayTaskList(tempTaskList);
                    currentDisplayListForDate = tempTaskList;
                    currentDisplayListForPriority = null;
                    
                    displayStateStack.push(upcomingDisplayState);
                    
                    updateGUIView( currentDisplayListForDate, currentDisplayListForPriority, "All Tasks", modifiedTask.getParent() );
                    
                } else{
                    
                    messageType = 1;
                    isMessageDisplayed = true;
                    commandPanel.setText( "Failed to convert task into a deadline task", true );
                    
                    return;
                }
            }
        }
        
        messageType = 0;
        isMessageDisplayed = true;
        commandPanel.setText( "Task #" + modifiedTaskID + " converted into a deadline task successfully", true );
    }
    
    private void handleConvertToFloatingTaskOperation(){
        
        DisplayState currentDisplayState =  displayStateStack.peek();
        DisplayState upcomingDisplayState = updateCurrentList( currentDisplayState );
        
        String sectionTitleString = upcomingDisplayState.getTitle();
        
        int modifiedTaskID = Engine.lastModifiedTask();
        DisplayTask modifiedTask = (currentList != null ? currentList.getTaskByParentID(modifiedTaskID) : null);
        
        if( modifiedTask != null ){
            
            if( currentDisplayState.getdisplayStateFlag() != upcomingDisplayState.getdisplayStateFlag() ){
                
                displayStateStack.push(upcomingDisplayState);
            }
            
            updateGUIView( currentDisplayListForDate, currentDisplayListForPriority, sectionTitleString, modifiedTask.getParent() );
            
        } else{
            
            if( currentDisplayState.getdisplayStateFlag() != DisplayStateFlag.ALL ){
                
                Set<Map.Entry<Date, DisplayTaskList>> tempTaskList = Engine.getAllTasks();
                
                modifiedTask = getDisplayTaskByParentID(tempTaskList, modifiedTaskID);
                
                if( modifiedTask != null ){
                    
                    currentList = convertToDisplayTaskList(tempTaskList);
                    currentDisplayListForDate = tempTaskList;
                    currentDisplayListForPriority = null;
                    
                    displayStateStack.push(upcomingDisplayState);
                    
                    updateGUIView( currentDisplayListForDate, currentDisplayListForPriority, "All Tasks", modifiedTask.getParent() );
                    
                } else{
                    
                    messageType = 1;
                    isMessageDisplayed = true;
                    commandPanel.setText( "Failed to convert task into a floating task", true );
                    
                    return;
                }
            }
        }
        
        messageType = 0;
        isMessageDisplayed = true;
        commandPanel.setText( "Task #" + modifiedTaskID + " converted into a floating task successfully", true );
    }
    
    private void handleUpdateOperation(){
        
        DisplayState currentDisplayState =  displayStateStack.peek();
        DisplayState upcomingDisplayState = updateCurrentList( currentDisplayState );
        
        String sectionTitleString = upcomingDisplayState.getTitle();
        
        int modifiedTaskID = Engine.lastModifiedTask();
        DisplayTask modifiedTask = (currentList != null ? currentList.getTaskByParentID(modifiedTaskID) : null);
        
        if( modifiedTask != null ){
            
            if( currentDisplayState.getdisplayStateFlag() != upcomingDisplayState.getdisplayStateFlag() ){
                
                displayStateStack.push(upcomingDisplayState);
            }
            
            updateGUIView( currentDisplayListForDate, currentDisplayListForPriority, sectionTitleString, modifiedTask.getParent() );
            
        } else{
            
            if( currentDisplayState.getdisplayStateFlag() != DisplayStateFlag.ALL ){
                
                Set<Map.Entry<Date, DisplayTaskList>> tempTaskList = Engine.getAllTasks();
                
                modifiedTask = getDisplayTaskByParentID(tempTaskList, modifiedTaskID);
                
                if( modifiedTask != null ){
                    
                    currentList = convertToDisplayTaskList(tempTaskList);
                    currentDisplayListForDate = tempTaskList;
                    currentDisplayListForPriority = null;
                    
                    displayStateStack.push(upcomingDisplayState);
                    
                    updateGUIView( currentDisplayListForDate, currentDisplayListForPriority, "All Tasks", modifiedTask.getParent() );
                    
                } else{
                    
                    messageType = 1;
                    isMessageDisplayed = true;
                    commandPanel.setText( "Failed to update task", true );
                    
                    return;
                }
                
            } else{
                
                messageType = 1;
                isMessageDisplayed = true;
                commandPanel.setText( "Failed to update task", true );
                
                return;
            }
        }

        messageType = 0;
        isMessageDisplayed = true;
        commandPanel.setText( "Task #" + modifiedTaskID + " updated successfully", true );
    }
    
    private void handleDoneOperation(){
        
        DisplayState currentDisplayState =  displayStateStack.peek();
        DisplayState upcomingDisplayState = updateCurrentList( currentDisplayState );
        
        String sectionTitleString = upcomingDisplayState.getTitle();
        
        int modifiedTaskID = Engine.lastModifiedTask();
        DisplayTask modifiedTask = (currentList != null ? currentList.getTaskByParentID(modifiedTaskID) : null);
        
        if( modifiedTask != null ){
            
            if( currentDisplayState.getdisplayStateFlag() != upcomingDisplayState.getdisplayStateFlag() ){
                
                displayStateStack.push(upcomingDisplayState);
            }
            
            updateGUIView( currentDisplayListForDate, currentDisplayListForPriority, sectionTitleString, modifiedTask.getParent() );
            
        } else{
            
            if( currentDisplayState.getdisplayStateFlag() != DisplayStateFlag.ALL ){
                
                Set<Map.Entry<Date, DisplayTaskList>> tempTaskList = Engine.getAllTasks();
                
                modifiedTask = getDisplayTaskByParentID(tempTaskList, modifiedTaskID);
                
                if( modifiedTask != null ){
                    
                    currentList = convertToDisplayTaskList(tempTaskList);
                    currentDisplayListForDate = tempTaskList;
                    currentDisplayListForPriority = null;
                    
                    displayStateStack.push(upcomingDisplayState);
                    
                    updateGUIView( currentDisplayListForDate, currentDisplayListForPriority, "All Tasks", modifiedTask.getParent() );
                    
                } else{
                    
                    messageType = 1;
                    isMessageDisplayed = true;
                    commandPanel.setText( "Fail to mark task as done", true );
                    
                    return;
                }
                
            } else{
                
                messageType = 1;
                isMessageDisplayed = true;
                commandPanel.setText( "Fail to mark task as done", true );
                
                return;
            }
        }

        messageType = 0;
        isMessageDisplayed = true;
        commandPanel.setText( "Task #" + modifiedTaskID + " marked done successfully", true );
    }
    
    private void handleDeleteOperation(){
        
        DisplayState currentDisplayState =  displayStateStack.peek();
        DisplayState upcomingDisplayState = updateCurrentList( currentDisplayState );
        
        String sectionTitleString = upcomingDisplayState.getTitle();
        
        if( currentDisplayState.getdisplayStateFlag() != upcomingDisplayState.getdisplayStateFlag() ){
            
            displayStateStack.push(upcomingDisplayState);
        }
        
        updateGUIView( currentDisplayListForDate, currentDisplayListForPriority, sectionTitleString, null );
        
        messageType = 0;
        isMessageDisplayed = true;
        commandPanel.setText( "Task deleted successfully", true );
    }
    
    private void handleInvalidOperation(){
        
        messageType = 1;
        isMessageDisplayed = true;
        
        String errorMessage = Constants.errorMessages.get(Engine.getErrorType());
        
        if( errorMessage != null ){
            
            commandPanel.setText( errorMessage, true );
            
        } else{
            
            commandPanel.setText( "Invalid Command", true );
        }
    }
    
    public void handleUnexpectedOperation(){
        
        messageType = 1;
        isMessageDisplayed = true;
        commandPanel.setText( "Feature not supported in V0.5", true );
    }
    
    public static void main(String[] args) {
        
        userInterfaceLogger.setLevel(java.util.logging.Level.SEVERE);
        
        EventQueue.invokeLater(new Runnable() {
            
            public void run() {
                
                try {
                    
                    UserInterface frame = new UserInterface();
                    frame.setVisible(true);
                    
                } catch (Exception e) {
                    
                    e.printStackTrace();
                    
                    JOptionPane.showMessageDialog(null, e.getMessage(), "", JOptionPane.ERROR_MESSAGE);
                }
                
            }
        });
    }

    public UserInterface() {
        
        // Initialise engine
        if( !Engine.init() ){
            
            JOptionPane.showMessageDialog(null, "Engine failed to initialise :(", "Error Message", JOptionPane.ERROR_MESSAGE);
            
            userInterfaceLogger.severe("Fail to intialise engine");
            
            System.exit(1);
        }
        
        // Initialize messages
        Constants.initializeErrorMessages();
        
        isMessageDisplayed = true;
        
        // Main frame
        setResizable(false);
        setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
        setDefaultCustomClosingFrameBehaviour();
        
        // Adding paintable component to main frame
        setBounds(100, 100, 867, 587);
        contentPane = new JPanel();
        setContentPane(contentPane);
        contentPane.setLayout(null);
        
        prepareCommandTextField();
        prepareDisplay();
        prepareCloseButton();
        prepareMinimiseButton();
        prepareSlidePanel();
        prepareLastCommandPanel();
        prepareNavigationPanel();
        prepareDragPanel();
        prepareSectionTitle();
        prepareSectionTitleLine();
        prepareBackground();
        
        if( displayPane != null ){
            
            prepareUpArrowButton(displayPane);
            
            prepareDownArrowButton(displayPane);
            
            prepareTaskDisplayPanel(displayPane);
        }
        
        inputList = new InputList(MAX_INPUT_LIST_SIZE);
        
        setUndecorated(true);
        setLocationRelativeTo(null);
    }
    
    private void setDefaultCustomClosingFrameBehaviour(){
        
        addWindowListener( new WindowAdapter(){

            @Override
            public void windowClosing(WindowEvent arg0) {

                handleExit();
            }
        });
    }
    
    private void showTutorialScreen( int tutorialIndex, String userInput, boolean isPrevCall ){
        
        currentDisplayListForDate = null;
        currentDisplayListForPriority = null;
        currentList = null;
        
        switch( tutorialIndex ){
        
            case Constants.ADD_TUTORIAL:

                displayStateStack.push(new DisplayState( planner.Constants.DisplayStateFlag.HELP_ADD, 
                        Constants.HELP_CONTENT[Constants.ADD_TUTORIAL][0], 
                        userInput, null ) );
                
                updateGUIView(currentDisplayListForDate, currentDisplayListForPriority, Constants.HELP_CONTENT[Constants.ADD_TUTORIAL][0], null);
                
                displayPane.addInfoToDisplay(Constants.HELP_CONTENT, Constants.ADD_TUTORIAL);
                
                break;
                
            case Constants.DELETE_TUTORIAL:
                
                displayStateStack.push(new DisplayState( planner.Constants.DisplayStateFlag.HELP_DELETE, 
                        Constants.HELP_CONTENT[Constants.DELETE_TUTORIAL][0], 
                        userInput, null ) );
                
                updateGUIView(currentDisplayListForDate, currentDisplayListForPriority, Constants.HELP_CONTENT[Constants.DELETE_TUTORIAL][0], null);
                
                displayPane.addInfoToDisplay(Constants.HELP_CONTENT, Constants.DELETE_TUTORIAL);
                
                break;
                
            case Constants.UPDATE_TUTORIAL:
                
                displayStateStack.push(new DisplayState( planner.Constants.DisplayStateFlag.HELP_UPDATE, 
                        Constants.HELP_CONTENT[Constants.UPDATE_TUTORIAL][0], 
                        userInput, null ) );
                
                updateGUIView(currentDisplayListForDate, currentDisplayListForPriority, Constants.HELP_CONTENT[Constants.UPDATE_TUTORIAL][0], null);
                
                displayPane.addInfoToDisplay(Constants.HELP_CONTENT, Constants.UPDATE_TUTORIAL);
                
                break;
            
            case Constants.DONE_TUTORIAL:
                
                displayStateStack.push(new DisplayState( planner.Constants.DisplayStateFlag.HELP_DONE, 
                        Constants.HELP_CONTENT[Constants.DONE_TUTORIAL][0], 
                        userInput, null ) );
                
                updateGUIView(currentDisplayListForDate, currentDisplayListForPriority, Constants.HELP_CONTENT[Constants.DONE_TUTORIAL][0], null);
                
                displayPane.addInfoToDisplay(Constants.HELP_CONTENT, Constants.DONE_TUTORIAL);
                
                break;
                
            case Constants.SEARCH_TUTORIAL:
                
                displayStateStack.push(new DisplayState( planner.Constants.DisplayStateFlag.HELP_SEARCH, 
                        Constants.HELP_CONTENT[Constants.SEARCH_TUTORIAL][0], 
                        userInput, null ) );
                
                updateGUIView(currentDisplayListForDate, currentDisplayListForPriority, Constants.HELP_CONTENT[Constants.SEARCH_TUTORIAL][0], null);
                
                displayPane.addInfoToDisplay(Constants.HELP_CONTENT, Constants.SEARCH_TUTORIAL);
                
                break;
                
            case Constants.UNDO_TUTORIAL:
                
                displayStateStack.push(new DisplayState( planner.Constants.DisplayStateFlag.HELP_UNDO, 
                        Constants.HELP_CONTENT[Constants.UNDO_TUTORIAL][0], 
                        userInput, null ) );
                
                updateGUIView(currentDisplayListForDate, currentDisplayListForPriority, Constants.HELP_CONTENT[Constants.UNDO_TUTORIAL][0], null);
                
                displayPane.addInfoToDisplay(Constants.HELP_CONTENT, Constants.UNDO_TUTORIAL);
                
                break;
            
            default:
                
                displayStateStack.push(new DisplayState( planner.Constants.DisplayStateFlag.HELP, "Tutorial", null, 
                        new KeyEvent( displayPane, KeyEvent.KEY_PRESSED, System.currentTimeMillis(),
                                      0, KeyEvent.VK_F3, '\0', KeyEvent.KEY_LOCATION_STANDARD) ) );
                
                updateGUIView(currentDisplayListForDate, currentDisplayListForPriority, "Tutorial", null);
                
                displayPane.addInfoToDisplay(Constants.HELP_CONTENT, -1);
                
                break;
        }
      
        if( !isPrevCall ){
            
            if( !commandInputField.isFocusOwner() && isMessageDisplayed ){
                
                messageType = 2;
                commandPanel.setForegroundColor(new Color(128,128,128));
                commandPanel.setText( "Enter Commands here", true );
            }
        }
    }
    
    private void prepareTaskDisplayPanel( DisplayPane displayPanel ){
        
        if( displayPanel != null ){
            
            taskDisplayPanel = displayPanel.getDisplayComponent();
            
            addKeyBindingsToTextView(taskDisplayPanel);
            
            userInterfaceLogger.info( "Task display panel set up successfully" );
            
        } else{
            
            userInterfaceLogger.severe("Task display panel fail to initialise");
        }
    }
    
    private void prepareDownArrowButton( DisplayPane displayPanel ){
        
        if( displayPanel != null ){
            
            downArrowButton = displayPanel.getDownButtonComponent();
            
            addKeyBindingsToButton(downArrowButton);
        }
    }
    
    private void prepareUpArrowButton( DisplayPane displayPanel ){
        
        if( displayPanel != null ){
            
            upArrowButton = displayPanel.getUpButtonComponent();
            
            addKeyBindingsToButton(upArrowButton);
        }
    }
    
    private void addKeyBindingsToTextView( JTextPane currentTextView ){
        
        if( currentTextView != null ){
            
            currentTextView.addKeyListener(new KeyAdapter(){

                @Override
                public void keyPressed(KeyEvent event) {
                    
                    handleKeyEvent(event);
                }
            });
        }
    }
    
    private void addKeyBindingsToButton( InvisibleButton currentArrowButton ){
        
        if( currentArrowButton != null ){
            
            currentArrowButton.addKeyListener(new KeyAdapter(){

                @Override
                public void keyPressed(KeyEvent event) {
                    
                    handleKeyEvent(event);
                }
            });
        }
    }
    
    private void updateNavigationBarTaskInfoContents( JTextPane inputField, ArrayList<NavigationBar> navigationBars, DisplayTask currentTask ){
        
        if( inputField != null && navigationBars != null && !navigationBars.isEmpty() && 
            currentTask != null && currentTask.getParent() != null ){
            
            NavigationBar tempNavigationBar = navigationBars.get(0);
            
            if( tempNavigationBar != null ){
                
                String additonalkey = (!inputField.isFocusOwner() ? "/Enter" : "");
                
                tempNavigationBar.setMessageToView(planner.Constants.NAVIGATION_BAR_STRING_CONTENTS[0] + currentTask.getParent().getID(), 
                        "F1"+additonalkey);
            }
        }
    }
    
    private char filterKeys( char keyCode ){
        
        if( (keyCode >= 32 && keyCode <= 126) || keyCode == 8 ){
            
            return keyCode;
            
        } else{
            
            return '\0';
        }
    }
    
    private void handleKeys( char keyTyped ){
        
        if( keyTyped >= 32 && keyTyped <= 126){
            
            characterToTransfer = keyTyped;
            isBackspacePressed = false;
            
        } else if( keyTyped == 8 ){
            
            characterToTransfer = '\0';
            isBackspacePressed = true;
            
        } else{
            
            characterToTransfer = '\0';
            isBackspacePressed = false;
        }
    }
    
    private boolean handleNavigationKeys(KeyEvent event){
        
        if( event != null ){
            
            if( event.getKeyCode() == KeyEvent.VK_F10 ){
                
                DisplayState currentDisplayState = displayStateStack.peek();
                
                if( currentDisplayState != null &&
                    currentDisplayState.getdisplayStateFlag() != planner.Constants.DisplayStateFlag.NOTDONE ){
                        
                    Set<Map.Entry<Date, DisplayTaskList>>tempTaskList = Engine.getUndoneTasks();
                    currentList = convertToDisplayTaskList(tempTaskList);
                    currentDisplayListForDate = tempTaskList;
                    currentDisplayListForPriority = null;
                    
                    displayStateStack.push(new DisplayState( planner.Constants.DisplayStateFlag.NOTDONE, "Ongoing Tasks", null, event ));
                    
                    updateGUIView( currentDisplayListForDate, currentDisplayListForPriority, "Ongoing Tasks", null );
                    
                    event.consume();
                    
                    return true;
                }
                
            } else if( event.getKeyCode() == KeyEvent.VK_F9 ){
                
                DisplayState currentDisplayState = displayStateStack.peek();
                
                if( currentDisplayState != null &&
                    currentDisplayState.getdisplayStateFlag() != planner.Constants.DisplayStateFlag.DONE ){
                        
                    Set<Map.Entry<Date, DisplayTaskList>>tempTaskList = Engine.getDoneTasks();
                    currentList = convertToDisplayTaskList(tempTaskList);
                    currentDisplayListForDate = tempTaskList;
                    currentDisplayListForPriority = null;
                    
                    displayStateStack.push(new DisplayState( planner.Constants.DisplayStateFlag.DONE, "Completed Tasks", null, event ));
                    
                    updateGUIView( currentDisplayListForDate, currentDisplayListForPriority, "Completed Tasks", null );
                    
                    event.consume();
                    
                    return true;
                }
                
            } else if( event.getKeyCode() == KeyEvent.VK_F8 ){
                
                DisplayState currentDisplayState = displayStateStack.peek();
                
                if( currentDisplayState != null &&
                    currentDisplayState.getdisplayStateFlag() != planner.Constants.DisplayStateFlag.OVERDUE ){
                        
                    Set<Map.Entry<Date, DisplayTaskList>>tempTaskList = Engine.getOverdueTasks();
                    currentList = convertToDisplayTaskList(tempTaskList);
                    currentDisplayListForDate = tempTaskList;
                    currentDisplayListForPriority = null;
                    
                    displayStateStack.push(new DisplayState( planner.Constants.DisplayStateFlag.OVERDUE, "Overdue Tasks", null, event ));
                    
                    updateGUIView( currentDisplayListForDate, currentDisplayListForPriority, "Overdue Tasks", null );
                    
                    event.consume();
                    
                    return true;
                }
                
            } else if( event.getKeyCode() == KeyEvent.VK_F7 ){
                
                DisplayState currentDisplayState = displayStateStack.peek();
                
                if( currentDisplayState != null &&
                    currentDisplayState.getdisplayStateFlag() != planner.Constants.DisplayStateFlag.TENTATIVE ){
                        
                    Set<Map.Entry<Integer, DisplayTaskList>>tempTaskList = Engine.getFloatingTasks();
                    currentList = convertToDisplayTaskList(tempTaskList);
                    currentDisplayListForDate = null;
                    currentDisplayListForPriority = tempTaskList;
                    
                    displayStateStack.push(new DisplayState( planner.Constants.DisplayStateFlag.TENTATIVE, "Floating Tasks", null, event ));
                    
                    updateGUIView( currentDisplayListForDate, currentDisplayListForPriority, "Floating Tasks", null );
                    
                    event.consume();
                    
                    return true;
                }
                
            } else if( event.getKeyCode() == KeyEvent.VK_F6 ){
                
                DisplayState currentDisplayState = displayStateStack.peek();
                
                if( currentDisplayState != null &&
                    currentDisplayState.getdisplayStateFlag() != planner.Constants.DisplayStateFlag.UPCOMING ){
                        
                    Set<Map.Entry<Date, DisplayTaskList>>tempTaskList = Engine.getUpcomingTasks();
                    currentList = convertToDisplayTaskList(tempTaskList);
                    currentDisplayListForDate = tempTaskList;
                    currentDisplayListForPriority = null;
                    
                    displayStateStack.push(new DisplayState( planner.Constants.DisplayStateFlag.UPCOMING, "Upcoming Tasks", null, event ));
                    
                    updateGUIView( currentDisplayListForDate, currentDisplayListForPriority, "Upcoming Tasks", null );
                    
                    event.consume();
                    
                    return true;
                }
                
            } else if( event.getKeyCode() == KeyEvent.VK_F5 ){
                
                DisplayState currentDisplayState = displayStateStack.peek();
                
                if( currentDisplayState != null &&
                    currentDisplayState.getdisplayStateFlag() != planner.Constants.DisplayStateFlag.ALL ){
                    
                    Set<Map.Entry<Date, DisplayTaskList>>tempTaskList = Engine.getAllTasks();
                    currentList = convertToDisplayTaskList(tempTaskList);
                    currentDisplayListForDate = tempTaskList;
                    currentDisplayListForPriority = null;
                    
                    displayStateStack.push(new DisplayState( planner.Constants.DisplayStateFlag.ALL, "All tasks", null, event ));
                    
                    updateGUIView( currentDisplayListForDate, currentDisplayListForPriority, "All Tasks", null );
                    
                    event.consume();
                    
                    return true;
                }
                
            } else if( event.getKeyCode() == KeyEvent.VK_F4 ){
                
                if( !event.isAltDown() ){
                    
                    DisplayState currentDisplayState = displayStateStack.peek();
                    
                    if( currentDisplayState != null &&
                        currentDisplayState.getdisplayStateFlag() != planner.Constants.DisplayStateFlag.TODAY ){
                        
                        Set<Map.Entry<Integer, DisplayTaskList>>tempTaskList = Engine.getTodayTasks();
                        currentList = convertToDisplayTaskList(tempTaskList);
                        currentDisplayListForDate = null;
                        currentDisplayListForPriority = tempTaskList;
                        
                        displayStateStack.push(new DisplayState( planner.Constants.DisplayStateFlag.TODAY, "Tasks due today", null, event ));
                        
                        updateGUIView( currentDisplayListForDate, currentDisplayListForPriority, "Tasks due today", null );
                        
                        event.consume();
                        
                        return true;
                    }
                }
                
            } else if(event.getKeyCode() == KeyEvent.VK_F3){
                
                showTutorialScreen( -1, null, false );
                
                event.consume();
                        
                return true;
                
            } else if( event.getKeyCode() == KeyEvent.VK_F2 ){
                
                handlePreviousViewOperation(displayStateStack);
                
                event.consume();
                
                return true;
                
            } else if( event.getKeyCode() == KeyEvent.VK_F1 ){
                
                if( !event.isShiftDown() ){
                    
                    DisplayTask tempTask = displayPane.getCurrentSelectedTask();
                    
                    if( tempTask != null && tempTask.getParent() != null ){
                        
                        //infoPanel.slideOut( tempTask.getParent(), true );
                        slideOut(infoPanel, tempTask.getParent());
                    }
                    
                } else{
                    
                    slideOut(lastCommandPanel, null);
                }
                
                event.consume();
                
                return true;
            }
        }
        
        return false;
    }
    
    private void handleKeyEvent(KeyEvent event){
        
        if( event != null ){
            
            if(  commandPanel != null ){
                
                if( commandPanel.handleKeyEvent(event) ){
                    
                    return;
                }
            }
            
            if( handleNavigationKeys(event) ){
                
                return;
            }
            
            if( event.getKeyCode() == KeyEvent.VK_PAGE_UP ){
                
                if( !displayPane.isFocusOwner() ){
                    
                    displayPane.requestFocusInWindow();
                }
                
                if( displayPane.hasTasksDisplayed() ){
                    
                    displayPane.selectTaskRelativeToCurrentSelectedTask(-8);
                    
                    event.consume();
                }
                
            } else if( event.getKeyCode() == KeyEvent.VK_PAGE_DOWN ){
                
                if( !displayPane.isFocusOwner() ){
                    
                    displayPane.requestFocusInWindow();
                }
                
                if( displayPane.hasTasksDisplayed() ){
                
                    displayPane.selectTaskRelativeToCurrentSelectedTask(8);
                    
                    event.consume();
                }
                
            }  else if( event.getKeyCode() == KeyEvent.VK_ESCAPE ){
         
                if( infoPanel.isVisible() || lastCommandPanel.isVisible() ){
                    
                    slideInAllPanelsExcept(null);
                    
                    event.consume();
                }
                
            } else if( event.getKeyCode() == KeyEvent.VK_UP ){
                
                if( event.isShiftDown() ){
                    
                    if( inputList != null && commandPanel != null && commandInputField != null ){
                        
                        String currentInput = commandInputField.getText();
                        
                        inputList.setRecentlyTypedString(currentInput);
                        
                        String prevInputString = inputList.getPrevInputString();
                        
                        if( prevInputString != null){
                            
                            commandPanel.setText(prevInputString, false);
                        }
                        
                        event.consume();
                        
                        return;
                    }
                }
                
                if( !displayPane.isFocusOwner() ){
                    
                    displayPane.requestFocusInWindow();
                }
                
                if( event.isControlDown() ){
                    
                    JScrollPane tempScrollPane = null;
                    
                    if( infoPanel != null && infoPanel.isVisible() ){
                        
                        tempScrollPane = infoPanel.getDisplayScrollComponent();
                        
                    } else if( lastCommandPanel != null && lastCommandPanel.isVisible() ){
                        
                        tempScrollPane = lastCommandPanel.getDisplayScrollComponent();
                    }
                    
                    if( tempScrollPane != null ){
                        
                        JScrollBar verticalScrollBar = tempScrollPane != null ? tempScrollPane.getVerticalScrollBar() : null;
                        
                        if( verticalScrollBar != null && verticalScrollBar.isVisible() ){
                            
                            int currentScrollValue = verticalScrollBar.getValue();
                            int tempScrollUnitDifference = -verticalScrollBar.getUnitIncrement(-1);
                            verticalScrollBar.setValue(currentScrollValue + tempScrollUnitDifference);
                            
                            event.consume();
                           
                            return;
                        }
                    }
                }
                
                displayPane.selectPreviousTask();
                
                if( currentNavigationBars != null && 
                    currentNavigationBars.size() > 0 && 
                    currentNavigationBars.get(0).isVisible() ){
                    
                    DisplayTask currentTask = displayPane.getCurrentSelectedTask();
                    
                    if( currentTask != null && currentTask.getParent() != null ){
                        
                        updateNavigationBarTaskInfoContents( commandInputField, currentNavigationBars, currentTask );
                    }
                }
                
                if( infoPanel.isVisible() ){
                    
                    DisplayTask tempTask = displayPane.getCurrentSelectedTask();
                    
                    if( tempTask != null && tempTask.getParent() != null ){
                        
                        infoPanel.populateDisplay(tempTask.getParent());
                    }
                }
                
                if( displayPane.hasTasksDisplayed() ){
                    
                    event.consume();
                }
                
            } else if( event.getKeyCode() == KeyEvent.VK_DOWN ){
                
                if( event.isShiftDown() ){
                    
                    if( inputList != null && commandPanel != null && commandInputField != null ){
                        
                        String currentInput = commandInputField.getText();
                        
                        inputList.setRecentlyTypedString(currentInput);
                        
                        String nextInputString = inputList.getNextInputString();
                        
                        if( nextInputString != null){
                            
                            commandPanel.setText(nextInputString, false);
                        }
                        
                        event.consume();
                        
                        return;
                    }
                }
                
                if( !displayPane.isFocusOwner() ){
                    
                    displayPane.requestFocusInWindow();
                }
                
                if( event.isControlDown() ){
                    
                    JScrollPane tempScrollPane = null;
                    
                    if( infoPanel != null && infoPanel.isVisible() ){
                        
                        tempScrollPane = infoPanel.getDisplayScrollComponent();
                        
                    } else if( lastCommandPanel != null && lastCommandPanel.isVisible() ){
                        
                        tempScrollPane = lastCommandPanel.getDisplayScrollComponent();
                    }
                    
                    if( tempScrollPane != null ){
                        
                        JScrollBar verticalScrollBar = tempScrollPane != null ? tempScrollPane.getVerticalScrollBar() : null;
                        
                        if( verticalScrollBar != null && verticalScrollBar.isVisible() ){
                        
                            int currentScrollValue = verticalScrollBar.getValue();
                            int tempScrollUnitDifference = verticalScrollBar.getUnitIncrement(1);
                            verticalScrollBar.setValue(currentScrollValue + tempScrollUnitDifference);
                            
                            event.consume();
                            
                            return;
                        }
                    }
                }
                
                displayPane.selectNextTask();
                
                if( currentNavigationBars != null && 
                        currentNavigationBars.size() > 0 && 
                        currentNavigationBars.get(0).isVisible() ){
                    
                    DisplayTask currentTask = displayPane.getCurrentSelectedTask();
                    
                    if( currentTask != null && currentTask.getParent() != null ){
                        
                        updateNavigationBarTaskInfoContents( commandInputField, currentNavigationBars, currentTask );
                    }
                }
                
                if( infoPanel.isVisible() ){
                    
                    DisplayTask tempTask = displayPane.getCurrentSelectedTask();
                    
                    if( tempTask != null && tempTask.getParent() != null ){
                        
                        infoPanel.populateDisplay(tempTask.getParent());
                    }
                }
                
                if( displayPane.hasTasksDisplayed() ){
                    event.consume();
                }
                
            } else{
                
                if( !commandInputField.isFocusOwner() ){
                    
                    if( event.getKeyCode() == KeyEvent.VK_ENTER ){
                        
                        DisplayTask tempTask = displayPane.getCurrentSelectedTask();
                        
                        if( tempTask != null && tempTask.getParent() != null ){
                            
                            //infoPanel.slideOut( tempTask.getParent(), true );
                            slideOut(infoPanel, tempTask.getParent());
                        }
                        
                        event.consume();
                        
                        return;
                        
                    } else{
                        
                        characterToTransfer = '\0';
                        isBackspacePressed = false;
                        
                        handleKeys( filterKeys(event.getKeyChar()) );
                        
                        commandInputField.requestFocusInWindow();
                        
                        event.consume();
                    }
                }
                
                if(event.getKeyCode() == KeyEvent.VK_BACK_SPACE ){
                    
                    if( commandInputField.getText().length() <= 0 ){
                        
                        event.consume();
                    } 
                    
                } else if( event.getKeyCode() == KeyEvent.VK_ENTER ){
                    
                    String input = commandInputField.getText();
                    
                    if( input.length() > 0 ){
                        
                        processCommand(input);
                        
                        displayPane.requestFocusInWindow();
                        
                        isMessageDisplayed = true;
                        
                    } else{
                        
                        event.consume();
                    }
                }
            }
        }
    }
    
    private void prepareSectionTitle(){
        
        sectionTitle = new JLabel();
        sectionTitle.setBounds(6, 30, 497, 33);
        sectionTitle.setFont( new Font( "Arial", Font.BOLD, 24 ) );
        sectionTitle.setForeground( new Color( 255,255,255,200 ) );
        sectionTitle.setHorizontalAlignment(SwingConstants.CENTER);
        contentPane.add(sectionTitle);
        
        if( displayStateStack != null ){
            DisplayState currentDisplayState = displayStateStack.peek();
            if( currentDisplayState != null ){
                
                sectionTitle.setText( currentDisplayState.getTitle() );
                return;
            }
        }
        sectionTitle.setText("All Tasks");
    }
    
    private void prepareSectionTitleLine(){
        
        sectionTitleLine = new JLabel();
        sectionTitleLine.setIcon(new ImageIcon(UserInterface.class.getResource("/planner/titleLine.png")));
        sectionTitleLine.setBounds(-142, 28, 643, 33);
        contentPane.add(sectionTitleLine);
    }
    
    private void prepareSlidePanel(){
        
        if( slidePanelFrame == null ){
            
            slidePanelFrame = new JPanel();
            slidePanelFrame.setBounds(670, 45, 396, 520);
            contentPane.add(slidePanelFrame);
            slidePanelFrame.setLayout(null);
            slidePanelFrame.setOpaque(false);
        }
        
        infoPanel = new SliderPanel(0, 198);
        infoPanel.setBounds(198, 0, 202, 520);
        slidePanelFrame.add(infoPanel);
    }
    
    private void prepareLastCommandPanel(){
        
        if( slidePanelFrame == null ){
            
            slidePanelFrame = new JPanel();
            slidePanelFrame.setBounds(670, 45, 396, 520);
            contentPane.add(slidePanelFrame);
            slidePanelFrame.setLayout(null);
            slidePanelFrame.setOpaque(false);
        }
        
        lastCommandPanel = new SliderPanel(0, 198);
        lastCommandPanel.setBounds(198, 0, 202, 520);
        slidePanelFrame.add(lastCommandPanel);
        
        int caretPosition = lastCommandPanel.getDisplayCaretPosition();
        
        SimpleAttributeSet titleStyle = new SimpleAttributeSet();
        StyleConstants.setFontFamily(titleStyle, "Arial");
        StyleConstants.setFontSize(titleStyle, 14);
        StyleConstants.setBold(titleStyle, true);
        StyleConstants.setForeground(titleStyle, Color.WHITE);
        StyleConstants.setUnderline(titleStyle, true);
        
        lastCommandPanel.insertStringToDisplay(caretPosition, "Recent Commands\n", titleStyle);
        
        caretPositionToAppendLastCommandString = lastCommandPanel.getDisplayCaretPosition();
    }
    
    private void updateCommandPanel( String userInput, String message, int messageType ){
        
        if( lastCommandPanel != null && userInput != null && message != null ){
            
            SimpleAttributeSet headerStyle = new SimpleAttributeSet();
            StyleConstants.setFontFamily(headerStyle, "Arial");
            StyleConstants.setFontSize(headerStyle, 13);
            StyleConstants.setBold(headerStyle, true);
            StyleConstants.setForeground(headerStyle, Color.WHITE);
            
            SimpleAttributeSet infoStyle = new SimpleAttributeSet();
            StyleConstants.setFontFamily(infoStyle, "Arial");
            StyleConstants.setFontSize(infoStyle, 12);
            StyleConstants.setBold(infoStyle, false);
            
            lastCommandPanel.setDisplayCaretPosition(caretPositionToAppendLastCommandString);
            
            lastCommandPanel.insertStringToDisplay(caretPositionToAppendLastCommandString, "\nYour Command:\n", headerStyle);
            
            StyleConstants.setForeground(infoStyle, new Color(125, 249, 255) );
            lastCommandPanel.insertStringToDisplay(lastCommandPanel.getDisplayCaretPosition(), userInput, infoStyle );
            
            if( messageType == 0 ){
                
                lastCommandPanel.insertStringToDisplay(lastCommandPanel.getDisplayCaretPosition(), "\nCommand Result:\n", headerStyle);
                StyleConstants.setForeground(infoStyle, Color.GREEN);
                lastCommandPanel.insertStringToDisplay(lastCommandPanel.getDisplayCaretPosition(), message, infoStyle );
                
            } else if( messageType == 1 ){
                
                lastCommandPanel.insertStringToDisplay(lastCommandPanel.getDisplayCaretPosition(), "\nCommand Result:\n", headerStyle);
                StyleConstants.setForeground(infoStyle, new Color(255, 102, 102));
                lastCommandPanel.insertStringToDisplay(lastCommandPanel.getDisplayCaretPosition(), message, infoStyle );
            }
            
            StyleConstants.setForeground(infoStyle, Color.WHITE);
            lastCommandPanel.insertStringToDisplay(lastCommandPanel.getDisplayCaretPosition(), "\n*********************************\n", infoStyle );
        }
    }
    
    private void slideInAllPanelsExcept( SliderPanel slidePanel ){
        
        if( infoPanel != null && slidePanel != infoPanel ){
            
            infoPanel.slideIn();   
        } 
        
        if( lastCommandPanel != null && slidePanel != lastCommandPanel ){
            
            lastCommandPanel.slideIn();
        }
    }
    
    private void slideOut( SliderPanel slidePanel, Task task ){
        
        if( infoPanel != null && slidePanel == infoPanel ){
            
            infoPanel.slideOut(task, true);
            slideInAllPanelsExcept(infoPanel);
            
        } else if( lastCommandPanel != null && slidePanel == lastCommandPanel ){
            
            lastCommandPanel.slideOut(null, false);
            slideInAllPanelsExcept(lastCommandPanel);
        }
    }
    
    private void prepareNavigationPanel(){
        
        navigationPanel = new JTextPane();
        navigationPanel.setBounds(10, 0, 188, 519);
        slidePanelFrame.add(navigationPanel);
        
        navigationPanel.setEditable(false);
        navigationPanel.setOpaque(false);
        navigationPanel.setBorder(null);
        navigationPanel.setHighlighter(null);
        navigationPanel.setFocusable(false);
        navigationPanel.setFont( new Font( "Arial", Font.PLAIN, 2 ) );
        
        navigationPanel.setText( "\n\n\n\n\n\n\n\n\n\n\n\n\n" );
        
        currentNavigationBars = generateContentForNavigationBars( displayStateStack.peek() );
        addNavigationBarsToPanel(currentNavigationBars);
    }
    
    private ArrayList<NavigationBar> generateContentForNavigationBars( DisplayState currentDisplayState ){
        
        ArrayList<NavigationBar> tempList = new ArrayList<NavigationBar>();
        
        if( planner.Constants.NAVIGATION_BAR_STRING_CONTENTS_SIZE == planner.Constants.NAVIGATION_BAR_STRING_CONTENTS.length ){
            
            int key = 1;
            
            // More info on current task
            if( currentList != null && currentList.size() > 0 ){
                
                DisplayTask tempTask = displayPane.getCurrentSelectedTask();
                          
                if( tempTask != null && tempTask.getParent() != null ){
                    
                    String additonalkey = (!commandInputField.isFocusOwner() ? "/Enter" : "");
                    
                    tempList.add( new NavigationBar( 
                            planner.Constants.NAVIGATION_BAR_STRING_CONTENTS[0] + tempTask.getParent().getID(), 
                            "F" + key + additonalkey ) );
                    
                } else{
                    
                    tempList.add( new NavigationBar(null) );
                }
                
            } else{
                
                tempList.add( new NavigationBar(null) );
            }
            ++key;
            
            // Previous view
            if( displayStateStack.size() > 1 ){
                
                tempList.add( new NavigationBar( planner.Constants.NAVIGATION_BAR_STRING_CONTENTS[1], "F" + key ) );
                
            } else{
                
                tempList.add( new NavigationBar(null) );
            }
            ++key;
            
            // tutorial
            if( currentDisplayState != null ){
                
                if( currentDisplayState.getdisplayStateFlag() != planner.Constants.DisplayStateFlag.HELP ){
                    
                    tempList.add( new NavigationBar( planner.Constants.NAVIGATION_BAR_STRING_CONTENTS[2], "F" + key ));
                    
                } else{
                    
                    tempList.add( new NavigationBar( planner.Constants.NAVIGATION_BAR_STRING_CONTENTS[2] ) );
                }
                
            } else{
                
                tempList.add( new NavigationBar(null) );
            }
            ++key;
            
            // Today tasks
            if( currentDisplayState != null ){
                
                int taskListSize = Engine.getTodayTasksSize();
                
                if( currentDisplayState.getdisplayStateFlag() != planner.Constants.DisplayStateFlag.TODAY ){
                    
                    if( taskListSize == 1 ){
                        
                        tempList.add( new NavigationBar( taskListSize + planner.Constants.NAVIGATION_BAR_STRING_CONTENTS[3], "F" + key ));
                        
                    } else{
                        
                        tempList.add( new NavigationBar( taskListSize + planner.Constants.NAVIGATION_BAR_STRING_CONTENTS[4], "F" + key ));
                    }
                    
                } else{
                    
                    if( taskListSize == 1 ){
                        
                        tempList.add( new NavigationBar( taskListSize + planner.Constants.NAVIGATION_BAR_STRING_CONTENTS[3] ));
                        
                    } else{
                        
                        tempList.add( new NavigationBar( taskListSize + planner.Constants.NAVIGATION_BAR_STRING_CONTENTS[4] ));
                    }
                }
                
            } else{
                
                tempList.add( new NavigationBar(null) );
            }
            ++key;
            
            // all tasks
            if( currentDisplayState != null ){
                
                int taskListSize = Engine.getAllTasksSize();
                
                if( currentDisplayState.getdisplayStateFlag() != planner.Constants.DisplayStateFlag.ALL ){
                    
                    if( taskListSize == 1 ){
                        
                        tempList.add( new NavigationBar( taskListSize + planner.Constants.NAVIGATION_BAR_STRING_CONTENTS[5], "F" + key ));
                        
                    } else{
                        
                        tempList.add( new NavigationBar( taskListSize + planner.Constants.NAVIGATION_BAR_STRING_CONTENTS[6], "F" + key ));
                    }
                    
                } else{
                    
                    if( taskListSize == 1 ){
                        
                        tempList.add( new NavigationBar( taskListSize + planner.Constants.NAVIGATION_BAR_STRING_CONTENTS[5] ));
                        
                    } else{
                        
                        tempList.add( new NavigationBar( taskListSize + planner.Constants.NAVIGATION_BAR_STRING_CONTENTS[6] ));
                    }
                }
                
            } else{
                
                tempList.add( new NavigationBar(null) );
            }
            ++key;
            
            // Upcoming Tasks
            if( currentDisplayState != null ){
                
                int taskListSize = Engine.getUpcomingTasksSize();
                
                if( currentDisplayState.getdisplayStateFlag() != planner.Constants.DisplayStateFlag.UPCOMING ){
                    
                    if( taskListSize == 1 ){
                        
                        tempList.add( new NavigationBar( taskListSize + planner.Constants.NAVIGATION_BAR_STRING_CONTENTS[7], "F" + key ));
                        
                    } else{
                        
                        tempList.add( new NavigationBar( taskListSize + planner.Constants.NAVIGATION_BAR_STRING_CONTENTS[8], "F" + key ));
                    }
                    
                } else{
                    
                    if( taskListSize == 1 ){
                        
                        tempList.add( new NavigationBar( taskListSize + planner.Constants.NAVIGATION_BAR_STRING_CONTENTS[7] ));
                        
                    } else{
                        
                        tempList.add( new NavigationBar( taskListSize + planner.Constants.NAVIGATION_BAR_STRING_CONTENTS[8] ));
                    }
                }
                
            } else{
                
                tempList.add( new NavigationBar( null ) );
            }
            ++key;
            
            // Tentative tasks
            if( currentDisplayState != null ){
                
                int taskListSize = Engine.getFloatingTasksSize();
                
                if( currentDisplayState.getdisplayStateFlag() != planner.Constants.DisplayStateFlag.TENTATIVE ){
                    
                    if( taskListSize == 1 ){
                        
                        tempList.add( new NavigationBar( taskListSize + planner.Constants.NAVIGATION_BAR_STRING_CONTENTS[9], "F" + key ));
                        
                    } else{
                        
                        tempList.add( new NavigationBar( taskListSize + planner.Constants.NAVIGATION_BAR_STRING_CONTENTS[10], "F" + key ));
                    }
                    
                } else{
                    
                    if( taskListSize == 1 ){
                        
                        tempList.add( new NavigationBar( taskListSize + planner.Constants.NAVIGATION_BAR_STRING_CONTENTS[9] ));
                        
                    } else{
                        
                        tempList.add( new NavigationBar( taskListSize + planner.Constants.NAVIGATION_BAR_STRING_CONTENTS[10]));
                    }
                }
                
            } else{
                
                tempList.add( new NavigationBar( null ) );
            }
            ++key;
            
            // Overdue tasks
            if( currentDisplayState != null ){
                
                int taskListSize = Engine.getOverdueTasksSize();
                
                if( currentDisplayState.getdisplayStateFlag() != planner.Constants.DisplayStateFlag.OVERDUE ){
                    
                    if( taskListSize == 1 ){
                        
                        tempList.add( new NavigationBar( taskListSize + planner.Constants.NAVIGATION_BAR_STRING_CONTENTS[11], "F" + key ));
                        
                    } else{
                        
                        tempList.add( new NavigationBar( taskListSize + planner.Constants.NAVIGATION_BAR_STRING_CONTENTS[12], "F" + key ));
                    }
                    
                } else{
                    
                    if( taskListSize == 1 ){
                        
                        tempList.add( new NavigationBar( taskListSize + planner.Constants.NAVIGATION_BAR_STRING_CONTENTS[11] ));
                        
                    } else{
                        
                        tempList.add( new NavigationBar( taskListSize + planner.Constants.NAVIGATION_BAR_STRING_CONTENTS[12] ));
                    }
                }

            } else{
                
                tempList.add( new NavigationBar( null ) );
            }
            ++key;
            
            // Done tasks
            if( currentDisplayState != null ){
                
                int taskListSize = Engine.getDoneTasksSize();
                
                if( currentDisplayState.getdisplayStateFlag() != planner.Constants.DisplayStateFlag.DONE ){
                    
                    if( taskListSize == 1 ){
                        
                        tempList.add( new NavigationBar( taskListSize + planner.Constants.NAVIGATION_BAR_STRING_CONTENTS[13], "F" + key ));
                        
                    } else{
                        
                        tempList.add( new NavigationBar( taskListSize + planner.Constants.NAVIGATION_BAR_STRING_CONTENTS[14], "F" + key ));
                    }
                    
                } else{
                    
                    if( taskListSize == 1 ){
                        
                        tempList.add( new NavigationBar( taskListSize + planner.Constants.NAVIGATION_BAR_STRING_CONTENTS[13] ));
                        
                    } else{
                        
                        tempList.add( new NavigationBar( taskListSize + planner.Constants.NAVIGATION_BAR_STRING_CONTENTS[14] ));
                    }
                }
                
            } else{
                
                tempList.add( new NavigationBar( null ) );
            }
            ++key;
            
            //Undone Tasks
            if( currentDisplayState != null ){
                
                int taskListSize = Engine.getUndoneTasksSize();
                
                if( currentDisplayState.getdisplayStateFlag() != planner.Constants.DisplayStateFlag.NOTDONE ){
                    
                    if( taskListSize == 1 ){
                        
                        tempList.add( new NavigationBar( taskListSize + planner.Constants.NAVIGATION_BAR_STRING_CONTENTS[15], "F" + key ));
                        
                    } else{
                        
                        tempList.add( new NavigationBar( taskListSize + planner.Constants.NAVIGATION_BAR_STRING_CONTENTS[16], "F" + key ));
                    }
                    
                } else{
                    
                    if( taskListSize == 1 ){
                        
                        tempList.add( new NavigationBar( taskListSize + planner.Constants.NAVIGATION_BAR_STRING_CONTENTS[15] ));
                        
                    } else{
                        
                        tempList.add( new NavigationBar( taskListSize + planner.Constants.NAVIGATION_BAR_STRING_CONTENTS[16] ));
                    }
                }
                
            } else{
                
                tempList.add( new NavigationBar( null ) );
            }
            ++key;
        }
        
        return tempList;
    }
    
    private void addNavigationBarsToPanel( ArrayList<NavigationBar> listOfNavigationBarComponents ){
        
        try{
            
            if( listOfNavigationBarComponents != null && listOfNavigationBarComponents.size() > 0 ){

                navigationPanel.setText("\n\n\n\n\n\n\n\n\n\n\n\n\n");
                
                StyledDocument styledDocument = navigationPanel.getStyledDocument();
                
                Iterator<NavigationBar> iterator = listOfNavigationBarComponents.iterator();
                
                NavigationBar tempNavigationBar;
                
                while( iterator.hasNext() ){
                    
                    tempNavigationBar = iterator.next();
                    
                    if( tempNavigationBar.isVisible() ){
                        
                        Style style = styledDocument.addStyle("component", null);
                        StyleConstants.setComponent(style, tempNavigationBar);
                        
                        styledDocument.insertString( styledDocument.getLength(), "component", style );
                    }
                }
            }
            
        } catch( BadLocationException badLocationException ){}
    }
    
    private void prepareBackground(){
        
        // Adding UI background
        background = new JLabel();
        background.setIcon(new ImageIcon(UserInterface.class.getResource("/planner/UI_Pic.png")));
        background.setBounds(0, 0, 867, 587);
        contentPane.add(background);
    }
    
    private void prepareDisplay(){
        
        displayPane = new DisplayPane();
        displayPane.setBounds(25, 83, 630, 430);
        
        contentPane.add(displayPane);
        
        displayStateStack = new DisplayStateStack(maxNumOfDisplayStates);
        
        // Copying of all tasks
        
        if( !Engine.isFirstRun() ){
            
            currentDisplayListForDate = Engine.getUpcomingTasks();
            currentDisplayListForPriority = null;
            
            currentList = convertToDisplayTaskList( currentDisplayListForDate );
            
            displayPane.displayByDate(currentDisplayListForDate);
            
            displayStateStack.push(new DisplayState( planner.Constants.DisplayStateFlag.UPCOMING, "Upcoming Tasks", null, 
                    new KeyEvent( displayPane, KeyEvent.KEY_PRESSED, System.currentTimeMillis(),
                                  0, KeyEvent.VK_F6, '\0', KeyEvent.KEY_LOCATION_STANDARD) ) );
            
        } else{
           
            currentDisplayListForDate = null;
            currentDisplayListForPriority = null;
            currentList = null;
            
            displayStateStack.push(new DisplayState( planner.Constants.DisplayStateFlag.HELP, "Tutorial", null, 
                    new KeyEvent( displayPane, KeyEvent.KEY_PRESSED, System.currentTimeMillis(),
                                  0, KeyEvent.VK_F3, '\0', KeyEvent.KEY_LOCATION_STANDARD) ) );
            
            displayPane.addInfoToDisplay(Constants.HELP_CONTENT, -1);
        }
        
        displayPane.requestFocusInWindow();
        
        addKeyBindingsToDisplay(displayPane);
    }
    
    private void addKeyBindingsToDisplay( DisplayPane currentDisplayPane ){
        
        if( currentDisplayPane != null ){
            
            currentDisplayPane.addKeyListener(new KeyAdapter(){

                @Override
                public void keyPressed(KeyEvent event) {
                    
                    handleKeyEvent(event);
                }
            });
        }
    }
    
    private ArrayList<Map.Entry<String, ArrayList<String>>> generateTutorialStringMappings( String [][]possibleCommands ){
        
        ArrayList<Map.Entry<String, ArrayList<String>>> mapping = new ArrayList<Map.Entry<String, ArrayList<String>>>();
        
        if( possibleCommands != null ){
            
            String sectionHeaderString;
            String []tempStringArray;
            ArrayList<String> newList = null;
            for( int i = 0; i < possibleCommands.length; ++i ){
                
                tempStringArray = possibleCommands[i];
                
                for( int j = 0; j < tempStringArray.length; ++j ){
                    
                    if( j > 0 ){
                        
                        newList.add(tempStringArray[j]);
                        
                    } else{
                        
                        newList = new ArrayList<String>();
                        
                        sectionHeaderString = tempStringArray[j];
                        
                        if( sectionHeaderString != null ){
                            
                            mapping.add( new AbstractMap.SimpleEntry<String, ArrayList<String>>( sectionHeaderString, newList ) );
                            
                        } else{
                            
                            break;
                        }
                    }
                }
            }
        }
        
        return mapping;
    }
    
    private void prepareCommandTextField(){
        
        // New command
        ArrayList<Map.Entry<String, ArrayList<String>>> possibleCommands = generateTutorialStringMappings( Constants.POSSIBLE_COMMANDS );
        
        commandPanel = new CommandTextbox( Constants.COMMAND_KEYWORDS, Constants.NONCOMMAND_KEYWORDS, possibleCommands );
        commandPanel.setBounds(34, 530, 610, 60);
        contentPane.add(commandPanel);
        commandInputField = commandPanel.getTextDisplay();
        commandPanel.setFontAttributes(new Font( "Arial", Font.BOLD, 20 ));
        commandPanel.setForegroundColor(new Color( 128,128,128 ));
        messageType = 2;
        commandPanel.setText("Enter commands here", true);
        
        addKeyBindingsToCommandTextField(commandInputField);
        addFocusListenerToCommandTextField( commandPanel, commandInputField );
        
        popupBox = commandPanel.getPopupBox();
        
        addKeyBindingsToPopupBox(popupBox);
        
        characterToTransfer = '\0';
        isBackspacePressed = false;
    }
    
    private void addKeyBindingsToPopupBox( final JComboBox<String> currentPopupBox ){
        
        if( currentPopupBox != null ){
            
            currentPopupBox.addKeyListener(new KeyListener(){

                @Override
                public void keyPressed(KeyEvent e) {
                    
                    if( handleNavigationKeys(e) ){
                        
                        return;
                    }
                }

                @Override
                public void keyReleased(KeyEvent e) {
                    
                    if( handleNavigationKeys(e) ){
                        
                        return;
                    }
                }

                @Override
                public void keyTyped(KeyEvent e) {
                    
                    if( handleNavigationKeys(e) ){
                        
                        return;
                    }
                }
                
            });
        }
    }
    
    private void addKeyBindingsToCommandTextField( JTextPane currentCommand ){
        
        if( currentCommand != null ){
            
            currentCommand.addKeyListener(new KeyListener(){
                
                @Override
                public void keyPressed( KeyEvent e ){
                        
                    handleKeyEvent(e);
                    
                    characterToTransfer = '\0';
                    isBackspacePressed = false;
                    
                    return;
                }
        
                @Override
                public void keyTyped(KeyEvent e) {
                    
                    if( characterToTransfer != '\0' ){
                        
                        e.consume();
                    }
                    
                    return;
                }
        
                @Override
                public void keyReleased(KeyEvent e) {
                    
                    e.consume();
                    
                    return;
                }
            });
        }
    }
    
    private void addFocusListenerToCommandTextField( final CommandTextbox commandTextbox, final JTextPane currentCommand ){
        
        if(currentCommand != null && commandTextbox != null){
            
            currentCommand.addFocusListener(new FocusListener(){

                @Override
                public void focusGained(FocusEvent e) {
                    
                    if( inputList != null ){
                        
                        inputList.resetGetWordPosition();
                    }
                    
                    commandTextbox.setSyntaxFilterOn();
                    
                    commandTextbox.setForegroundColor( new Color( 0,0,0 ) );
                    
                    String additionalCharacterToAdd = (characterToTransfer != '\0' ? characterToTransfer + "" : "");
                    
                    if( isMessageDisplayed ){
                        
                        commandTextbox.setText(additionalCharacterToAdd, false);
                        
                        isMessageDisplayed = false;
                        
                    } else{
                        
                        String finalString = currentCommand.getText() + additionalCharacterToAdd;
                        
                        if( isBackspacePressed && finalString.length() > 0 ){
                            
                            finalString = finalString.substring(0, finalString.length()-1);
                        }
                        
                        commandTextbox.setText(finalString, false);
                    }
                    
                    if( currentNavigationBars.get(0).isVisible() 
                        && displayPane.getCurrentSelectedTask() != null 
                        && displayPane.getCurrentSelectedTask().getParent() != null ){
                           
                        updateNavigationBarTaskInfoContents( commandInputField, currentNavigationBars, displayPane.getCurrentSelectedTask() );
                    }
                    
                    messageType = 2;
                }

                @Override
                public void focusLost(FocusEvent e) {
                    
                    if( inputList != null ){
                       
                        inputList.resetGetWordPosition();
                    }
                    
                    commandTextbox.setSyntaxFilterOff();
                    
                    commandTextbox.hidePopupBox();
                    
                    commandTextbox.setForegroundColor( new Color( 255,0,0 ) );
                    
                    if( messageType == 0 ){
                        
                        commandTextbox.setForegroundColor( new Color( 0,100,0 ) );
                        
                    } else if( messageType == 1 ){
                        
                        commandTextbox.setForegroundColor( new Color( 255,0,0 ) );
                        
                    } else{
                        
                        commandTextbox.setForegroundColor( new Color( 128,128,128 ) );
                    }
                    
                    String input = currentCommand.getText();
                    
                    if( !isMessageDisplayed && input.length() <= 0 ){
                        
                        commandTextbox.setText("Enter commands here", true);
                        
                        isMessageDisplayed = true;
                        
                    } else{
                        
                        commandTextbox.setText(input, true);
                    }
                    
                    characterToTransfer = '\0';
                    isBackspacePressed = false;
                    
                    if( currentNavigationBars.get(0).isVisible() 
                            && displayPane.getCurrentSelectedTask() != null 
                            && displayPane.getCurrentSelectedTask().getParent() != null ){
                           
                           String messageTitle = planner.Constants.NAVIGATION_BAR_STRING_CONTENTS[0] + displayPane.getCurrentSelectedTask().getParent().getID();
                           
                           currentNavigationBars.get(0).setMessageToView(messageTitle, "F1/Enter" );
                       }
                    
                    messageType = 2;
                }
            });
        }
    }

    private void prepareCloseButton(){
        
        closeButton = new JLabel();
        closeButton.setBounds(819, 13, 27, 27);
        contentPane.add(closeButton);
        
        closeButton.setCursor(new Cursor( Cursor.HAND_CURSOR ));
        
        addMouseActionListenersToCloseButton(closeButton);
    }

    private void addMouseActionListenersToCloseButton( JLabel currentCloseButton ){
        
        if( currentCloseButton != null ){
            
            currentCloseButton.addMouseListener( new MouseInputAdapter(){

                @Override
                public void mouseClicked(MouseEvent e) {
                    
                    if( javax.swing.SwingUtilities.isLeftMouseButton(e) ){
                        
                        handleExit();
                    }
                }
            });
        }
    }
    
    private void prepareMinimiseButton(){
        
        minimiseButton = new JLabel();
        minimiseButton.setBounds(782, 12, 28, 28);
        contentPane.add(minimiseButton);
        
        minimiseButton.setCursor(new Cursor( Cursor.HAND_CURSOR ));
        
        addMouseActionListenersToMinimiseButton(minimiseButton);
    }

    private void addMouseActionListenersToMinimiseButton( JLabel currentMinimiseButton ){
        
        if( currentMinimiseButton != null ){
            
            currentMinimiseButton.addMouseListener( new MouseInputAdapter(){

                @Override
                public void mouseClicked(MouseEvent e) {
                    
                    if( javax.swing.SwingUtilities.isLeftMouseButton(e) ){
                        
                        setState( UserInterface.ICONIFIED );
                    }
                }
                
            } );
        }
    }
    
    private void prepareDragPanel(){
        
        dragPanel = new JLabel();
        dragPanel.setBounds(0, 0, 867, 587);
        contentPane.add(dragPanel);
        
        addMouseMovementBindingsToDragPanel(dragPanel);
        addMouseActionListenersToDragPanel(dragPanel);
    }
    
    private void addMouseMovementBindingsToDragPanel( JLabel currentDragPanel ){
        
        if( currentDragPanel != null ){
            
            currentDragPanel.addMouseMotionListener( new MouseMotionAdapter(){ 
    
                @Override
                public void mouseDragged(MouseEvent e) {
                    
                    int mouseDragXCoordinate = e.getXOnScreen();
                    int mouseDragYCoordinate = e.getYOnScreen();
                    
                    setLocation( mouseDragXCoordinate - mouseXCoordinate,
                                 mouseDragYCoordinate - mouseYCoordinate);
                }                
            });
        }
    }
    
    private void addMouseActionListenersToDragPanel( JLabel currentDragPanel ){
        
        if( currentDragPanel != null ){
            
            currentDragPanel.addMouseListener( new MouseInputAdapter(){ 

                @Override
                public void mousePressed(MouseEvent e) {
                    
                    mouseXCoordinate = e.getX();
                    mouseYCoordinate = e.getY();
                }
            });
        }
    }
}

	// End of segment: C:\Users\GamePro-Pc\Desktop\Work\Y2S2\CS2103\main\source\src\planner\UserInterface.java





	/**
	 * origin: C:\Users\GamePro-Pc\Desktop\Work\Y2S2\CS2103\main\source\src\planner\WrappingLabelLayout.java
	 */


package planner;

import javax.swing.text.Element;
import javax.swing.text.LabelView;
import javax.swing.text.View;

/**
* The WrappingLabelLayout class handles the layout of the editor kit used for wrapping text
*
	// End of segment: C:\Users\GamePro-Pc\Desktop\Work\Y2S2\CS2103\main\source\src\planner\WrappingLabelLayout.java





	/**
	 * origin: C:\Users\GamePro-Pc\Desktop\Work\Y2S2\CS2103\main\source\src\planner\WrappingLabelLayout.java
	 */

*/
public class WrappingLabelLayout extends LabelView{

    private final float DEFAULT_MINIMUM_SPAN = 0.0f;
    
    /**
     * Constructs the layout for the editor kit used for wrapping text
     */
    public WrappingLabelLayout( Element element ){
        super(element);
    }
    
    /**
     * Returns the minimum span of the layout
     * 
     * @param axis     The orientation of the layout
     * @return         The minimum span of the layout
     */
    @Override
    public float getMinimumSpan( int axis ){
        if( axis == View.Y_AXIS ){
            return super.getMinimumSpan(axis);
        } else{
            return DEFAULT_MINIMUM_SPAN;
        }
    }
}

	// End of segment: C:\Users\GamePro-Pc\Desktop\Work\Y2S2\CS2103\main\source\src\planner\WrappingLabelLayout.java





	/**
	 * origin: C:\Users\GamePro-Pc\Desktop\Work\Y2S2\CS2103\main\source\src\planner\WrapTextLogic.java
	 */


package planner;

import javax.swing.text.AbstractDocument;
import javax.swing.text.BoxView;
import javax.swing.text.ComponentView;
import javax.swing.text.Element;
import javax.swing.text.IconView;
import javax.swing.text.LabelView;
import javax.swing.text.ParagraphView;
import javax.swing.text.StyleConstants;
import javax.swing.text.View;
import javax.swing.text.ViewFactory;

/**
* The NoWrapTextLogic class handles the logic of wrapping text for the editor kit implementing wrapping text behavior
*
	// End of segment: C:\Users\GamePro-Pc\Desktop\Work\Y2S2\CS2103\main\source\src\planner\WrapTextLogic.java





	/**
	 * origin: C:\Users\GamePro-Pc\Desktop\Work\Y2S2\CS2103\main\source\src\planner\WrapTextLogic.java
	 */

*/
public class WrapTextLogic implements ViewFactory{

    /**
     * Returns the view required for the document containing the text to be displayed
     * 
     * @param element     An object representing the document containing the text to be displayed
     * @return            The view required for the document containing the text to be displayed
     */
    @Override
    public View create( Element element ){
        String viewType = element.getName();
        if( viewType != null ){
            if( viewType.equals( AbstractDocument.ParagraphElementName ) ){
                return new ParagraphView(element);
            } else if( viewType.equals( AbstractDocument.ContentElementName ) ){
                return new WrappingLabelLayout(element);
            } else if( viewType.equals( AbstractDocument.SectionElementName ) ){
                return new BoxView( element, View.Y_AXIS );
            } else if( viewType.equals( StyleConstants.IconElementName ) ){
                return new IconView(element);
            } else if( viewType.equals( StyleConstants.ComponentElementName) ){
                return new ComponentView(element);
            }
        }
        return new LabelView(element);
    }
}

	// End of segment: C:\Users\GamePro-Pc\Desktop\Work\Y2S2\CS2103\main\source\src\planner\WrapTextLogic.java





	/**
	 * origin: C:\Users\GamePro-Pc\Desktop\Work\Y2S2\CS2103\main\source\test\planner\testCommandPanelDocumentFilter.java
	 */


package planner;

import static org.junit.Assert.assertEquals;

import org.junit.Test;

public class testCommandPanelDocumentFilter {

    @Test
    public void testRegularStringArray() {
       
        CustomTextFieldDocumentFilter commandPanelDocumentFilter = new CustomTextFieldDocumentFilter();
        
        String []keywords = { "nice", "done" };
        
        String regexOutput = commandPanelDocumentFilter.generateRegex(keywords);
        
        assertEquals( regexOutput, "(\\bnice\\b|\\bdone\\b)" );
    }
    
    @Test
    public void testStringArrayContainingNull() {
        
        CustomTextFieldDocumentFilter commandPanelDocumentFilter = new CustomTextFieldDocumentFilter();
        
        String []keywords = { "nice", null, "done" };
        
        String regexOutput = commandPanelDocumentFilter.generateRegex(keywords);
        
        assertEquals( regexOutput, "(\\bnice\\b|\\bdone\\b)" );
    }

    @Test
    public void testNullStringArray(){
        
        CustomTextFieldDocumentFilter commandPanelDocumentFilter = new CustomTextFieldDocumentFilter();
        
        String regexOutput = commandPanelDocumentFilter.generateRegex(null);
        
        assertEquals( regexOutput, "()" );
    }
}

	// End of segment: C:\Users\GamePro-Pc\Desktop\Work\Y2S2\CS2103\main\source\test\planner\testCommandPanelDocumentFilter.java





